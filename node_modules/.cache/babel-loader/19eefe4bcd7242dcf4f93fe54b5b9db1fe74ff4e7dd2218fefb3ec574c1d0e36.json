{"ast":null,"code":"import * as echarts from 'echarts/lib/echarts';\nexport default echarts.graphic.extendShape({\n  type: 'ec-liquid-fill',\n  shape: {\n    waveLength: 0,\n    radius: 0,\n    radiusY: 0,\n    cx: 0,\n    cy: 0,\n    waterLevel: 0,\n    amplitude: 0,\n    phase: 0,\n    inverse: false\n  },\n  buildPath: function (ctx, shape) {\n    if (shape.radiusY == null) {\n      shape.radiusY = shape.radius;\n    }\n\n    /**\n     * We define a sine wave having 4 waves, and make sure at least 8 curves\n     * is drawn. Otherwise, it may cause blank area for some waves when\n     * wave length is large enough.\n     */\n    var curves = Math.max(Math.ceil(2 * shape.radius / shape.waveLength * 4) * 2, 8);\n\n    // map phase to [-Math.PI * 2, 0]\n    while (shape.phase < -Math.PI * 2) {\n      shape.phase += Math.PI * 2;\n    }\n    while (shape.phase > 0) {\n      shape.phase -= Math.PI * 2;\n    }\n    var phase = shape.phase / Math.PI / 2 * shape.waveLength;\n    var left = shape.cx - shape.radius + phase - shape.radius * 2;\n\n    /**\n     * top-left corner as start point\n     *\n     * draws this point\n     *  |\n     * \\|/\n     *  ~~~~~~~~\n     *  |      |\n     *  +------+\n     */\n    ctx.moveTo(left, shape.waterLevel);\n\n    /**\n     * top wave\n     *\n     * ~~~~~~~~ <- draws this sine wave\n     * |      |\n     * +------+\n     */\n    var waveRight = 0;\n    for (var c = 0; c < curves; ++c) {\n      var stage = c % 4;\n      var pos = getWaterPositions(c * shape.waveLength / 4, stage, shape.waveLength, shape.amplitude);\n      ctx.bezierCurveTo(pos[0][0] + left, -pos[0][1] + shape.waterLevel, pos[1][0] + left, -pos[1][1] + shape.waterLevel, pos[2][0] + left, -pos[2][1] + shape.waterLevel);\n      if (c === curves - 1) {\n        waveRight = pos[2][0];\n      }\n    }\n    if (shape.inverse) {\n      /**\n       * top-right corner\n       *                  2. draws this line\n       *                          |\n       *                       +------+\n       * 3. draws this line -> |      | <- 1. draws this line\n       *                       ~~~~~~~~\n       */\n      ctx.lineTo(waveRight + left, shape.cy - shape.radiusY);\n      ctx.lineTo(left, shape.cy - shape.radiusY);\n      ctx.lineTo(left, shape.waterLevel);\n    } else {\n      /**\n       * top-right corner\n       *\n       *                       ~~~~~~~~\n       * 3. draws this line -> |      | <- 1. draws this line\n       *                       +------+\n       *                          ^\n       *                          |\n       *                  2. draws this line\n       */\n      ctx.lineTo(waveRight + left, shape.cy + shape.radiusY);\n      ctx.lineTo(left, shape.cy + shape.radiusY);\n      ctx.lineTo(left, shape.waterLevel);\n    }\n    ctx.closePath();\n  }\n});\n\n/**\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\n *\n * @param {number} x          x position of the left-most point (a)\n * @param {number} stage      0-3, stating which part of the wave it is\n * @param {number} waveLength wave length of the sine wave\n * @param {number} amplitude  wave amplitude\n */\nfunction getWaterPositions(x, stage, waveLength, amplitude) {\n  if (stage === 0) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];\n  } else if (stage === 1) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];\n  } else if (stage === 2) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];\n  } else {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
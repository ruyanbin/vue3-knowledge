{"ast":null,"code":"import { uuid } from '../../../util/index';\nimport { deepMerge } from '@jiaminghi/charts/lib/util/index';\nimport { deepClone } from '@jiaminghi/c-render/lib/plugin/util';\nimport CRender from '@jiaminghi/c-render';\nexport default {\n  name: 'DvWaterLevelPond',\n  props: {\n    config: Object,\n    default: () => ({})\n  },\n  data() {\n    const id = uuid();\n    return {\n      gradientId: `water-level-pond-${id}`,\n      defaultConfig: {\n        /**\n         * @description Data\n         * @type {Array<Number>}\n         * @default data = []\n         * @example data = [60, 40]\n         */\n        data: [],\n        /**\n         * @description Shape of wanter level pond\n         * @type {String}\n         * @default shape = 'rect'\n         * @example shape = 'rect' | 'roundRect' | 'round'\n         */\n        shape: 'rect',\n        /**\n         * @description Water wave number\n         * @type {Number}\n         * @default waveNum = 3\n         */\n        waveNum: 3,\n        /**\n         * @description Water wave height (px)\n         * @type {Number}\n         * @default waveHeight = 40\n         */\n        waveHeight: 40,\n        /**\n         * @description Wave opacity\n         * @type {Number}\n         * @default waveOpacity = 0.4\n         */\n        waveOpacity: 0.4,\n        /**\n         * @description Colors (hex|rgb|rgba|color keywords)\n         * @type {Array<String>}\n         * @default colors = ['#00BAFF', '#3DE7C9']\n         * @example colors = ['#000', 'rgb(0, 0, 0)', 'rgba(0, 0, 0, 1)', 'red']\n         */\n        colors: ['#3DE7C9', '#00BAFF'],\n        /**\n         * @description Formatter\n         * @type {String}\n         * @default formatter = '{value}%'\n         */\n        formatter: '{value}%'\n      },\n      mergedConfig: {},\n      renderer: null,\n      svgBorderGradient: [],\n      details: '',\n      waves: [],\n      animation: false\n    };\n  },\n  computed: {\n    radius() {\n      const {\n        shape\n      } = this.mergedConfig;\n      if (shape === 'round') return '50%';\n      if (shape === 'rect') return '0';\n      if (shape === 'roundRect') return '10px';\n      return '0';\n    },\n    shape() {\n      const {\n        shape\n      } = this.mergedConfig;\n      if (!shape) return 'rect';\n      return shape;\n    }\n  },\n  watch: {\n    config() {\n      const {\n        calcData,\n        renderer\n      } = this;\n      renderer.delAllGraph();\n      this.waves = [];\n      setTimeout(calcData, 0);\n    }\n  },\n  methods: {\n    init() {\n      const {\n        initRender,\n        config,\n        calcData\n      } = this;\n      initRender();\n      if (!config) return;\n      calcData();\n    },\n    initRender() {\n      const {\n        $refs\n      } = this;\n      this.renderer = new CRender($refs['water-pond-level']);\n    },\n    calcData() {\n      const {\n        mergeConfig,\n        calcSvgBorderGradient,\n        calcDetails\n      } = this;\n      mergeConfig();\n      calcSvgBorderGradient();\n      calcDetails();\n      const {\n        addWave,\n        animationWave\n      } = this;\n      addWave();\n      animationWave();\n    },\n    mergeConfig() {\n      const {\n        config,\n        defaultConfig\n      } = this;\n      this.mergedConfig = deepMerge(deepClone(defaultConfig, true), config);\n    },\n    calcSvgBorderGradient() {\n      const {\n        colors\n      } = this.mergedConfig;\n      const colorNum = colors.length;\n      const colorOffsetGap = 100 / (colorNum - 1);\n      this.svgBorderGradient = colors.map((c, i) => [colorOffsetGap * i, c]);\n    },\n    calcDetails() {\n      const {\n        data,\n        formatter\n      } = this.mergedConfig;\n      if (!data.length) {\n        this.details = '';\n        return;\n      }\n      const maxValue = Math.max(...data);\n      this.details = formatter.replace('{value}', maxValue);\n    },\n    addWave() {\n      const {\n        renderer,\n        getWaveShapes,\n        getWaveStyle,\n        drawed\n      } = this;\n      const shapes = getWaveShapes();\n      const style = getWaveStyle();\n      this.waves = shapes.map(shape => renderer.add({\n        name: 'smoothline',\n        animationFrame: 300,\n        shape,\n        style,\n        drawed\n      }));\n    },\n    getWaveShapes() {\n      const {\n        mergedConfig,\n        renderer,\n        mergeOffset\n      } = this;\n      const {\n        waveNum,\n        waveHeight,\n        data\n      } = mergedConfig;\n      const [w, h] = renderer.area;\n      const pointsNum = waveNum * 4 + 4;\n      const pointXGap = w / waveNum / 2;\n      return data.map(v => {\n        let points = new Array(pointsNum).fill(0).map((foo, j) => {\n          const x = w - pointXGap * j;\n          const startY = (1 - v / 100) * h;\n          const y = j % 2 === 0 ? startY : startY - waveHeight;\n          return [x, y];\n        });\n        points = points.map(p => mergeOffset(p, [pointXGap * 2, 0]));\n        return {\n          points\n        };\n      });\n    },\n    mergeOffset([x, y], [ox, oy]) {\n      return [x + ox, y + oy];\n    },\n    getWaveStyle() {\n      const {\n        renderer,\n        mergedConfig\n      } = this;\n      const h = renderer.area[1];\n      return {\n        gradientColor: mergedConfig.colors,\n        gradientType: 'linear',\n        gradientParams: [0, 0, 0, h],\n        gradientWith: 'fill',\n        opacity: mergedConfig.waveOpacity,\n        translate: [0, 0]\n      };\n    },\n    drawed({\n      shape: {\n        points\n      }\n    }, {\n      ctx,\n      area\n    }) {\n      const firstPoint = points[0];\n      const lastPoint = points.slice(-1)[0];\n      const h = area[1];\n      ctx.lineTo(lastPoint[0], h);\n      ctx.lineTo(firstPoint[0], h);\n      ctx.closePath();\n      ctx.fill();\n    },\n    async animationWave(repeat = 1) {\n      const {\n        waves,\n        renderer,\n        animation\n      } = this;\n      if (animation) return;\n      this.animation = true;\n      const w = renderer.area[0];\n      waves.forEach(graph => {\n        graph.attr('style', {\n          translate: [0, 0]\n        });\n        graph.animation('style', {\n          translate: [w, 0]\n        }, true);\n      });\n      await renderer.launchAnimation();\n      this.animation = false;\n      if (!renderer.graphs.length) return;\n      this.animationWave(repeat + 1);\n    }\n  },\n  mounted() {\n    const {\n      init\n    } = this;\n    init();\n  },\n  beforeDestroy() {\n    const {\n      renderer\n    } = this;\n    renderer.delAllGraph();\n    this.waves = [];\n  }\n};","map":{"version":3,"mappings":"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","names":["uuid","deepMerge","deepClone","CRender","name","props","config","Object","default","data","id","gradientId","defaultConfig","shape","waveNum","waveHeight","waveOpacity","colors","formatter","mergedConfig","renderer","svgBorderGradient","details","waves","animation","computed","radius","watch","calcData","delAllGraph","setTimeout","methods","init","initRender","$refs","mergeConfig","calcSvgBorderGradient","calcDetails","addWave","animationWave","colorNum","length","colorOffsetGap","map","c","i","maxValue","Math","max","replace","getWaveShapes","getWaveStyle","drawed","shapes","style","add","animationFrame","mergeOffset","w","h","area","pointsNum","pointXGap","v","points","Array","fill","foo","j","x","startY","y","p","ox","oy","gradientColor","gradientType","gradientParams","gradientWith","opacity","translate","ctx","firstPoint","lastPoint","slice","lineTo","closePath","repeat","forEach","graph","attr","launchAnimation","graphs","mounted","beforeDestroy"],"sourceRoot":"","sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/@jiaminghi/data-view/lib/components/waterLevelPond/src/main.vue"],"sourcesContent":["<template>\n  <div class=\"dv-water-pond-level\">\n    <svg v-if=\"renderer\">\n      <defs>\n        <linearGradient :id=\"gradientId\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n          <stop v-for=\"lc in svgBorderGradient\" :key=\"lc[0]\"\n            :offset=\"lc[0]\"\n            :stop-color=\"lc[1]\" />\n        </linearGradient>\n      </defs>\n\n      <text\n        v-if=\"renderer\"\n        :stroke=\"`url(#${gradientId})`\"\n        :fill=\"`url(#${gradientId})`\"\n        :x=\"renderer.area[0] / 2 + 8\"\n        :y=\"renderer.area[1] / 2 + 8\"\n      >\n        {{ details }}\n      </text>\n\n      <ellipse v-if=\"!shape || shape === 'round'\"\n        :cx=\"renderer.area[0] / 2 + 8\"\n        :cy=\"renderer.area[1] / 2 + 8\"\n        :rx=\"renderer.area[0] / 2 + 5\"\n        :ry=\"renderer.area[1] / 2 + 5\"\n        :stroke=\"`url(#${gradientId})`\" />\n\n      <rect v-else\n        x=\"2\" y=\"2\"\n        :rx=\"shape === 'roundRect' ? 10 : 0\"\n        :ry=\"shape === 'roundRect' ? 10 : 0\"\n        :width=\"renderer.area[0] + 12\"\n        :height=\"renderer.area[1] + 12\"\n        :stroke=\"`url(#${gradientId})`\" />\n    </svg>\n\n    <canvas ref=\"water-pond-level\" :style=\"`border-radius: ${radius};`\" />\n  </div>\n</template>\n\n<script>\nimport { uuid } from '../../../util/index'\n\nimport { deepMerge } from '@jiaminghi/charts/lib/util/index'\n\nimport { deepClone } from '@jiaminghi/c-render/lib/plugin/util'\n\nimport CRender from '@jiaminghi/c-render'\n\nexport default {\n  name: 'DvWaterLevelPond',\n  props: {\n    config: Object,\n    default: () => ({})\n  },\n  data () {\n    const id = uuid()\n    return {\n      gradientId: `water-level-pond-${id}`,\n\n      defaultConfig: {\n        /**\n         * @description Data\n         * @type {Array<Number>}\n         * @default data = []\n         * @example data = [60, 40]\n         */\n        data: [],\n        /**\n         * @description Shape of wanter level pond\n         * @type {String}\n         * @default shape = 'rect'\n         * @example shape = 'rect' | 'roundRect' | 'round'\n         */\n        shape: 'rect',\n        /**\n         * @description Water wave number\n         * @type {Number}\n         * @default waveNum = 3\n         */\n        waveNum: 3,\n        /**\n         * @description Water wave height (px)\n         * @type {Number}\n         * @default waveHeight = 40\n         */\n        waveHeight: 40,\n        /**\n         * @description Wave opacity\n         * @type {Number}\n         * @default waveOpacity = 0.4\n         */\n        waveOpacity: 0.4,\n        /**\n         * @description Colors (hex|rgb|rgba|color keywords)\n         * @type {Array<String>}\n         * @default colors = ['#00BAFF', '#3DE7C9']\n         * @example colors = ['#000', 'rgb(0, 0, 0)', 'rgba(0, 0, 0, 1)', 'red']\n         */\n        colors: ['#3DE7C9', '#00BAFF'],\n        /**\n         * @description Formatter\n         * @type {String}\n         * @default formatter = '{value}%'\n         */\n        formatter: '{value}%'\n      },\n\n      mergedConfig: {},\n\n      renderer: null,\n\n      svgBorderGradient: [],\n\n      details: '',\n\n      waves: [],\n\n      animation: false\n    }\n  },\n  computed: {\n    radius () {\n      const { shape } = this.mergedConfig\n\n      if (shape === 'round') return '50%'\n\n      if (shape === 'rect') return '0'\n\n      if (shape === 'roundRect') return '10px'\n\n      return '0'\n    },\n    shape () {\n      const { shape } = this.mergedConfig\n\n      if (!shape) return 'rect'\n\n      return shape\n    }\n  },\n  watch: {\n    config () {\n      const { calcData, renderer } = this\n\n      renderer.delAllGraph()\n\n      this.waves = []\n\n      setTimeout(calcData, 0)\n    }\n  },\n  methods: {\n    init () {\n      const { initRender, config, calcData } = this\n\n      initRender()\n\n      if (!config) return\n\n      calcData()\n    },\n    initRender () {\n      const { $refs } = this\n\n      this.renderer = new CRender($refs['water-pond-level'])\n    },\n    calcData () {\n      const { mergeConfig, calcSvgBorderGradient, calcDetails } = this\n\n      mergeConfig()\n\n      calcSvgBorderGradient()\n\n      calcDetails()\n\n      const { addWave, animationWave } = this\n\n      addWave()\n\n      animationWave()\n    },\n    mergeConfig () {\n      const { config, defaultConfig } = this\n\n      this.mergedConfig = deepMerge(deepClone(defaultConfig, true), config)\n    },\n    calcSvgBorderGradient () {\n      const { colors } = this.mergedConfig\n\n      const colorNum = colors.length\n\n      const colorOffsetGap = 100 / (colorNum - 1)\n\n      this.svgBorderGradient = colors.map((c, i) => [colorOffsetGap * i, c])\n    },\n    calcDetails () {\n      const { data, formatter } = this.mergedConfig\n\n      if (!data.length) {\n        this.details = ''\n\n        return\n      }\n\n      const maxValue = Math.max(...data)\n\n      this.details = formatter.replace('{value}', maxValue)\n    },\n    addWave () {\n      const { renderer, getWaveShapes, getWaveStyle, drawed } = this\n\n      const shapes = getWaveShapes()\n      const style = getWaveStyle()\n\n      this.waves = shapes.map(shape => renderer.add({\n        name: 'smoothline',\n        animationFrame: 300,\n        shape,\n        style,\n        drawed\n      }))\n    },\n    getWaveShapes () {\n      const { mergedConfig, renderer, mergeOffset } = this\n\n      const { waveNum, waveHeight, data } = mergedConfig\n\n      const [w, h] = renderer.area\n\n      const pointsNum = waveNum * 4 + 4\n\n      const pointXGap = w / waveNum / 2\n\n      return data.map(v => {\n        let points = new Array(pointsNum).fill(0).map((foo, j) => {\n          const x = w - pointXGap * j\n\n          const startY = (1 - v / 100) * h\n\n          const y = j % 2 === 0 ? startY : startY - waveHeight\n\n          return [x, y]\n        })\n\n        points = points.map(p => mergeOffset(p, [pointXGap * 2, 0]))\n\n        return { points }\n      })\n    },\n    mergeOffset ([x, y], [ox, oy]) {\n      return [x + ox, y + oy]\n    },\n    getWaveStyle () {\n      const { renderer, mergedConfig } = this\n\n      const h = renderer.area[1]\n\n      return {\n        gradientColor: mergedConfig.colors,\n        gradientType: 'linear',\n        gradientParams: [0, 0, 0, h],\n        gradientWith: 'fill',\n        opacity: mergedConfig.waveOpacity,\n        translate: [0, 0]\n      }\n    },\n    drawed ({ shape: { points } }, { ctx, area }) {\n      const firstPoint = points[0]\n      const lastPoint = points.slice(-1)[0]\n\n      const h = area[1]\n\n      ctx.lineTo(lastPoint[0], h)\n      ctx.lineTo(firstPoint[0], h)\n\n      ctx.closePath()\n\n      ctx.fill()\n    },\n    async animationWave (repeat = 1) {\n      const { waves, renderer, animation } = this\n\n      if (animation) return\n\n      this.animation = true\n\n      const w = renderer.area[0]\n\n      waves.forEach(graph => {\n        graph.attr('style', { translate: [0, 0] })\n\n        graph.animation('style', {\n          translate: [w, 0]\n        }, true)\n      })\n\n      await renderer.launchAnimation()\n\n      this.animation = false\n\n      if (!renderer.graphs.length) return\n\n      this.animationWave(repeat + 1)\n    }\n  },\n  mounted () {\n    const { init } = this\n\n    init()\n  },\n  beforeDestroy () {\n    const { renderer } = this\n\n    renderer.delAllGraph()\n\n    this.waves = []\n  }\n}\n</script>"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
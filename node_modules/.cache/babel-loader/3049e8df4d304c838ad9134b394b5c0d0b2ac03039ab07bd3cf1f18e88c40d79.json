{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Group, TextureLoader, RepeatWrapping, MeshLambertMaterial, DoubleSide, Vector2, Path, Shape, ExtrudeGeometry, Color, Vector4, UniformsUtils, UniformsLib, ShaderMaterial, Mesh } from 'three';\nimport { getRgbNumber, getAlpha } from '../../../utils/colorUtil.mjs';\nimport { clearGroup } from '../../../utils/threeUtil.mjs';\nimport { vertex, fragment } from './meshlambert.glsl.mjs';\nclass ThreePolygon {\n  constructor(layer, options) {\n    this.layer = layer;\n    this.object = new Group();\n    this.createGlobalMaterial(options);\n    this.layer.add(this.object);\n    this.init(options);\n  }\n  createGlobalMaterial(options) {\n    if (options.sideTexture) {\n      const sideTexture = new TextureLoader().load(options.sideTexture);\n      sideTexture.wrapS = sideTexture.wrapT = RepeatWrapping;\n      sideTexture.offset.set(0, 0.5);\n      sideTexture.repeat.set(0.1, 0.1);\n      this.sideImgMaterial = new MeshLambertMaterial({\n        depthTest: options.depthTest,\n        map: sideTexture,\n        side: DoubleSide\n      });\n    }\n    this.bottomMaterial = new MeshLambertMaterial({\n      depthTest: options.depthTest,\n      transparent: true,\n      color: getRgbNumber(options.bottomColor),\n      opacity: getAlpha(options.bottomColor)\n    });\n    this.topMaterial = new MeshLambertMaterial({\n      depthTest: options.depthTest,\n      transparent: true,\n      color: getRgbNumber(options.topColor),\n      opacity: getAlpha(options.topColor)\n    });\n  }\n  init(options) {\n    options.source.features.forEach(feature => {\n      if (feature.geometry.type === \"Polygon\") {\n        this.createMesh(feature.geometry.coordinates, feature.properties, options);\n      } else if (feature.geometry.type === \"MultiPolygon\") {\n        feature.geometry.coordinates.forEach(cood => {\n          this.createMesh(cood, feature.properties, options);\n        });\n      }\n    });\n    this.refresh();\n  }\n  createMesh(paths, properties, options) {\n    if (paths.length === 0) {\n      return;\n    }\n    properties = properties || {};\n    const height = properties.height !== void 0 ? properties.height : options.height;\n    const path = paths[0];\n    const outPolygonArray = [];\n    const holesArray = [];\n    for (let i = 0; i < path.length; i++) {\n      const point = this.convertLngLat(path[i]);\n      outPolygonArray.push(new Vector2(point[0], point[1]));\n    }\n    for (let i = 1; i < paths.length; i++) {\n      const inPolygonPath = paths[i];\n      const array = [];\n      for (let j = 0; j < inPolygonPath.length; j++) {\n        const inPoint = this.convertLngLat(inPolygonPath[j]);\n        array.push(new Vector2(inPoint[0], inPoint[1]));\n      }\n      holesArray.push(new Path(array));\n    }\n    const shape = new Shape(outPolygonArray);\n    shape.holes = holesArray;\n    if (height > 0) {\n      const sideExtrudeGeometry = new ExtrudeGeometry(shape, {\n        depth: height,\n        bevelEnabled: false,\n        steps: 1\n      });\n      const hideMaterial = new MeshLambertMaterial({\n        visible: false\n      });\n      const materialList = [hideMaterial];\n      let sideMaterial;\n      if (options.sideTexture) {\n        sideMaterial = this.sideImgMaterial;\n      } else {\n        const topColor = new Color();\n        topColor.setHex(getRgbNumber(options.sideTopColor));\n        const topColorVector4 = new Vector4(topColor.r, topColor.g, topColor.b, getAlpha(options.sideTopColor));\n        const bottomColor = new Color();\n        bottomColor.setHex(getRgbNumber(options.sideBottomColor));\n        const bottomColorVector4 = new Vector4(bottomColor.r, bottomColor.g, bottomColor.b, getAlpha(options.sideBottomColor));\n        const uniforms = UniformsUtils.merge([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {\n          emissive: {\n            value: new Color(\"#000\")\n          },\n          \"topColorVector4\": {\n            value: bottomColorVector4\n          },\n          \"bottomColorVector4\": {\n            value: topColorVector4\n          },\n          \"height\": {\n            value: height\n          }\n        }]);\n        sideMaterial = new ShaderMaterial({\n          depthTest: options.depthTest,\n          side: DoubleSide,\n          transparent: true,\n          lights: true,\n          uniforms,\n          vertexShader: vertex,\n          fragmentShader: fragment\n        });\n      }\n      materialList.push(sideMaterial);\n      const bottomExtrudeGeometry = new ExtrudeGeometry(shape, {\n        depth: 0\n      });\n      const bottomMesh = new Mesh(bottomExtrudeGeometry, this.bottomMaterial);\n      this.object.add(bottomMesh);\n      const sideMesh = new Mesh(sideExtrudeGeometry, materialList);\n      this.object.add(sideMesh);\n    }\n    const topExtrudeGeometry = new ExtrudeGeometry(shape, {\n      depth: 0\n    });\n    const topMesh = new Mesh(topExtrudeGeometry, this.topMaterial);\n    topMesh.translateZ(height);\n    this.object.add(topMesh);\n  }\n  convertLngLat(lnglat) {\n    var _a;\n    return (_a = this.layer) == null ? void 0 : _a.convertLngLat(lnglat);\n  }\n  refresh() {\n    var _a;\n    (_a = this.layer) == null ? void 0 : _a.update();\n  }\n  show() {\n    this.object.visible = true;\n    this.refresh();\n  }\n  hide() {\n    this.object.visible = false;\n    this.refresh();\n  }\n  remove() {\n    var _a;\n    if (this.object) {\n      (_a = this.layer) == null ? void 0 : _a.remove(this.object);\n    }\n  }\n  destroy() {\n    if (this.object) {\n      clearGroup(this.object);\n      if (this.bottomMaterial) {\n        this.bottomMaterial.dispose();\n        this.bottomMaterial = void 0;\n      }\n      if (this.topMaterial) {\n        this.topMaterial.dispose();\n        this.topMaterial = void 0;\n      }\n      if (this.sideImgMaterial) {\n        this.sideImgMaterial.dispose();\n        this.sideImgMaterial = void 0;\n      }\n      this.object = null;\n      this.layer = void 0;\n    }\n  }\n}\nexport { ThreePolygon as default };","map":{"version":3,"mappings":"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","names":["ThreePolygon","constructor","layer","options","object","Group","createGlobalMaterial","add","init","sideTexture","TextureLoader","wrapT","set","MeshLambertMaterial","depthTest","map","side","transparent","color","getRgbNumber","opacity","getAlpha","features","feature","geometry","createMesh","properties","coordinates","cood","paths","length","height","path","outPolygonArray","holesArray","i","push","Vector2","point","inPolygonPath","array","j","inPoint","Path","Shape","shape","holes","ExtrudeGeometry","depth","bevelEnabled","steps","visible","materialList","hideMaterial","sideMaterial","topColor","Color","Vector4","g","b","bottomColor","UniformsUtils","merge","UniformsLib","emissive","value","ShaderMaterial","lights","uniforms","vertexShader","fragmentShader","bottomMesh","Mesh","sideExtrudeGeometry","topMesh","translateZ","convertLngLat","lnglat","refresh","show","hide","remove","destroy","clearGroup","bottomMaterial","topMaterial","sideImgMaterial"],"sources":["../../../../../../src/packages/three/ThreePolygon/ThreePolygon.ts"],"sourcesContent":["import {Group, Shape, ExtrudeGeometry, MeshLambertMaterial,\r\n  Mesh, TextureLoader, DoubleSide, RepeatWrapping, Vector2,\r\n  Vector4, Path, ShaderMaterial, Color,UniformsUtils, UniformsLib} from 'three';\r\nimport {getRgbNumber, getAlpha} from \"../../../utils/colorUtil\";\r\nimport {clearGroup} from \"../../../utils/threeUtil\";\r\nimport {vertex, fragment} from './meshlambert.glsl'\r\nimport type {Polygon} from \"./Type\";\r\nimport type CustomThreeLayer from '@vue-map/packages/three/ThreeLayer/CustomThreeLayer'\r\n\r\ninterface Options {\r\n  sideTopColor: string // 侧面顶部颜色。缺省值为 '#ffffff'。\r\n  sideBottomColor: string // 侧面顶部颜色。缺省值为 '#ffffff'。\r\n  sideTexture?: string\r\n  topColor: string\r\n  bottomColor: string\r\n  height: number\r\n  depthTest: boolean // 是否开启深度检测，深度检测的话会面会进行融合\r\n  source: Polygon\r\n}\r\n\r\ninterface Properties {\r\n  height?: number\r\n}\r\n\r\nclass ThreePolygon {\r\n  object: any // Group\r\n  layer?: CustomThreeLayer // threejs的图层对象\r\n  bottomMaterial?: MeshLambertMaterial //底部材质\r\n  topMaterial?: MeshLambertMaterial // 顶部材质\r\n  sideImgMaterial?: MeshLambertMaterial // 侧面贴图材质\r\n\r\n  constructor(layer: CustomThreeLayer, options: Options) {\r\n    this.layer = layer;\r\n    this.object = new Group();\r\n    this.createGlobalMaterial(options);\r\n    this.layer.add(this.object);\r\n    this.init(options);\r\n  }\r\n\r\n  createGlobalMaterial(options: Options){\r\n    if(options.sideTexture){\r\n      const sideTexture = new TextureLoader().load(options.sideTexture);\r\n      sideTexture.wrapS = sideTexture.wrapT = RepeatWrapping;\r\n      sideTexture.offset.set(0, 0.5);\r\n      sideTexture.repeat.set(0.1,0.1);\r\n      this.sideImgMaterial = new MeshLambertMaterial({\r\n        depthTest: options.depthTest,\r\n        map: sideTexture,\r\n        side: DoubleSide\r\n      })\r\n    }\r\n    this.bottomMaterial = new MeshLambertMaterial({\r\n      depthTest: options.depthTest,\r\n      transparent: true,\r\n      color: getRgbNumber(options.bottomColor),\r\n      opacity: getAlpha(options.bottomColor),\r\n    })\r\n    this.topMaterial = new MeshLambertMaterial({\r\n      depthTest: options.depthTest,\r\n      transparent: true,\r\n      color: getRgbNumber(options.topColor),\r\n      opacity: getAlpha(options.topColor)\r\n    })\r\n  }\r\n\r\n  init(options: Options) {\r\n    options.source.features.forEach( feature => {\r\n      if(feature.geometry.type === 'Polygon'){\r\n        this.createMesh(feature.geometry.coordinates, feature.properties as Properties, options);\r\n      }else if(feature.geometry.type === 'MultiPolygon'){\r\n        feature.geometry.coordinates.forEach( cood => {\r\n          this.createMesh(cood, feature.properties as Properties, options);\r\n        })\r\n      }\r\n    })\r\n    this.refresh();\r\n  }\r\n\r\n  createMesh(paths: number[][][], properties:Properties, options: Options ) {\r\n    if(paths.length === 0){\r\n      return\r\n    }\r\n    properties = properties || {}\r\n    const height = properties.height !== undefined ? properties.height : options.height;\r\n    const path = paths[0];\r\n    const outPolygonArray: Vector2[] = []\r\n    const holesArray: Path[] = [];\r\n    // 生成面的外围圈\r\n    for(let i=0;i<path.length;i++){\r\n      const point = this.convertLngLat(path[i]);\r\n      outPolygonArray.push(new Vector2(point[0], point[1]))\r\n    }\r\n    // 生成孔洞\r\n    for(let i=1;i<paths.length;i++){\r\n      const inPolygonPath = paths[i];\r\n      const array:Vector2[] = [];\r\n      for(let j=0;j<inPolygonPath.length;j++){\r\n        const inPoint = this.convertLngLat(inPolygonPath[j]);\r\n        array.push(new Vector2(inPoint[0], inPoint[1]))\r\n      }\r\n      holesArray.push(new Path(array));\r\n    }\r\n    const shape = new Shape(outPolygonArray);\r\n    shape.holes = holesArray;\r\n    // 由于需要对顶面，侧面，地面单独控制，因此在此处划分了3个mesh\r\n    if(height > 0){\r\n      // 生成侧面结构\r\n      const sideExtrudeGeometry = new ExtrudeGeometry(shape, {\r\n        depth: height,\r\n        bevelEnabled: false,\r\n        steps: 1\r\n      })\r\n      const hideMaterial = new MeshLambertMaterial({\r\n        visible: false\r\n      })\r\n      const materialList = [hideMaterial]\r\n      // 生成侧面\r\n      let sideMaterial;\r\n      if(options.sideTexture){\r\n        sideMaterial = this.sideImgMaterial;\r\n      }else{\r\n        /*sideMaterial = new MeshLambertMaterial({\r\n          depthTest: options.depthTest,\r\n          transparent: true,\r\n          color: getRgbNumber(options.sideColor),\r\n          opacity: getAlpha(options.sideColor),\r\n          side: DoubleSide\r\n        })*/\r\n        const topColor = new Color();\r\n        topColor.setHex(getRgbNumber(options.sideTopColor));\r\n        const topColorVector4 = new Vector4(topColor.r, topColor.g, topColor.b, getAlpha(options.sideTopColor))\r\n        const bottomColor = new Color();\r\n        bottomColor.setHex(getRgbNumber(options.sideBottomColor));\r\n        const bottomColorVector4 = new Vector4(bottomColor.r, bottomColor.g, bottomColor.b, getAlpha(options.sideBottomColor))\r\n        const uniforms = UniformsUtils.merge( [\r\n          UniformsLib.common,\r\n          UniformsLib.specularmap,\r\n          UniformsLib.envmap,\r\n          UniformsLib.aomap,\r\n          UniformsLib.lightmap,\r\n          UniformsLib.emissivemap,\r\n          UniformsLib.fog,\r\n          UniformsLib.lights,\r\n          {\r\n            emissive: { value: new Color( '#000' ) },\r\n            \"topColorVector4\": {value: bottomColorVector4},\r\n            \"bottomColorVector4\": {value: topColorVector4},\r\n            \"height\": {value: height},\r\n          }\r\n\r\n        ] )\r\n        sideMaterial = new ShaderMaterial({\r\n          depthTest: options.depthTest,\r\n          side: DoubleSide,\r\n          transparent: true,\r\n          lights: true,\r\n          uniforms,\r\n          vertexShader: vertex,\r\n          fragmentShader: fragment\r\n        })\r\n      }\r\n      materialList.push(sideMaterial);\r\n\r\n      // 生成底面\r\n      const bottomExtrudeGeometry = new ExtrudeGeometry(shape, {\r\n        depth: 0\r\n      })\r\n      const bottomMesh = new Mesh(bottomExtrudeGeometry, this.bottomMaterial);\r\n      this.object.add(bottomMesh);\r\n      const sideMesh = new Mesh(sideExtrudeGeometry, materialList);\r\n      this.object.add(sideMesh);\r\n    }\r\n    // 生成顶面\r\n    const topExtrudeGeometry = new ExtrudeGeometry(shape, {\r\n      depth: 0\r\n    })\r\n    const topMesh = new Mesh(topExtrudeGeometry, this.topMaterial);\r\n    topMesh.translateZ(height);\r\n    this.object.add(topMesh);\r\n  }\r\n\r\n  convertLngLat(lnglat: number[]) {\r\n    return this.layer?.convertLngLat(lnglat);\r\n  }\r\n\r\n  refresh() {\r\n    this.layer?.update();\r\n  }\r\n\r\n  show() {\r\n    this.object.visible = true;\r\n    this.refresh();\r\n  }\r\n\r\n  hide() {\r\n    this.object.visible = false;\r\n    this.refresh();\r\n  }\r\n\r\n  remove(){\r\n    if (this.object) {\r\n      this.layer?.remove(this.object)\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    if (this.object) {\r\n      clearGroup(this.object);\r\n      if(this.bottomMaterial){\r\n        this.bottomMaterial.dispose();\r\n        this.bottomMaterial = undefined;\r\n      }\r\n      if(this.topMaterial){\r\n        this.topMaterial.dispose();\r\n        this.topMaterial = undefined;\r\n      }\r\n      if(this.sideImgMaterial){\r\n        this.sideImgMaterial.dispose();\r\n        this.sideImgMaterial = undefined\r\n      }\r\n      this.object = null;\r\n      this.layer = undefined;\r\n    }\r\n  }\r\n}\r\n\r\nexport default ThreePolygon\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
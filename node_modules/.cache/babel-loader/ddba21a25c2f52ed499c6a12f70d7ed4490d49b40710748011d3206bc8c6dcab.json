{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { getUrlExtension } from '../utilities/urlExtension.js';\nimport { LRUCache } from '../utilities/LRUCache.js';\nimport { PriorityQueue } from '../utilities/PriorityQueue.js';\nimport { determineFrustumSet, toggleTiles, skipTraversal, markUsedSetLeaves, traverseSet } from './traverseFunctions.js';\nimport { UNLOADED, LOADING, PARSING, LOADED, FAILED } from './constants.js';\n\n/**\n * Function for provided to sort all tiles for prioritizing loading/unloading.\n *\n * @param {Tile} a\n * @param {Tile} b\n * @returns number\n */\nconst priorityCallback = (a, b) => {\n  if (a.__depth !== b.__depth) {\n    // load shallower tiles first\n    return a.__depth > b.__depth ? -1 : 1;\n  } else if (a.__inFrustum !== b.__inFrustum) {\n    // load tiles that are in the frustum at the current depth\n    return a.__inFrustum ? 1 : -1;\n  } else if (a.__used !== b.__used) {\n    // load tiles that have been used\n    return a.__used ? 1 : -1;\n  } else if (a.__error !== b.__error) {\n    // load the tile with the higher error\n    return a.__error > b.__error ? 1 : -1;\n  } else if (a.__distanceFromCamera !== b.__distanceFromCamera) {\n    // and finally visible tiles which have equal error (ex: if geometricError === 0)\n    // should prioritize based on distance.\n    return a.__distanceFromCamera > b.__distanceFromCamera ? -1 : 1;\n  }\n  return 0;\n};\n\n/**\n * Function for sorting the evicted LRU items. We should evict the shallowest depth first.\n * @param {Tile} tile\n * @returns number\n */\nconst lruPriorityCallback = tile => 1 / (tile.__depthFromRenderedParent + 1);\nexport class TilesRendererBase {\n  get rootTileSet() {\n    const tileSet = this.tileSets[this.rootURL];\n    if (!tileSet || tileSet instanceof Promise) {\n      return null;\n    } else {\n      return tileSet;\n    }\n  }\n  get root() {\n    const tileSet = this.rootTileSet;\n    return tileSet ? tileSet.root : null;\n  }\n  constructor(url) {\n    // state\n    this.tileSets = {};\n    this.rootURL = url;\n    this.fetchOptions = {};\n    this.preprocessURL = null;\n    const lruCache = new LRUCache();\n    lruCache.unloadPriorityCallback = lruPriorityCallback;\n    const downloadQueue = new PriorityQueue();\n    downloadQueue.maxJobs = 4;\n    downloadQueue.priorityCallback = priorityCallback;\n    const parseQueue = new PriorityQueue();\n    parseQueue.maxJobs = 1;\n    parseQueue.priorityCallback = priorityCallback;\n    this.lruCache = lruCache;\n    this.downloadQueue = downloadQueue;\n    this.parseQueue = parseQueue;\n    this.stats = {\n      parsing: 0,\n      downloading: 0,\n      failed: 0,\n      inFrustum: 0,\n      used: 0,\n      active: 0,\n      visible: 0\n    };\n    this.frameCount = 0;\n\n    // options\n    this.errorTarget = 6.0;\n    this.errorThreshold = Infinity;\n    this.loadSiblings = true;\n    this.displayActiveTiles = false;\n    this.maxDepth = Infinity;\n    this.stopAtEmptyTiles = true;\n  }\n  traverse(beforecb, aftercb) {\n    const tileSets = this.tileSets;\n    const rootTileSet = tileSets[this.rootURL];\n    if (!rootTileSet || !rootTileSet.root) return;\n    traverseSet(rootTileSet.root, beforecb, aftercb);\n  }\n\n  // Public API\n  update() {\n    const stats = this.stats;\n    const lruCache = this.lruCache;\n    const tileSets = this.tileSets;\n    const rootTileSet = tileSets[this.rootURL];\n    if (!(this.rootURL in tileSets)) {\n      this.loadRootTileSet(this.rootURL);\n      return;\n    } else if (!rootTileSet || !rootTileSet.root) {\n      return;\n    }\n    const root = rootTileSet.root;\n    stats.inFrustum = 0, stats.used = 0, stats.active = 0, stats.visible = 0, this.frameCount++;\n    determineFrustumSet(root, this);\n    markUsedSetLeaves(root, this);\n    skipTraversal(root, this);\n    toggleTiles(root, this);\n    lruCache.scheduleUnload();\n  }\n\n  // Overrideable\n  parseTile(buffer, tile, extension) {\n    return null;\n  }\n  disposeTile(tile) {}\n  preprocessNode(tile, parentTile, tileSetDir) {\n    if (tile.content) {\n      // Fix old file formats\n      if (!('uri' in tile.content) && 'url' in tile.content) {\n        tile.content.uri = tile.content.url;\n        delete tile.content.url;\n      }\n      if (tile.content.uri) {\n        // tile content uri has to be interpreted relative to the tileset.json\n        tile.content.uri = new URL(tile.content.uri, tileSetDir + '/').toString();\n      }\n\n      // NOTE: fix for some cases where tilesets provide the bounding volume\n      // but volumes are not present.\n      if (tile.content.boundingVolume && !('box' in tile.content.boundingVolume || 'sphere' in tile.content.boundingVolume || 'region' in tile.content.boundingVolume)) {\n        delete tile.content.boundingVolume;\n      }\n    }\n    tile.parent = parentTile;\n    tile.children = tile.children || [];\n    const uri = tile.content && tile.content.uri;\n    if (uri) {\n      // \"content\" should only indicate loadable meshes, not external tile sets\n      const extension = getUrlExtension(tile.content.uri);\n      const isExternalTileSet = Boolean(extension && extension.toLowerCase() === 'json');\n      tile.__externalTileSet = isExternalTileSet;\n      tile.__contentEmpty = isExternalTileSet;\n    } else {\n      tile.__externalTileSet = false;\n      tile.__contentEmpty = true;\n    }\n\n    // Expected to be set during calculateError()\n    tile.__distanceFromCamera = Infinity;\n    tile.__error = Infinity;\n    tile.__inFrustum = false;\n    tile.__isLeaf = false;\n    tile.__usedLastFrame = false;\n    tile.__used = false;\n    tile.__wasSetVisible = false;\n    tile.__visible = false;\n    tile.__childrenWereVisible = false;\n    tile.__allChildrenLoaded = false;\n    tile.__wasSetActive = false;\n    tile.__active = false;\n    tile.__loadingState = UNLOADED;\n    tile.__loadIndex = 0;\n    tile.__loadAbort = null;\n    tile.__depthFromRenderedParent = -1;\n    if (parentTile === null) {\n      tile.__depth = 0;\n      tile.refine = tile.refine || 'REPLACE';\n    } else {\n      tile.__depth = parentTile.__depth + 1;\n      tile.refine = tile.refine || parentTile.refine;\n    }\n  }\n  setTileActive(tile, state) {}\n  setTileVisible(tile, state) {}\n  calculateError(tile) {\n    return 0;\n  }\n  tileInView(tile) {\n    return true;\n  }\n  resetFailedTiles() {\n    const stats = this.stats;\n    if (stats.failed === 0) {\n      return;\n    }\n    this.traverse(tile => {\n      if (tile.__loadingState === FAILED) {\n        tile.__loadingState = UNLOADED;\n      }\n    });\n    stats.failed = 0;\n  }\n\n  // Private Functions\n  fetchTileSet(url, fetchOptions, parent = null) {\n    return fetch(url, fetchOptions).then(res => {\n      if (res.ok) {\n        return res.json();\n      } else {\n        throw new Error(`TilesRenderer: Failed to load tileset \"${url}\" with status ${res.status} : ${res.statusText}`);\n      }\n    }).then(json => {\n      const version = json.asset.version;\n      console.assert(version === '1.0' || version === '0.0', 'asset.version is expected to be a string of \"1.0\" or \"0.0\"');\n\n      // remove trailing slash and last path-segment from the URL\n      let basePath = url.replace(/\\/[^\\/]*\\/?$/, '');\n      basePath = new URL(basePath, window.location.href).toString();\n      traverseSet(json.root, (node, parent) => this.preprocessNode(node, parent, basePath), null, parent, parent ? parent.__depth : 0);\n      return json;\n    });\n  }\n  loadRootTileSet(url) {\n    const tileSets = this.tileSets;\n    if (!(url in tileSets)) {\n      const pr = this.fetchTileSet(this.preprocessURL ? this.preprocessURL(url) : url, this.fetchOptions).then(json => {\n        tileSets[url] = json;\n      });\n      pr.catch(err => {\n        console.error(err);\n        tileSets[url] = err;\n      });\n      tileSets[url] = pr;\n      return pr;\n    } else if (tileSets[url] instanceof Error) {\n      return Promise.reject(tileSets[url]);\n    } else {\n      return Promise.resolve(tileSets[url]);\n    }\n  }\n  requestTileContents(tile) {\n    // If the tile is already being loaded then don't\n    // start it again.\n    if (tile.__loadingState !== UNLOADED) {\n      return;\n    }\n    const stats = this.stats;\n    const lruCache = this.lruCache;\n    const downloadQueue = this.downloadQueue;\n    const parseQueue = this.parseQueue;\n    const isExternalTileSet = tile.__externalTileSet;\n    lruCache.add(tile, t => {\n      // Stop the load if it's started\n      if (t.__loadingState === LOADING) {\n        t.__loadAbort.abort();\n        t.__loadAbort = null;\n      } else if (isExternalTileSet) {\n        t.children.length = 0;\n      } else {\n        this.disposeTile(t);\n      }\n\n      // Decrement stats\n      if (t.__loadingState === LOADING) {\n        stats.downloading--;\n      } else if (t.__loadingState === PARSING) {\n        stats.parsing--;\n      }\n      t.__loadingState = UNLOADED;\n      t.__loadIndex++;\n      parseQueue.remove(t);\n      downloadQueue.remove(t);\n    });\n\n    // Track a new load index so we avoid the condition where this load is stopped and\n    // another begins soon after so we don't parse twice.\n    tile.__loadIndex++;\n    const loadIndex = tile.__loadIndex;\n    const controller = new AbortController();\n    const signal = controller.signal;\n    stats.downloading++;\n    tile.__loadAbort = controller;\n    tile.__loadingState = LOADING;\n    const errorCallback = e => {\n      // if it has been unloaded then the tile has been disposed\n      if (tile.__loadIndex !== loadIndex) {\n        return;\n      }\n      if (e.name !== 'AbortError') {\n        parseQueue.remove(tile);\n        downloadQueue.remove(tile);\n        if (tile.__loadingState === PARSING) {\n          stats.parsing--;\n        } else if (tile.__loadingState === LOADING) {\n          stats.downloading--;\n        }\n        stats.failed++;\n        console.error(`TilesRenderer : Failed to load tile at url \"${tile.content.uri}\".`);\n        console.error(e);\n        tile.__loadingState = FAILED;\n      } else {\n        lruCache.remove(tile);\n      }\n    };\n    if (isExternalTileSet) {\n      downloadQueue.add(tile, tileCb => {\n        // if it has been unloaded then the tile has been disposed\n        if (tileCb.__loadIndex !== loadIndex) {\n          return Promise.resolve();\n        }\n        const uri = this.preprocessURL ? this.preprocessURL(tileCb.content.uri) : tileCb.content.uri;\n        return this.fetchTileSet(uri, Object.assign({\n          signal\n        }, this.fetchOptions), tileCb);\n      }).then(json => {\n        // if it has been unloaded then the tile has been disposed\n        if (tile.__loadIndex !== loadIndex) {\n          return;\n        }\n        stats.downloading--;\n        tile.__loadAbort = null;\n        tile.__loadingState = LOADED;\n        tile.children.push(json.root);\n      }).catch(errorCallback);\n    } else {\n      downloadQueue.add(tile, downloadTile => {\n        if (downloadTile.__loadIndex !== loadIndex) {\n          return Promise.resolve();\n        }\n        const uri = this.preprocessURL ? this.preprocessURL(downloadTile.content.uri) : downloadTile.content.uri;\n        return fetch(uri, Object.assign({\n          signal\n        }, this.fetchOptions));\n      }).then(res => {\n        if (tile.__loadIndex !== loadIndex) {\n          return;\n        }\n        if (res.ok) {\n          return res.arrayBuffer();\n        } else {\n          throw new Error(`Failed to load model with error code ${res.status}`);\n        }\n      }).then(buffer => {\n        // if it has been unloaded then the tile has been disposed\n        if (tile.__loadIndex !== loadIndex) {\n          return;\n        }\n        stats.downloading--;\n        stats.parsing++;\n        tile.__loadAbort = null;\n        tile.__loadingState = PARSING;\n        return parseQueue.add(tile, parseTile => {\n          // if it has been unloaded then the tile has been disposed\n          if (parseTile.__loadIndex !== loadIndex) {\n            return Promise.resolve();\n          }\n          const uri = parseTile.content.uri;\n          const extension = getUrlExtension(uri);\n          return this.parseTile(buffer, parseTile, extension);\n        });\n      }).then(() => {\n        // if it has been unloaded then the tile has been disposed\n        if (tile.__loadIndex !== loadIndex) {\n          return;\n        }\n        stats.parsing--;\n        tile.__loadingState = LOADED;\n        if (tile.__wasSetVisible) {\n          this.setTileVisible(tile, true);\n        }\n        if (tile.__wasSetActive) {\n          this.setTileActive(tile, true);\n        }\n      }).catch(errorCallback);\n    }\n  }\n  dispose() {\n    const lruCache = this.lruCache;\n    this.traverse(tile => {\n      lruCache.remove(tile);\n    });\n    this.stats = {\n      parsing: 0,\n      downloading: 0,\n      failed: 0,\n      inFrustum: 0,\n      used: 0,\n      active: 0,\n      visible: 0\n    };\n    this.frameCount = 0;\n  }\n}","map":{"version":3,"names":["getUrlExtension","LRUCache","PriorityQueue","determineFrustumSet","toggleTiles","skipTraversal","markUsedSetLeaves","traverseSet","UNLOADED","LOADING","PARSING","LOADED","FAILED","priorityCallback","a","b","__depth","__inFrustum","__used","__error","__distanceFromCamera","lruPriorityCallback","tile","__depthFromRenderedParent","TilesRendererBase","rootTileSet","tileSet","tileSets","rootURL","Promise","root","constructor","url","fetchOptions","preprocessURL","lruCache","unloadPriorityCallback","downloadQueue","maxJobs","parseQueue","stats","parsing","downloading","failed","inFrustum","used","active","visible","frameCount","errorTarget","errorThreshold","Infinity","loadSiblings","displayActiveTiles","maxDepth","stopAtEmptyTiles","traverse","beforecb","aftercb","update","loadRootTileSet","scheduleUnload","parseTile","buffer","extension","disposeTile","preprocessNode","parentTile","tileSetDir","content","uri","URL","toString","boundingVolume","parent","children","isExternalTileSet","Boolean","toLowerCase","__externalTileSet","__contentEmpty","__isLeaf","__usedLastFrame","__wasSetVisible","__visible","__childrenWereVisible","__allChildrenLoaded","__wasSetActive","__active","__loadingState","__loadIndex","__loadAbort","refine","setTileActive","state","setTileVisible","calculateError","tileInView","resetFailedTiles","fetchTileSet","fetch","then","res","ok","json","Error","status","statusText","version","asset","console","assert","basePath","replace","window","location","href","node","pr","catch","err","error","reject","resolve","requestTileContents","add","t","abort","length","remove","loadIndex","controller","AbortController","signal","errorCallback","e","name","tileCb","Object","assign","push","downloadTile","arrayBuffer","dispose"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/3d-tiles-renderer/src/base/TilesRendererBase.js"],"sourcesContent":["import { getUrlExtension } from '../utilities/urlExtension.js';\nimport { LRUCache } from '../utilities/LRUCache.js';\nimport { PriorityQueue } from '../utilities/PriorityQueue.js';\nimport { determineFrustumSet, toggleTiles, skipTraversal, markUsedSetLeaves, traverseSet } from './traverseFunctions.js';\nimport { UNLOADED, LOADING, PARSING, LOADED, FAILED } from './constants.js';\n\n/**\n * Function for provided to sort all tiles for prioritizing loading/unloading.\n *\n * @param {Tile} a\n * @param {Tile} b\n * @returns number\n */\nconst priorityCallback = ( a, b ) => {\n\n\tif ( a.__depth !== b.__depth ) {\n\n\t\t// load shallower tiles first\n\t\treturn a.__depth > b.__depth ? - 1 : 1;\n\n\t} else if ( a.__inFrustum !== b.__inFrustum ) {\n\n\t\t// load tiles that are in the frustum at the current depth\n\t\treturn a.__inFrustum ? 1 : - 1;\n\n\t} else if ( a.__used !== b.__used ) {\n\n\t\t// load tiles that have been used\n\t\treturn a.__used ? 1 : - 1;\n\n\t} else if ( a.__error !== b.__error ) {\n\n\t\t// load the tile with the higher error\n\t\treturn a.__error > b.__error ? 1 : - 1;\n\n\t} else if ( a.__distanceFromCamera !== b.__distanceFromCamera ) {\n\n\t\t// and finally visible tiles which have equal error (ex: if geometricError === 0)\n\t\t// should prioritize based on distance.\n\t\treturn a.__distanceFromCamera > b.__distanceFromCamera ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\n/**\n * Function for sorting the evicted LRU items. We should evict the shallowest depth first.\n * @param {Tile} tile\n * @returns number\n */\nconst lruPriorityCallback = ( tile ) => 1 / ( tile.__depthFromRenderedParent + 1 );\n\nexport class TilesRendererBase {\n\n\tget rootTileSet() {\n\n\t\tconst tileSet = this.tileSets[ this.rootURL ];\n\t\tif ( ! tileSet || tileSet instanceof Promise ) {\n\n\t\t\treturn null;\n\n\t\t} else {\n\n\t\t\treturn tileSet;\n\n\t\t}\n\n\t}\n\n\tget root() {\n\n\t\tconst tileSet = this.rootTileSet;\n\t\treturn tileSet ? tileSet.root : null;\n\n\t}\n\n\tconstructor( url ) {\n\n\t\t// state\n\t\tthis.tileSets = {};\n\t\tthis.rootURL = url;\n\t\tthis.fetchOptions = {};\n\n\t\tthis.preprocessURL = null;\n\n\t\tconst lruCache = new LRUCache();\n\t\tlruCache.unloadPriorityCallback = lruPriorityCallback;\n\n\t\tconst downloadQueue = new PriorityQueue();\n\t\tdownloadQueue.maxJobs = 4;\n\t\tdownloadQueue.priorityCallback = priorityCallback;\n\n\t\tconst parseQueue = new PriorityQueue();\n\t\tparseQueue.maxJobs = 1;\n\t\tparseQueue.priorityCallback = priorityCallback;\n\n\t\tthis.lruCache = lruCache;\n\t\tthis.downloadQueue = downloadQueue;\n\t\tthis.parseQueue = parseQueue;\n\t\tthis.stats = {\n\t\t\tparsing: 0,\n\t\t\tdownloading: 0,\n\t\t\tfailed: 0,\n\t\t\tinFrustum: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\n\t\t// options\n\t\tthis.errorTarget = 6.0;\n\t\tthis.errorThreshold = Infinity;\n\t\tthis.loadSiblings = true;\n\t\tthis.displayActiveTiles = false;\n\t\tthis.maxDepth = Infinity;\n\t\tthis.stopAtEmptyTiles = true;\n\n\t}\n\n\ttraverse( beforecb, aftercb ) {\n\n\t\tconst tileSets = this.tileSets;\n\t\tconst rootTileSet = tileSets[ this.rootURL ];\n\t\tif ( ! rootTileSet || ! rootTileSet.root ) return;\n\n\t\ttraverseSet( rootTileSet.root, beforecb, aftercb );\n\n\t}\n\n\t// Public API\n\tupdate() {\n\n\t\tconst stats = this.stats;\n\t\tconst lruCache = this.lruCache;\n\t\tconst tileSets = this.tileSets;\n\t\tconst rootTileSet = tileSets[ this.rootURL ];\n\t\tif ( ! ( this.rootURL in tileSets ) ) {\n\n\t\t\tthis.loadRootTileSet( this.rootURL );\n\t\t\treturn;\n\n\t\t} else if ( ! rootTileSet || ! rootTileSet.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst root = rootTileSet.root;\n\n\t\tstats.inFrustum = 0,\n\t\tstats.used = 0,\n\t\tstats.active = 0,\n\t\tstats.visible = 0,\n\t\tthis.frameCount ++;\n\n\t\tdetermineFrustumSet( root, this );\n\t\tmarkUsedSetLeaves( root, this );\n\t\tskipTraversal( root, this );\n\t\ttoggleTiles( root, this );\n\n\t\tlruCache.scheduleUnload();\n\n\t}\n\n\t// Overrideable\n\tparseTile( buffer, tile, extension ) {\n\n\t\treturn null;\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t}\n\n\tpreprocessNode( tile, parentTile, tileSetDir ) {\n\n\t\tif ( tile.content ) {\n\n\t\t\t// Fix old file formats\n\t\t\tif ( ! ( 'uri' in tile.content ) && 'url' in tile.content ) {\n\n\t\t\t\ttile.content.uri = tile.content.url;\n\t\t\t\tdelete tile.content.url;\n\n\t\t\t}\n\n\t\t\tif ( tile.content.uri ) {\n\n\t\t\t\t// tile content uri has to be interpreted relative to the tileset.json\n\t\t\t\ttile.content.uri = new URL( tile.content.uri, tileSetDir + '/' ).toString();\n\n\t\t\t}\n\n\t\t\t// NOTE: fix for some cases where tilesets provide the bounding volume\n\t\t\t// but volumes are not present.\n\t\t\tif (\n\t\t\t\ttile.content.boundingVolume &&\n\t\t\t\t! (\n\t\t\t\t\t'box' in tile.content.boundingVolume ||\n\t\t\t\t\t'sphere' in tile.content.boundingVolume ||\n\t\t\t\t\t'region' in tile.content.boundingVolume\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tdelete tile.content.boundingVolume;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.parent = parentTile;\n\t\ttile.children = tile.children || [];\n\n\t\tconst uri = tile.content && tile.content.uri;\n\t\tif ( uri ) {\n\n\t\t\t// \"content\" should only indicate loadable meshes, not external tile sets\n\t\t\tconst extension = getUrlExtension( tile.content.uri );\n\t\t\tconst isExternalTileSet = Boolean( extension && extension.toLowerCase() === 'json' );\n\t\t\ttile.__externalTileSet = isExternalTileSet;\n\t\t\ttile.__contentEmpty = isExternalTileSet;\n\n\t\t} else {\n\n\t\t\ttile.__externalTileSet = false;\n\t\t\ttile.__contentEmpty = true;\n\n\t\t}\n\n\t\t// Expected to be set during calculateError()\n\t\ttile.__distanceFromCamera = Infinity;\n\t\ttile.__error = Infinity;\n\n\t\ttile.__inFrustum = false;\n\t\ttile.__isLeaf = false;\n\n\t\ttile.__usedLastFrame = false;\n\t\ttile.__used = false;\n\n\t\ttile.__wasSetVisible = false;\n\t\ttile.__visible = false;\n\t\ttile.__childrenWereVisible = false;\n\t\ttile.__allChildrenLoaded = false;\n\n\t\ttile.__wasSetActive = false;\n\t\ttile.__active = false;\n\n\t\ttile.__loadingState = UNLOADED;\n\t\ttile.__loadIndex = 0;\n\n\t\ttile.__loadAbort = null;\n\n\t\ttile.__depthFromRenderedParent = - 1;\n\t\tif ( parentTile === null ) {\n\n\t\t\ttile.__depth = 0;\n\t\t\ttile.refine = tile.refine || 'REPLACE';\n\n\t\t} else {\n\n\t\t\ttile.__depth = parentTile.__depth + 1;\n\t\t\ttile.refine = tile.refine || parentTile.refine;\n\n\t\t}\n\n\t}\n\n\tsetTileActive( tile, state ) {\n\n\t}\n\n\tsetTileVisible( tile, state ) {\n\n\t}\n\n\tcalculateError( tile ) {\n\n\t\treturn 0;\n\n\t}\n\n\ttileInView( tile ) {\n\n\t\treturn true;\n\n\t}\n\n\n\tresetFailedTiles() {\n\n\t\tconst stats = this.stats;\n\t\tif ( stats.failed === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.traverse( tile => {\n\n\t\t\tif ( tile.__loadingState === FAILED ) {\n\n\t\t\t\ttile.__loadingState = UNLOADED;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tstats.failed = 0;\n\n\t}\n\n\t// Private Functions\n\tfetchTileSet( url, fetchOptions, parent = null ) {\n\n\t\treturn fetch( url, fetchOptions )\n\t\t\t.then( res => {\n\n\t\t\t\tif ( res.ok ) {\n\n\t\t\t\t\treturn res.json();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `TilesRenderer: Failed to load tileset \"${ url }\" with status ${ res.status } : ${ res.statusText }` );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( json => {\n\n\t\t\t\tconst version = json.asset.version;\n\t\t\t\tconsole.assert(\n\t\t\t\t\tversion === '1.0' || version === '0.0',\n\t\t\t\t\t'asset.version is expected to be a string of \"1.0\" or \"0.0\"'\n\t\t\t\t);\n\n\t\t\t\t// remove trailing slash and last path-segment from the URL\n\t\t\t\tlet basePath = url.replace( /\\/[^\\/]*\\/?$/, '' );\n\t\t\t\tbasePath = new URL( basePath, window.location.href ).toString();\n\n\t\t\t\ttraverseSet(\n\t\t\t\t\tjson.root,\n\t\t\t\t\t( node, parent ) => this.preprocessNode( node, parent, basePath ),\n\t\t\t\t\tnull,\n\t\t\t\t\tparent,\n\t\t\t\t\tparent ? parent.__depth : 0,\n\t\t\t\t);\n\n\t\t\t\treturn json;\n\n\t\t\t} );\n\n\t}\n\n\tloadRootTileSet( url ) {\n\n\t\tconst tileSets = this.tileSets;\n\t\tif ( ! ( url in tileSets ) ) {\n\n\t\t\tconst pr = this\n\t\t\t\t.fetchTileSet( this.preprocessURL ? this.preprocessURL( url ) : url, this.fetchOptions )\n\t\t\t\t.then( json => {\n\n\t\t\t\t\ttileSets[ url ] = json;\n\n\t\t\t\t} );\n\n\t\t\tpr.catch( err => {\n\n\t\t\t\tconsole.error( err );\n\t\t\t\ttileSets[ url ] = err;\n\n\t\t\t} );\n\n\t\t\ttileSets[ url ] = pr;\n\n\t\t\treturn pr;\n\n\t\t} else if ( tileSets[ url ] instanceof Error ) {\n\n\t\t\treturn Promise.reject( tileSets[ url ] );\n\n\t\t} else {\n\n\t\t\treturn Promise.resolve( tileSets[ url ] );\n\n\t\t}\n\n\t}\n\n\trequestTileContents( tile ) {\n\n\t\t// If the tile is already being loaded then don't\n\t\t// start it again.\n\t\tif ( tile.__loadingState !== UNLOADED ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst stats = this.stats;\n\t\tconst lruCache = this.lruCache;\n\t\tconst downloadQueue = this.downloadQueue;\n\t\tconst parseQueue = this.parseQueue;\n\t\tconst isExternalTileSet = tile.__externalTileSet;\n\t\tlruCache.add( tile, t => {\n\n\t\t\t// Stop the load if it's started\n\t\t\tif ( t.__loadingState === LOADING ) {\n\n\t\t\t\tt.__loadAbort.abort();\n\t\t\t\tt.__loadAbort = null;\n\n\t\t\t} else if ( isExternalTileSet ) {\n\n\t\t\t\tt.children.length = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.disposeTile( t );\n\n\t\t\t}\n\n\t\t\t// Decrement stats\n\t\t\tif ( t.__loadingState === LOADING ) {\n\n\t\t\t\tstats.downloading --;\n\n\t\t\t} else if ( t.__loadingState === PARSING ) {\n\n\t\t\t\tstats.parsing --;\n\n\t\t\t}\n\n\t\t\tt.__loadingState = UNLOADED;\n\t\t\tt.__loadIndex ++;\n\n\t\t\tparseQueue.remove( t );\n\t\t\tdownloadQueue.remove( t );\n\n\t\t} );\n\n\t\t// Track a new load index so we avoid the condition where this load is stopped and\n\t\t// another begins soon after so we don't parse twice.\n\t\ttile.__loadIndex ++;\n\t\tconst loadIndex = tile.__loadIndex;\n\t\tconst controller = new AbortController();\n\t\tconst signal = controller.signal;\n\n\t\tstats.downloading ++;\n\t\ttile.__loadAbort = controller;\n\t\ttile.__loadingState = LOADING;\n\n\t\tconst errorCallback = e => {\n\n\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\tif ( tile.__loadIndex !== loadIndex ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( e.name !== 'AbortError' ) {\n\n\t\t\t\tparseQueue.remove( tile );\n\t\t\t\tdownloadQueue.remove( tile );\n\n\t\t\t\tif ( tile.__loadingState === PARSING ) {\n\n\t\t\t\t\tstats.parsing --;\n\n\t\t\t\t} else if ( tile.__loadingState === LOADING ) {\n\n\t\t\t\t\tstats.downloading --;\n\n\t\t\t\t}\n\n\t\t\t\tstats.failed ++;\n\n\t\t\t\tconsole.error( `TilesRenderer : Failed to load tile at url \"${ tile.content.uri }\".` );\n\t\t\t\tconsole.error( e );\n\t\t\t\ttile.__loadingState = FAILED;\n\n\t\t\t} else {\n\n\t\t\t\tlruCache.remove( tile );\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( isExternalTileSet ) {\n\n\t\t\tdownloadQueue.add( tile, tileCb => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( tileCb.__loadIndex !== loadIndex ) {\n\n\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t}\n\n\t\t\t\tconst uri = this.preprocessURL ? this.preprocessURL( tileCb.content.uri ) : tileCb.content.uri;\n\t\t\t\treturn this.fetchTileSet( uri, Object.assign( { signal }, this.fetchOptions ), tileCb );\n\n\t\t\t} )\n\t\t\t\t.then( json => {\n\n\t\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\t\tif ( tile.__loadIndex !== loadIndex ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstats.downloading --;\n\t\t\t\t\ttile.__loadAbort = null;\n\t\t\t\t\ttile.__loadingState = LOADED;\n\n\t\t\t\t\ttile.children.push( json.root );\n\n\t\t\t\t} )\n\t\t\t\t.catch( errorCallback );\n\n\t\t} else {\n\n\t\t\tdownloadQueue.add( tile, downloadTile => {\n\n\t\t\t\tif ( downloadTile.__loadIndex !== loadIndex ) {\n\n\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t}\n\n\t\t\t\tconst uri = this.preprocessURL ? this.preprocessURL( downloadTile.content.uri ) : downloadTile.content.uri;\n\t\t\t\treturn fetch( uri, Object.assign( { signal }, this.fetchOptions ) );\n\n\t\t\t} )\n\t\t\t\t.then( res => {\n\n\t\t\t\t\tif ( tile.__loadIndex !== loadIndex ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( res.ok ) {\n\n\t\t\t\t\t\treturn res.arrayBuffer();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( `Failed to load model with error code ${res.status}` );\n\n\t\t\t\t\t}\n\n\t\t\t\t} )\n\t\t\t\t.then( buffer => {\n\n\t\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\t\tif ( tile.__loadIndex !== loadIndex ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstats.downloading --;\n\t\t\t\t\tstats.parsing ++;\n\t\t\t\t\ttile.__loadAbort = null;\n\t\t\t\t\ttile.__loadingState = PARSING;\n\n\t\t\t\t\treturn parseQueue.add( tile, parseTile => {\n\n\t\t\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\t\t\tif ( parseTile.__loadIndex !== loadIndex ) {\n\n\t\t\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst uri = parseTile.content.uri;\n\t\t\t\t\t\tconst extension = getUrlExtension( uri );\n\n\t\t\t\t\t\treturn this.parseTile( buffer, parseTile, extension );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.then( () => {\n\n\t\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\t\tif ( tile.__loadIndex !== loadIndex ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstats.parsing --;\n\t\t\t\t\ttile.__loadingState = LOADED;\n\n\t\t\t\t\tif ( tile.__wasSetVisible ) {\n\n\t\t\t\t\t\tthis.setTileVisible( tile, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( tile.__wasSetActive ) {\n\n\t\t\t\t\t\tthis.setTileActive( tile, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t} )\n\t\t\t\t.catch( errorCallback );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst lruCache = this.lruCache;\n\t\tthis.traverse( tile => {\n\n\t\t\tlruCache.remove( tile );\n\n\t\t} );\n\n\t\tthis.stats = {\n\t\t\tparsing: 0,\n\t\t\tdownloading: 0,\n\t\t\tfailed: 0,\n\t\t\tinFrustum: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
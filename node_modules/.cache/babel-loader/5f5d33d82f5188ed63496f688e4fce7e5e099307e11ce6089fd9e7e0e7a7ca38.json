{"ast":null,"code":"import { Group, VideoTexture, PlaneGeometry, MeshPhongMaterial, DoubleSide, Mesh, CanvasTexture } from 'three';\nimport { bind } from 'lodash-es';\nimport { clearGroup } from '../../../utils/threeUtil.mjs';\nclass ThreeVideo {\n  constructor(layer) {\n    this.videoFrame = -1;\n    this.layer = layer;\n  }\n  init(options, $vue) {\n    this.video = options.video;\n    this.object = new Group();\n    this.object.isCustomGroup = true;\n    this.object.$vue = $vue;\n    return new Promise(resolve => {\n      var _a, _b, _c, _d, _e;\n      (_a = this.video) == null ? void 0 : _a.load();\n      (_b = this.video) == null ? void 0 : _b.play();\n      const texture = new VideoTexture(this.video);\n      const geometry = new PlaneGeometry(options.videoWidth || ((_c = this.video) == null ? void 0 : _c.videoWidth), options.videoHeight || ((_d = this.video) == null ? void 0 : _d.videoHeight));\n      const material = new MeshPhongMaterial({\n        map: texture,\n        side: DoubleSide,\n        transparent: true,\n        depthTest: false\n      });\n      const mesh = new Mesh(geometry, material);\n      mesh.renderOrder = 3;\n      mesh.rotation.y = Math.PI;\n      mesh.name = \"video\";\n      this.videoMesh = mesh;\n      this.object.add(mesh);\n      this.setVideoTranslate(options.videoTranslate);\n      this.setPosition(options.position);\n      this.setRotation(options.rotation);\n      this.setScale(options.scale);\n      this.setAltitude(options.altitude);\n      (_e = this.layer) == null ? void 0 : _e.add(this.object);\n      this.videoAnimate();\n      this.addBgCanvas(options.canvas);\n      this.setAngle(options.angle);\n      this.setOpacity(options.opacity);\n      this.setzIndex(options.zIndex || 0);\n      this.bindAlwaysFront(options.alwaysFront);\n      resolve();\n    });\n  }\n  bindAlwaysFront(alwaysFront) {\n    var _a;\n    if (alwaysFront) {\n      const map = (_a = this.layer) == null ? void 0 : _a.getMap();\n      this.rotateFun = bind(this._changeMapRotate, this);\n      map.on(\"rotatechange\", this.rotateFun);\n    }\n  }\n  unBindAlwaysFront() {\n    var _a;\n    if (this.rotateFun) {\n      const map = (_a = this.layer) == null ? void 0 : _a.getMap();\n      if (map) {\n        map.off(\"rotatechange\", this.rotateFun);\n      }\n    }\n  }\n  _changeMapRotate() {\n    var _a;\n    const map = (_a = this.layer) == null ? void 0 : _a.getMap();\n    const rotate = map.getRotation();\n    this.setAngle(rotate);\n  }\n  addBgCanvas(canvas) {\n    if (!canvas) {\n      return;\n    }\n    const texture = new CanvasTexture(canvas);\n    const geometry = new PlaneGeometry(canvas.width, canvas.height);\n    const material = new MeshPhongMaterial({\n      map: texture,\n      side: DoubleSide,\n      transparent: true,\n      depthTest: false\n    });\n    const mesh = new Mesh(geometry, material);\n    mesh.name = \"bg\";\n    mesh.renderOrder = 1;\n    this.object.add(mesh);\n    this.canvasTexture = texture;\n    this.bgMesh = mesh;\n  }\n  videoAnimate() {\n    this.videoFrame = requestAnimationFrame(() => {\n      this.videoAnimate();\n    });\n    if (this.canvasTexture) {\n      this.canvasTexture.needsUpdate = true;\n    }\n    this.refresh();\n  }\n  cancelCanvasTextureAnimate() {\n    if (this.videoFrame > 0) {\n      cancelAnimationFrame(this.videoFrame);\n    }\n  }\n  setScale(scale) {\n    let scaleArray;\n    if (typeof scale === \"number\") {\n      scaleArray = [scale, scale, scale];\n    } else {\n      scaleArray = scale;\n    }\n    this.object.scale.set(...scaleArray);\n  }\n  setPosition(position) {\n    var _a;\n    const positionConvert = (_a = this.layer) == null ? void 0 : _a.convertLngLat(position);\n    this.object.position.setX(positionConvert[0]);\n    this.object.position.setY(positionConvert[1]);\n    this.refresh();\n  }\n  setRotation(rotation) {\n    if (rotation) {\n      const x = Math.PI / 180 * (rotation.x || 0);\n      const y = Math.PI / 180 * (rotation.y || 0);\n      const z = Math.PI / 180 * (rotation.z || 0);\n      this.object.rotation.set(x, y, z);\n      this.refresh();\n    }\n  }\n  setVideoTranslate(translate) {\n    if (translate) {\n      this.videoMesh.translateX(translate.x);\n      this.videoMesh.translateY(translate.y);\n      this.videoMesh.translateZ(translate.z);\n      this.refresh();\n    }\n  }\n  setAltitude(altitude) {\n    if (altitude !== void 0) {\n      this.object.position.setZ(altitude);\n      this.refresh();\n    }\n  }\n  setAngle(angle) {\n    if (angle !== void 0) {\n      const x = this.object.rotation.x;\n      const z = this.object.rotation.z;\n      const y = Math.PI / 180 * angle;\n      this.object.rotation.set(x, y, z);\n      this.refresh();\n    }\n  }\n  setOpacity(opacity) {\n    this.videoMesh.material.opacity = opacity;\n    if (this.bgMesh) {\n      this.bgMesh.material.opacity = opacity;\n    }\n    this.refresh();\n  }\n  setzIndex(zIndex) {\n    this.object.renderOrder = zIndex;\n  }\n  refresh() {\n    var _a;\n    (_a = this.layer) == null ? void 0 : _a.update();\n  }\n  show() {\n    this.object.visible = true;\n    this.refresh();\n  }\n  hide() {\n    this.object.visible = false;\n    this.refresh();\n  }\n  start() {\n    var _a;\n    (_a = this.video) == null ? void 0 : _a.play();\n  }\n  pause() {\n    var _a;\n    (_a = this.video) == null ? void 0 : _a.pause();\n  }\n  remove() {\n    var _a;\n    if (this.object) {\n      (_a = this.layer) == null ? void 0 : _a.remove(this.object);\n      this.unBindAlwaysFront();\n    }\n  }\n  destroy() {\n    this.cancelCanvasTextureAnimate();\n    this.unBindAlwaysFront();\n    if (this.object) {\n      this.object.$vue = null;\n      clearGroup(this.object);\n      this.video = void 0;\n      this.videoMesh = void 0;\n      this.bgMesh = void 0;\n      this.canvasTexture = void 0;\n      this.rotateFun = void 0;\n      this.object = null;\n      this.layer = void 0;\n    }\n  }\n}\nexport { ThreeVideo as default };","map":{"version":3,"mappings":"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","names":["ThreeVideo","constructor","layer","init","options","$vue","video","object","Group","isCustomGroup","Promise","resolve","VideoTexture","geometry","PlaneGeometry","videoWidth","videoHeight","MeshPhongMaterial","map","side","transparent","depthTest","Mesh","mesh","renderOrder","y","Math","name","videoMesh","add","setVideoTranslate","setPosition","setRotation","setScale","setAltitude","addBgCanvas","setAngle","setOpacity","zIndex","bindAlwaysFront","alwaysFront","_a","bind","_changeMapRotate","unBindAlwaysFront","rotateFun","rotate","canvas","CanvasTexture","width","canvasTexture","bgMesh","videoAnimate","requestAnimationFrame","needsUpdate","cancelCanvasTextureAnimate","videoFrame","cancelAnimationFrame","scale","scaleArray","position","positionConvert","convertLngLat","rotation","x","PI","z","set","translate","translateX","translateY","translateZ","altitude","setZ","angle","opacity","material","setzIndex","refresh","show","visible","hide","start","pause","remove","destroy","clearGroup"],"sources":["../../../../../../src/packages/three/ThreeVideo/ThreeVideo.ts"],"sourcesContent":["import {Group, VideoTexture, CanvasTexture, PlaneGeometry, MeshPhongMaterial, Mesh, DoubleSide} from 'three';\r\nimport {bind} from \"lodash-es\";\r\nimport {clearGroup} from '../../../utils/threeUtil';\r\nimport type {Vec, Offset} from './Type'\r\nimport type CustomThreeLayer from '@vue-map/packages/three/ThreeLayer/CustomThreeLayer'\r\n\r\ninterface Options {\r\n  video: HTMLVideoElement //模型下载地址\r\n  videoWidth: number // 视频宽度，默认为实际的视频宽度\r\n  videoHeight: number // 视频高度，默认为实际的视频高度\r\n  videoTranslate: Vec // 视频偏移量\r\n  canvas: HTMLCanvasElement // 背景canvas图层\r\n  position: number[] // 模型的经纬度\r\n  altitude?: number  // 高度，模型的离地高度\r\n  rotation?: Vec // 模型旋转角度\r\n  scale: number | number[]  //模型缩放级别，可以整体缩放和按X Y Z缩放\r\n  angle?: number //  模型旋转角度\r\n  alwaysFront?: boolean  // 位置移动是否开启动画，开启后将会以参数中的duration进行插帧移动\r\n  opacity: number //透明度\r\n  zIndex: number // 层级\r\n}\r\n\r\nclass ThreeVideo {\r\n  object: any // group对象\r\n  animations: any // 模型的动画\r\n  layer?: CustomThreeLayer // threejs的图层对象\r\n  video?: HTMLVideoElement\r\n  videoMesh: any //视频\r\n  bgMesh: any //背景\r\n  canvasTexture?: any\r\n  videoFrame = -1\r\n  rotateFun: any\r\n\r\n  constructor(layer: CustomThreeLayer) {\r\n    this.layer = layer;\r\n  }\r\n\r\n  init(options: Options, $vue: any) {\r\n    this.video = options.video;\r\n    this.object = new Group();\r\n    this.object.isCustomGroup = true;\r\n    this.object.$vue = $vue;\r\n\r\n    return new Promise<void>((resolve) => {\r\n      this.video?.load()\r\n      this.video?.play();\r\n      const texture = new VideoTexture( this.video as HTMLVideoElement );\r\n      const geometry = new PlaneGeometry(options.videoWidth || this.video?.videoWidth, options.videoHeight || this.video?.videoHeight); //矩形平面\r\n      const material = new MeshPhongMaterial({\r\n        map: texture, // 设置纹理贴图\r\n        side: DoubleSide,\r\n        transparent: true,\r\n        depthTest: false\r\n      }); //材质对象Material\r\n      const mesh = new Mesh(geometry, material); //网格模型对象Mesh\r\n      mesh.renderOrder = 3;\r\n      mesh.rotation.y = Math.PI;\r\n      mesh.name = 'video';\r\n      this.videoMesh = mesh;\r\n      this.object.add(mesh);\r\n      this.setVideoTranslate(options.videoTranslate);\r\n      this.setPosition(options.position);\r\n      this.setRotation(options.rotation);\r\n      this.setScale(options.scale);\r\n      this.setAltitude(options.altitude)\r\n      this.layer?.add(this.object);\r\n      this.videoAnimate();\r\n      this.addBgCanvas(options.canvas)\r\n      this.setAngle(options.angle);\r\n      this.setOpacity(options.opacity);\r\n      this.setzIndex(options.zIndex || 0);\r\n      this.bindAlwaysFront(options.alwaysFront);\r\n      resolve()\r\n    })\r\n\r\n  }\r\n\r\n  bindAlwaysFront(alwaysFront?: boolean){\r\n    if(alwaysFront){\r\n      const map = this.layer?.getMap();\r\n      this.rotateFun = bind(this._changeMapRotate, this)\r\n      map.on('rotatechange', this.rotateFun)\r\n    }\r\n  }\r\n\r\n  unBindAlwaysFront(){\r\n    if(this.rotateFun){\r\n      const map = this.layer?.getMap();\r\n      if(map){\r\n        map.off('rotatechange', this.rotateFun)\r\n      }\r\n    }\r\n  }\r\n\r\n  _changeMapRotate(){\r\n    const map = this.layer?.getMap();\r\n    const rotate = map.getRotation();\r\n    this.setAngle(rotate);\r\n  }\r\n\r\n  addBgCanvas(canvas: HTMLCanvasElement){\r\n    if(!canvas){\r\n      return\r\n    }\r\n    const texture = new CanvasTexture( canvas );\r\n    const geometry = new PlaneGeometry(canvas.width, canvas.height); //矩形平面\r\n    const material = new MeshPhongMaterial({\r\n      map: texture, // 设置纹理贴图\r\n      side: DoubleSide,\r\n      transparent: true,\r\n      depthTest: false\r\n    }); //材质对象Material\r\n    const mesh = new Mesh(geometry, material); //网格模型对象Mesh\r\n    mesh.name = 'bg';\r\n    mesh.renderOrder = 1;\r\n    this.object.add(mesh);\r\n    this.canvasTexture = texture;\r\n    this.bgMesh = mesh;\r\n  }\r\n\r\n  videoAnimate(){\r\n    this.videoFrame = requestAnimationFrame(() => {\r\n      this.videoAnimate();\r\n    })\r\n    if(this.canvasTexture){\r\n      this.canvasTexture.needsUpdate = true;\r\n    }\r\n    this.refresh()\r\n  }\r\n\r\n  cancelCanvasTextureAnimate(){\r\n    if(this.videoFrame > 0) {\r\n      cancelAnimationFrame(this.videoFrame);\r\n    }\r\n  }\r\n\r\n  setScale(scale: number | number[]) {\r\n    let scaleArray: number[];\r\n    if (typeof scale === 'number') {\r\n      scaleArray = [scale, scale, scale];\r\n    } else {\r\n      scaleArray = scale;\r\n    }\r\n    this.object.scale.set(...scaleArray);\r\n  }\r\n\r\n  setPosition(position) {\r\n    const positionConvert = this.layer?.convertLngLat(position);\r\n    this.object.position.setX(positionConvert[0]);\r\n    this.object.position.setY(positionConvert[1]);\r\n    this.refresh();\r\n  }\r\n\r\n  setRotation(rotation: Vec | undefined) {\r\n    if (rotation) {\r\n      const x = Math.PI / 180 * (rotation.x || 0);\r\n      const y = Math.PI / 180 * (rotation.y || 0);\r\n      const z = Math.PI / 180 * (rotation.z || 0);\r\n      this.object.rotation.set(x, y, z);\r\n      this.refresh();\r\n    }\r\n  }\r\n  setVideoTranslate(translate: Vec) {\r\n    if (translate) {\r\n      this.videoMesh.translateX(translate.x)\r\n      this.videoMesh.translateY(translate.y)\r\n      this.videoMesh.translateZ(translate.z)\r\n      this.refresh();\r\n    }\r\n  }\r\n\r\n  setAltitude(altitude) {\r\n    if (altitude !== undefined) {\r\n      this.object.position.setZ(altitude);\r\n      this.refresh();\r\n    }\r\n  }\r\n\r\n  setAngle(angle?: number) {\r\n    if(angle !== undefined){\r\n      const x = this.object.rotation.x;\r\n      const z = this.object.rotation.z;\r\n      const y = Math.PI / 180 * angle;\r\n      this.object.rotation.set(x, y, z);\r\n      this.refresh();\r\n    }\r\n  }\r\n\r\n  setOpacity(opacity: number){\r\n    this.videoMesh.material.opacity = opacity;\r\n    if(this.bgMesh){\r\n      this.bgMesh.material.opacity = opacity;\r\n    }\r\n    this.refresh();\r\n  }\r\n\r\n  setzIndex(zIndex: number) {\r\n    this.object.renderOrder = zIndex;\r\n  }\r\n\r\n  refresh() {\r\n    this.layer?.update();\r\n  }\r\n\r\n  show() {\r\n    this.object.visible = true;\r\n    this.refresh();\r\n  }\r\n\r\n  hide() {\r\n    this.object.visible = false;\r\n    this.refresh();\r\n  }\r\n\r\n  start() {\r\n    this.video?.play()\r\n  }\r\n\r\n  pause() {\r\n    this.video?.pause()\r\n  }\r\n\r\n  remove(){\r\n    if (this.object) {\r\n      this.layer?.remove(this.object)\r\n      this.unBindAlwaysFront()\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    this.cancelCanvasTextureAnimate();\r\n    this.unBindAlwaysFront();\r\n    if (this.object) {\r\n      this.object.$vue = null;\r\n      clearGroup(this.object);\r\n      this.video = undefined;\r\n      this.videoMesh = undefined;\r\n      this.bgMesh = undefined;\r\n      this.canvasTexture = undefined;\r\n      this.rotateFun = undefined;\r\n      this.object = null;\r\n      this.layer = undefined;\r\n    }\r\n  }\r\n}\r\n\r\nexport default ThreeVideo\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
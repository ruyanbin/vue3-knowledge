{"ast":null,"code":"import * as echarts from 'echarts/lib/echarts';\nexport default echarts.graphic.extendShape({\n  type: 'ec-liquid-fill',\n  shape: {\n    waveLength: 0,\n    radius: 0,\n    radiusY: 0,\n    cx: 0,\n    cy: 0,\n    waterLevel: 0,\n    amplitude: 0,\n    phase: 0,\n    inverse: false\n  },\n  buildPath: function (ctx, shape) {\n    if (shape.radiusY == null) {\n      shape.radiusY = shape.radius;\n    }\n\n    /**\n     * We define a sine wave having 4 waves, and make sure at least 8 curves\n     * is drawn. Otherwise, it may cause blank area for some waves when\n     * wave length is large enough.\n     */\n    var curves = Math.max(Math.ceil(2 * shape.radius / shape.waveLength * 4) * 2, 8);\n\n    // map phase to [-Math.PI * 2, 0]\n    while (shape.phase < -Math.PI * 2) {\n      shape.phase += Math.PI * 2;\n    }\n    while (shape.phase > 0) {\n      shape.phase -= Math.PI * 2;\n    }\n    var phase = shape.phase / Math.PI / 2 * shape.waveLength;\n    var left = shape.cx - shape.radius + phase - shape.radius * 2;\n\n    /**\n     * top-left corner as start point\n     *\n     * draws this point\n     *  |\n     * \\|/\n     *  ~~~~~~~~\n     *  |      |\n     *  +------+\n     */\n    ctx.moveTo(left, shape.waterLevel);\n\n    /**\n     * top wave\n     *\n     * ~~~~~~~~ <- draws this sine wave\n     * |      |\n     * +------+\n     */\n    var waveRight = 0;\n    for (var c = 0; c < curves; ++c) {\n      var stage = c % 4;\n      var pos = getWaterPositions(c * shape.waveLength / 4, stage, shape.waveLength, shape.amplitude);\n      ctx.bezierCurveTo(pos[0][0] + left, -pos[0][1] + shape.waterLevel, pos[1][0] + left, -pos[1][1] + shape.waterLevel, pos[2][0] + left, -pos[2][1] + shape.waterLevel);\n      if (c === curves - 1) {\n        waveRight = pos[2][0];\n      }\n    }\n    if (shape.inverse) {\n      /**\n       * top-right corner\n       *                  2. draws this line\n       *                          |\n       *                       +------+\n       * 3. draws this line -> |      | <- 1. draws this line\n       *                       ~~~~~~~~\n       */\n      ctx.lineTo(waveRight + left, shape.cy - shape.radiusY);\n      ctx.lineTo(left, shape.cy - shape.radiusY);\n      ctx.lineTo(left, shape.waterLevel);\n    } else {\n      /**\n       * top-right corner\n       *\n       *                       ~~~~~~~~\n       * 3. draws this line -> |      | <- 1. draws this line\n       *                       +------+\n       *                          ^\n       *                          |\n       *                  2. draws this line\n       */\n      ctx.lineTo(waveRight + left, shape.cy + shape.radiusY);\n      ctx.lineTo(left, shape.cy + shape.radiusY);\n      ctx.lineTo(left, shape.waterLevel);\n    }\n    ctx.closePath();\n  }\n});\n\n/**\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\n *\n * @param {number} x          x position of the left-most point (a)\n * @param {number} stage      0-3, stating which part of the wave it is\n * @param {number} waveLength wave length of the sine wave\n * @param {number} amplitude  wave amplitude\n */\nfunction getWaterPositions(x, stage, waveLength, amplitude) {\n  if (stage === 0) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];\n  } else if (stage === 1) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];\n  } else if (stage === 2) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];\n  } else {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];\n  }\n}","map":{"version":3,"names":["echarts","graphic","extendShape","type","shape","waveLength","radius","radiusY","cx","cy","waterLevel","amplitude","phase","inverse","buildPath","ctx","curves","Math","max","ceil","PI","left","moveTo","waveRight","c","stage","pos","getWaterPositions","bezierCurveTo","lineTo","closePath","x"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/echarts-liquidfill/src/liquidFillShape.js"],"sourcesContent":["import * as echarts from 'echarts/lib/echarts';\n\nexport default echarts.graphic.extendShape({\n    type: 'ec-liquid-fill',\n\n    shape: {\n        waveLength: 0,\n        radius: 0,\n        radiusY: 0,\n        cx: 0,\n        cy: 0,\n        waterLevel: 0,\n        amplitude: 0,\n        phase: 0,\n        inverse: false\n    },\n\n    buildPath: function (ctx, shape) {\n        if (shape.radiusY == null) {\n            shape.radiusY = shape.radius;\n        }\n\n        /**\n         * We define a sine wave having 4 waves, and make sure at least 8 curves\n         * is drawn. Otherwise, it may cause blank area for some waves when\n         * wave length is large enough.\n         */\n        var curves = Math.max(\n            Math.ceil(2 * shape.radius / shape.waveLength * 4) * 2,\n            8\n        );\n\n        // map phase to [-Math.PI * 2, 0]\n        while (shape.phase < -Math.PI * 2) {\n            shape.phase += Math.PI * 2;\n        }\n        while (shape.phase > 0) {\n            shape.phase -= Math.PI * 2;\n        }\n        var phase = shape.phase / Math.PI / 2 * shape.waveLength;\n\n        var left = shape.cx - shape.radius + phase - shape.radius * 2;\n\n        /**\n         * top-left corner as start point\n         *\n         * draws this point\n         *  |\n         * \\|/\n         *  ~~~~~~~~\n         *  |      |\n         *  +------+\n         */\n        ctx.moveTo(left, shape.waterLevel);\n\n        /**\n         * top wave\n         *\n         * ~~~~~~~~ <- draws this sine wave\n         * |      |\n         * +------+\n         */\n        var waveRight = 0;\n        for (var c = 0; c < curves; ++c) {\n            var stage = c % 4;\n            var pos = getWaterPositions(c * shape.waveLength / 4, stage,\n                shape.waveLength, shape.amplitude);\n            ctx.bezierCurveTo(pos[0][0] + left, -pos[0][1] + shape.waterLevel,\n                pos[1][0] + left, -pos[1][1] + shape.waterLevel,\n                pos[2][0] + left, -pos[2][1] + shape.waterLevel);\n\n            if (c === curves - 1) {\n                waveRight = pos[2][0];\n            }\n        }\n\n        if (shape.inverse) {\n            /**\n             * top-right corner\n             *                  2. draws this line\n             *                          |\n             *                       +------+\n             * 3. draws this line -> |      | <- 1. draws this line\n             *                       ~~~~~~~~\n             */\n            ctx.lineTo(waveRight + left, shape.cy - shape.radiusY);\n            ctx.lineTo(left, shape.cy - shape.radiusY);\n            ctx.lineTo(left, shape.waterLevel);\n        }\n        else {\n            /**\n             * top-right corner\n             *\n             *                       ~~~~~~~~\n             * 3. draws this line -> |      | <- 1. draws this line\n             *                       +------+\n             *                          ^\n             *                          |\n             *                  2. draws this line\n             */\n            ctx.lineTo(waveRight + left, shape.cy + shape.radiusY);\n            ctx.lineTo(left, shape.cy + shape.radiusY);\n            ctx.lineTo(left, shape.waterLevel);\n        }\n\n        ctx.closePath();\n    }\n});\n\n\n\n/**\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\n *\n * @param {number} x          x position of the left-most point (a)\n * @param {number} stage      0-3, stating which part of the wave it is\n * @param {number} waveLength wave length of the sine wave\n * @param {number} amplitude  wave amplitude\n */\nfunction getWaterPositions(x, stage, waveLength, amplitude) {\n    if (stage === 0) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],\n            [x + 1 / 2 * waveLength / Math.PI,     amplitude],\n            [x + waveLength / 4,                   amplitude]\n        ];\n    }\n    else if (stage === 1) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),\n            amplitude],\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),\n            amplitude / 2],\n            [x + waveLength / 4,                   0]\n        ]\n    }\n    else if (stage === 2) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],\n            [x + 1 / 2 * waveLength / Math.PI,     -amplitude],\n            [x + waveLength / 4,                   -amplitude]\n        ]\n    }\n    else {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),\n            -amplitude],\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),\n            -amplitude / 2],\n            [x + waveLength / 4,                   0]\n        ]\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/resolvers/vuemap-vue-amap.ts
function resolveComponent(name, options) {
  if (options.exclude && name.match(options.exclude))
    return;
  if (!name.match(/^ElAmap[A-Z]*/))
    return;
  return {
    importName: name,
    path: "@vuemap/vue-amap/es"
  };
}
function VueAmapResolver(options = {}) {
  let optionsResolved;
  async function resolveOptions() {
    if (optionsResolved)
      return optionsResolved;
    optionsResolved = __spreadValues({
      exclude: void 0
    }, options);
    return optionsResolved;
  }
  return [
    {
      type: "component",
      resolve: async (name) => {
        return resolveComponent(name, await resolveOptions());
      }
    }
  ];
}

// src/resolvers/vue-bmap-gl.ts
function resolveComponent2(name, options) {
  if (options.exclude && name.match(options.exclude))
    return;
  if (name !== "ElBmap" && !name.match(/^ElBmap[A-Z]/))
    return;
  return {
    importName: name,
    path: "vue-bmap-gl/es"
  };
}
function VueBmapGlResolver(options = {}) {
  let optionsResolved;
  async function resolveOptions() {
    if (optionsResolved)
      return optionsResolved;
    optionsResolved = __spreadValues({
      exclude: void 0
    }, options);
    return optionsResolved;
  }
  return [
    {
      type: "component",
      resolve: async (name) => {
        return resolveComponent2(name, await resolveOptions());
      }
    }
  ];
}

// src/resolvers/vue-mapvgl.ts
function resolveComponent3(name, options) {
  if (options.exclude && name.match(options.exclude))
    return;
  if (!name.match(/^ElBmapv[A-Z]/))
    return;
  return {
    importName: name,
    path: "vue-mapvgl/es"
  };
}
function VueMapvglResolver(options = {}) {
  let optionsResolved;
  async function resolveOptions() {
    if (optionsResolved)
      return optionsResolved;
    optionsResolved = __spreadValues({
      exclude: void 0
    }, options);
    return optionsResolved;
  }
  return [
    {
      type: "component",
      resolve: async (name) => {
        return resolveComponent3(name, await resolveOptions());
      }
    }
  ];
}
export {
  VueAmapResolver,
  VueBmapGlResolver,
  VueMapvglResolver
};

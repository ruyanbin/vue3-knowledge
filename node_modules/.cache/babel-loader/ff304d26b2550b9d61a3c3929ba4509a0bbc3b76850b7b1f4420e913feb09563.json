{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { EllipsoidRegion } from '../math/EllipsoidRegion.js';\nimport { Mesh, Vector3, MathUtils, BoxGeometry, BufferGeometry, EdgesGeometry, LineSegments } from 'three';\nimport { BufferAttribute } from 'three';\nconst _norm = new Vector3();\nconst _norm2 = new Vector3();\nconst _pos = new Vector3();\nconst _vec1 = new Vector3();\nconst _vec2 = new Vector3();\n\n// Converts a geometry with a given set of groups rendering a smaller set of\n// geometry into a new one with only the relevant triangles.\nfunction toGroupGeometry(geometry) {\n  // non indexed makes this process easier\n  geometry = geometry.toNonIndexed();\n\n  // prep the arrays\n  const {\n    groups\n  } = geometry;\n  const {\n    position,\n    normal\n  } = geometry.attributes;\n  const newNorm = [];\n  const newPos = [];\n\n  // add the normals and the positions\n  for (const group of groups) {\n    const {\n      start,\n      count\n    } = group;\n    for (let i = start, l = start + count; i < l; i++) {\n      _vec1.fromBufferAttribute(position, i);\n      _vec2.fromBufferAttribute(normal, i);\n      newPos.push(..._vec1);\n      newNorm.push(..._vec2);\n    }\n  }\n\n  // set the new geometry\n  const newGeometry = new BufferGeometry();\n  newGeometry.setAttribute('position', new BufferAttribute(new Float32Array(newPos), 3));\n  newGeometry.setAttribute('normal', new BufferAttribute(new Float32Array(newNorm), 3));\n  return newGeometry;\n}\nfunction getRegionGeometry(ellipsoidRegion) {\n  // retrieve the relevant fields\n  const {\n    latStart = -Math.PI / 2,\n    latEnd = Math.PI / 2,\n    lonStart = 0,\n    lonEnd = 2 * Math.PI,\n    heightStart = 0,\n    heightEnd = 0\n  } = ellipsoidRegion;\n\n  // get the attributes\n  const geometry = new BoxGeometry(1, 1, 1, 32, 32);\n  const {\n    normal,\n    position\n  } = geometry.attributes;\n\n  // clone the position buffer so we can reference it for normal calculations later\n  const refPosition = position.clone();\n\n  // perturb the position buffer into an ellipsoid region\n  for (let i = 0, l = position.count; i < l; i++) {\n    _pos.fromBufferAttribute(position, i);\n    const lat = MathUtils.mapLinear(_pos.x, -0.5, 0.5, latStart, latEnd);\n    const lon = MathUtils.mapLinear(_pos.y, -0.5, 0.5, lonStart, lonEnd);\n    let height = heightStart;\n    ellipsoidRegion.getCartographicToNormal(lat, lon, _norm);\n    if (_pos.z < 0) {\n      height = heightEnd;\n    }\n    ellipsoidRegion.getCartographicToPosition(lat, lon, height, _pos);\n    position.setXYZ(i, ..._pos);\n  }\n\n  // compute the vertex normals so we can get the edge normals\n  geometry.computeVertexNormals();\n\n  // compute the top and bottom cap normals\n  for (let i = 0, l = refPosition.count; i < l; i++) {\n    _pos.fromBufferAttribute(refPosition, i);\n    const lat = MathUtils.mapLinear(_pos.x, -0.5, 0.5, latStart, latEnd);\n    const lon = MathUtils.mapLinear(_pos.y, -0.5, 0.5, lonStart, lonEnd);\n    _norm.fromBufferAttribute(normal, i);\n    ellipsoidRegion.getCartographicToNormal(lat, lon, _norm2);\n\n    // exclude the sides so we get sharp corners\n    if (Math.abs(_norm.dot(_norm2)) > 0.1) {\n      if (_pos.z > 0) {\n        _norm2.multiplyScalar(-1);\n      }\n      normal.setXYZ(i, ..._norm2);\n    }\n  }\n  return geometry;\n}\nexport class EllipsoidRegionLineHelper extends LineSegments {\n  constructor(ellipsoidRegion = new EllipsoidRegion(), color = 0xffff00) {\n    super();\n    this.ellipsoidRegion = ellipsoidRegion;\n    this.material.color.set(color);\n    this.update();\n  }\n  update() {\n    const geometry = getRegionGeometry(this.ellipsoidRegion);\n    this.geometry.dispose();\n    this.geometry = new EdgesGeometry(geometry, 80);\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nexport class EllipsoidRegionHelper extends Mesh {\n  constructor(ellipsoidRegion = new EllipsoidRegion()) {\n    super();\n    this.ellipsoidRegion = ellipsoidRegion;\n    this.update();\n  }\n  update() {\n    // dispose of the existing geometry\n    this.geometry.dispose();\n\n    // retrieve the relevant fields\n    const geometry = getRegionGeometry(this.ellipsoidRegion);\n    const {\n      lonStart,\n      lonEnd\n    } = this;\n\n    // exclude the side tris if the region wraps around\n    if (lonEnd - lonStart >= 2 * Math.PI) {\n      geometry.groups.splice(2, 2);\n      this.geometry = toGroupGeometry(geometry);\n    } else {\n      this.geometry = geometry;\n    }\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}","map":{"version":3,"names":["EllipsoidRegion","Mesh","Vector3","MathUtils","BoxGeometry","BufferGeometry","EdgesGeometry","LineSegments","BufferAttribute","_norm","_norm2","_pos","_vec1","_vec2","toGroupGeometry","geometry","toNonIndexed","groups","position","normal","attributes","newNorm","newPos","group","start","count","i","l","fromBufferAttribute","push","newGeometry","setAttribute","Float32Array","getRegionGeometry","ellipsoidRegion","latStart","Math","PI","latEnd","lonStart","lonEnd","heightStart","heightEnd","refPosition","clone","lat","mapLinear","x","lon","y","height","getCartographicToNormal","z","getCartographicToPosition","setXYZ","computeVertexNormals","abs","dot","multiplyScalar","EllipsoidRegionLineHelper","constructor","color","material","set","update","dispose","EllipsoidRegionHelper","splice"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/3d-tiles-renderer/src/three/objects/EllipsoidRegionHelper.js"],"sourcesContent":["import { EllipsoidRegion } from '../math/EllipsoidRegion.js';\nimport { Mesh, Vector3, MathUtils, BoxGeometry, BufferGeometry, EdgesGeometry, LineSegments } from 'three';\nimport { BufferAttribute } from 'three';\n\nconst _norm = new Vector3();\nconst _norm2 = new Vector3();\nconst _pos = new Vector3();\nconst _vec1 = new Vector3();\nconst _vec2 = new Vector3();\n\n// Converts a geometry with a given set of groups rendering a smaller set of\n// geometry into a new one with only the relevant triangles.\nfunction toGroupGeometry( geometry ) {\n\n\t// non indexed makes this process easier\n\tgeometry = geometry.toNonIndexed();\n\n\t// prep the arrays\n\tconst { groups } = geometry;\n\tconst { position, normal } = geometry.attributes;\n\tconst newNorm = [];\n\tconst newPos = [];\n\n\t// add the normals and the positions\n\tfor ( const group of groups ) {\n\n\t\tconst { start, count } = group;\n\t\tfor ( let i = start, l = ( start + count ); i < l; i ++ ) {\n\n\t\t\t_vec1.fromBufferAttribute( position, i );\n\t\t\t_vec2.fromBufferAttribute( normal, i );\n\n\t\t\tnewPos.push( ..._vec1 );\n\t\t\tnewNorm.push( ..._vec2 );\n\n\t\t}\n\n\t}\n\n\t// set the new geometry\n\tconst newGeometry = new BufferGeometry();\n\tnewGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( newPos ), 3 ) );\n\tnewGeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( newNorm ), 3 ) );\n\n\treturn newGeometry;\n\n}\n\nfunction getRegionGeometry( ellipsoidRegion ) {\n\n\t// retrieve the relevant fields\n\tconst {\n\t\tlatStart = - Math.PI / 2, latEnd = Math.PI / 2,\n\t\tlonStart = 0, lonEnd = 2 * Math.PI,\n\t\theightStart = 0, heightEnd = 0,\n\t} = ellipsoidRegion;\n\n\t// get the attributes\n\tconst geometry = new BoxGeometry( 1, 1, 1, 32, 32 );\n\tconst { normal, position } = geometry.attributes;\n\n\t// clone the position buffer so we can reference it for normal calculations later\n\tconst refPosition = position.clone();\n\n\t// perturb the position buffer into an ellipsoid region\n\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t_pos.fromBufferAttribute( position, i );\n\n\t\tconst lat = MathUtils.mapLinear( _pos.x, - 0.5, 0.5, latStart, latEnd );\n\t\tconst lon = MathUtils.mapLinear( _pos.y, - 0.5, 0.5, lonStart, lonEnd );\n\n\t\tlet height = heightStart;\n\t\tellipsoidRegion.getCartographicToNormal( lat, lon, _norm );\n\t\tif ( _pos.z < 0 ) {\n\n\t\t\theight = heightEnd;\n\n\t\t}\n\t\tellipsoidRegion.getCartographicToPosition( lat, lon, height, _pos );\n\t\tposition.setXYZ( i, ..._pos );\n\n\t}\n\n\t// compute the vertex normals so we can get the edge normals\n\tgeometry.computeVertexNormals();\n\n\t// compute the top and bottom cap normals\n\tfor ( let i = 0, l = refPosition.count; i < l; i ++ ) {\n\n\t\t_pos.fromBufferAttribute( refPosition, i );\n\n\t\tconst lat = MathUtils.mapLinear( _pos.x, - 0.5, 0.5, latStart, latEnd );\n\t\tconst lon = MathUtils.mapLinear( _pos.y, - 0.5, 0.5, lonStart, lonEnd );\n\n\t\t_norm.fromBufferAttribute( normal, i );\n\t\tellipsoidRegion.getCartographicToNormal( lat, lon, _norm2 );\n\n\t\t// exclude the sides so we get sharp corners\n\t\tif ( Math.abs( _norm.dot( _norm2 ) ) > 0.1 ) {\n\n\t\t\tif ( _pos.z > 0 ) {\n\n\t\t\t\t_norm2.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tnormal.setXYZ( i, ..._norm2 );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\nexport class EllipsoidRegionLineHelper extends LineSegments {\n\n\tconstructor( ellipsoidRegion = new EllipsoidRegion(), color = 0xffff00 ) {\n\n\t\tsuper();\n\t\tthis.ellipsoidRegion = ellipsoidRegion;\n\t\tthis.material.color.set( color );\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst geometry = getRegionGeometry( this.ellipsoidRegion );\n\t\tthis.geometry.dispose();\n\t\tthis.geometry = new EdgesGeometry( geometry, 80 );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nexport class EllipsoidRegionHelper extends Mesh {\n\n\tconstructor( ellipsoidRegion = new EllipsoidRegion() ) {\n\n\t\tsuper();\n\t\tthis.ellipsoidRegion = ellipsoidRegion;\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\t// dispose of the existing geometry\n\t\tthis.geometry.dispose();\n\n\t\t// retrieve the relevant fields\n\t\tconst geometry = getRegionGeometry( this.ellipsoidRegion );\n\t\tconst { lonStart, lonEnd } = this;\n\n\t\t// exclude the side tris if the region wraps around\n\t\tif ( lonEnd - lonStart >= 2 * Math.PI ) {\n\n\t\t\tgeometry.groups.splice( 2, 2 );\n\t\t\tthis.geometry = toGroupGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tthis.geometry = geometry;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Fires at the end of the frame and before the next one\nfunction enqueueMicrotask(callback) {\n  Promise.resolve().then(callback);\n}\nclass LRUCache {\n  constructor() {\n    // options\n    this.maxSize = 800;\n    this.minSize = 600;\n    this.unloadPercent = 0.05;\n\n    // \"itemSet\" doubles as both the list of the full set of items currently\n    // stored in the cache (keys) as well as a map to the time the item was last\n    // used so it can be sorted appropriately.\n    this.itemSet = new Map();\n    this.itemList = [];\n    this.usedSet = new Set();\n    this.callbacks = new Map();\n    this.unloadPriorityCallback = null;\n    const itemSet = this.itemSet;\n    this.defaultPriorityCallback = item => itemSet.get(item);\n  }\n\n  // Returns whether or not the cache has reached the maximum size\n  isFull() {\n    return this.itemSet.size >= this.maxSize;\n  }\n  add(item, removeCb) {\n    const itemSet = this.itemSet;\n    if (itemSet.has(item)) {\n      return false;\n    }\n    if (this.isFull()) {\n      return false;\n    }\n    const usedSet = this.usedSet;\n    const itemList = this.itemList;\n    const callbacks = this.callbacks;\n    itemList.push(item);\n    usedSet.add(item);\n    itemSet.set(item, Date.now());\n    callbacks.set(item, removeCb);\n    return true;\n  }\n  remove(item) {\n    const usedSet = this.usedSet;\n    const itemSet = this.itemSet;\n    const itemList = this.itemList;\n    const callbacks = this.callbacks;\n    if (itemSet.has(item)) {\n      callbacks.get(item)(item);\n      const index = itemList.indexOf(item);\n      itemList.splice(index, 1);\n      usedSet.delete(item);\n      itemSet.delete(item);\n      callbacks.delete(item);\n      return true;\n    }\n    return false;\n  }\n  markUsed(item) {\n    const itemSet = this.itemSet;\n    const usedSet = this.usedSet;\n    if (itemSet.has(item) && !usedSet.has(item)) {\n      itemSet.set(item, Date.now());\n      usedSet.add(item);\n    }\n  }\n  markAllUnused() {\n    this.usedSet.clear();\n  }\n\n  // TODO: this should be renamed because it's not necessarily unloading all unused content\n  // Maybe call it \"cleanup\" or \"unloadToMinSize\"\n  unloadUnusedContent() {\n    const unloadPercent = this.unloadPercent;\n    const targetSize = this.minSize;\n    const itemList = this.itemList;\n    const itemSet = this.itemSet;\n    const usedSet = this.usedSet;\n    const callbacks = this.callbacks;\n    const unused = itemList.length - usedSet.size;\n    const excess = itemList.length - targetSize;\n    const unloadPriorityCallback = this.unloadPriorityCallback || this.defaultPriorityCallback;\n    if (excess > 0 && unused > 0) {\n      // used items should be at the end of the array\n      itemList.sort((a, b) => {\n        const usedA = usedSet.has(a);\n        const usedB = usedSet.has(b);\n        if (usedA && usedB) {\n          // If they're both used then don't bother moving them\n          return 0;\n        } else if (!usedA && !usedB) {\n          // Use the sort function otherwise\n          // higher priority should be further to the left\n          return unloadPriorityCallback(b) - unloadPriorityCallback(a);\n        } else {\n          // If one is used and the other is not move the used one towards the end of the array\n          return usedA ? 1 : -1;\n        }\n      });\n\n      // address corner cases where the minSize might be zero or smaller than maxSize - minSize,\n      // which would result in a very small or no items being unloaded.\n      const unusedExcess = Math.min(excess, unused);\n      const maxUnload = Math.max(targetSize * unloadPercent, unusedExcess * unloadPercent);\n      let nodesToUnload = Math.min(maxUnload, unused);\n      nodesToUnload = Math.ceil(nodesToUnload);\n      const removedItems = itemList.splice(0, nodesToUnload);\n      for (let i = 0, l = removedItems.length; i < l; i++) {\n        const item = removedItems[i];\n        callbacks.get(item)(item);\n        itemSet.delete(item);\n        callbacks.delete(item);\n      }\n    }\n  }\n  scheduleUnload(markAllUnused = true) {\n    if (!this.scheduled) {\n      this.scheduled = true;\n      enqueueMicrotask(() => {\n        this.scheduled = false;\n        this.unloadUnusedContent();\n        if (markAllUnused) {\n          this.markAllUnused();\n        }\n      });\n    }\n  }\n}\nexport { LRUCache };","map":{"version":3,"names":["enqueueMicrotask","callback","Promise","resolve","then","LRUCache","constructor","maxSize","minSize","unloadPercent","itemSet","Map","itemList","usedSet","Set","callbacks","unloadPriorityCallback","defaultPriorityCallback","item","get","isFull","size","add","removeCb","has","push","set","Date","now","remove","index","indexOf","splice","delete","markUsed","markAllUnused","clear","unloadUnusedContent","targetSize","unused","length","excess","sort","a","b","usedA","usedB","unusedExcess","Math","min","maxUnload","max","nodesToUnload","ceil","removedItems","i","l","scheduleUnload","scheduled"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/3d-tiles-renderer/src/utilities/LRUCache.js"],"sourcesContent":["// Fires at the end of the frame and before the next one\nfunction enqueueMicrotask( callback ) {\n\n\tPromise.resolve().then( callback );\n\n}\n\nclass LRUCache {\n\n\tconstructor() {\n\n\t\t// options\n\t\tthis.maxSize = 800;\n\t\tthis.minSize = 600;\n\t\tthis.unloadPercent = 0.05;\n\n\t\t// \"itemSet\" doubles as both the list of the full set of items currently\n\t\t// stored in the cache (keys) as well as a map to the time the item was last\n\t\t// used so it can be sorted appropriately.\n\t\tthis.itemSet = new Map();\n\t\tthis.itemList = [];\n\t\tthis.usedSet = new Set();\n\t\tthis.callbacks = new Map();\n\n\t\tthis.unloadPriorityCallback = null;\n\n\t\tconst itemSet = this.itemSet;\n\t\tthis.defaultPriorityCallback = item => itemSet.get( item );\n\n\t}\n\n\t// Returns whether or not the cache has reached the maximum size\n\tisFull() {\n\n\t\treturn this.itemSet.size >= this.maxSize;\n\n\t}\n\n\tadd( item, removeCb ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( this.isFull() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemList = this.itemList;\n\t\tconst callbacks = this.callbacks;\n\t\titemList.push( item );\n\t\tusedSet.add( item );\n\t\titemSet.set( item, Date.now() );\n\t\tcallbacks.set( item, removeCb );\n\n\t\treturn true;\n\n\t}\n\n\tremove( item ) {\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemSet = this.itemSet;\n\t\tconst itemList = this.itemList;\n\t\tconst callbacks = this.callbacks;\n\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\tcallbacks.get( item )( item );\n\n\t\t\tconst index = itemList.indexOf( item );\n\t\t\titemList.splice( index, 1 );\n\t\t\tusedSet.delete( item );\n\t\t\titemSet.delete( item );\n\t\t\tcallbacks.delete( item );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tmarkUsed( item ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tconst usedSet = this.usedSet;\n\t\tif ( itemSet.has( item ) && ! usedSet.has( item ) ) {\n\n\t\t\titemSet.set( item, Date.now() );\n\t\t\tusedSet.add( item );\n\n\t\t}\n\n\t}\n\n\tmarkAllUnused() {\n\n\t\tthis.usedSet.clear();\n\n\t}\n\n\t// TODO: this should be renamed because it's not necessarily unloading all unused content\n\t// Maybe call it \"cleanup\" or \"unloadToMinSize\"\n\tunloadUnusedContent() {\n\n\t\tconst unloadPercent = this.unloadPercent;\n\t\tconst targetSize = this.minSize;\n\t\tconst itemList = this.itemList;\n\t\tconst itemSet = this.itemSet;\n\t\tconst usedSet = this.usedSet;\n\t\tconst callbacks = this.callbacks;\n\t\tconst unused = itemList.length - usedSet.size;\n\t\tconst excess = itemList.length - targetSize;\n\t\tconst unloadPriorityCallback = this.unloadPriorityCallback || this.defaultPriorityCallback;\n\n\t\tif ( excess > 0 && unused > 0 ) {\n\n\t\t\t// used items should be at the end of the array\n\t\t\titemList.sort( ( a, b ) => {\n\n\t\t\t\tconst usedA = usedSet.has( a );\n\t\t\t\tconst usedB = usedSet.has( b );\n\t\t\t\tif ( usedA && usedB ) {\n\n\t\t\t\t\t// If they're both used then don't bother moving them\n\t\t\t\t\treturn 0;\n\n\t\t\t\t} else if ( ! usedA && ! usedB ) {\n\n\t\t\t\t\t// Use the sort function otherwise\n\t\t\t\t\t// higher priority should be further to the left\n\t\t\t\t\treturn unloadPriorityCallback( b ) - unloadPriorityCallback( a );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If one is used and the other is not move the used one towards the end of the array\n\t\t\t\t\treturn usedA ? 1 : - 1;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// address corner cases where the minSize might be zero or smaller than maxSize - minSize,\n\t\t\t// which would result in a very small or no items being unloaded.\n\t\t\tconst unusedExcess = Math.min( excess, unused );\n\t\t\tconst maxUnload = Math.max( targetSize * unloadPercent, unusedExcess * unloadPercent );\n\t\t\tlet nodesToUnload = Math.min( maxUnload, unused );\n\t\t\tnodesToUnload = Math.ceil( nodesToUnload );\n\n\t\t\tconst removedItems = itemList.splice( 0, nodesToUnload );\n\t\t\tfor ( let i = 0, l = removedItems.length; i < l; i ++ ) {\n\n\t\t\t\tconst item = removedItems[ i ];\n\t\t\t\tcallbacks.get( item )( item );\n\t\t\t\titemSet.delete( item );\n\t\t\t\tcallbacks.delete( item );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tscheduleUnload( markAllUnused = true ) {\n\n\t\tif ( ! this.scheduled ) {\n\n\t\t\tthis.scheduled = true;\n\t\t\tenqueueMicrotask( () => {\n\n\t\t\t\tthis.scheduled = false;\n\t\t\t\tthis.unloadUnusedContent();\n\t\t\t\tif ( markAllUnused ) {\n\n\t\t\t\t\tthis.markAllUnused();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LRUCache };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
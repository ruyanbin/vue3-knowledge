{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { MathUtils, Matrix4 } from 'three';\nimport { Vector3 } from 'three';\nimport { Ellipsoid } from './Ellipsoid.js';\nconst PI = Math.PI;\nconst HALF_PI = PI / 2;\nconst _orthoX = new Vector3();\nconst _orthoY = new Vector3();\nconst _orthoZ = new Vector3();\nconst _invMatrix = new Matrix4();\nlet _poolIndex = 0;\nconst _pointsPool = [];\nfunction getVector(usePool = false) {\n  if (!usePool) {\n    return new Vector3();\n  }\n  if (!_pointsPool[_poolIndex]) {\n    _pointsPool[_poolIndex] = new Vector3();\n  }\n  _poolIndex++;\n  return _pointsPool[_poolIndex - 1];\n}\nfunction resetPool() {\n  _poolIndex = 0;\n}\nexport class EllipsoidRegion extends Ellipsoid {\n  constructor(x, y, z, latStart = -HALF_PI, latEnd = HALF_PI, lonStart = 0, lonEnd = 2 * PI, heightStart = 0, heightEnd = 0) {\n    super(x, y, z);\n    this.latStart = latStart;\n    this.latEnd = latEnd;\n    this.lonStart = lonStart;\n    this.lonEnd = lonEnd;\n    this.heightStart = heightStart;\n    this.heightEnd = heightEnd;\n  }\n  _getPoints(usePool = false) {\n    const {\n      latStart,\n      latEnd,\n      lonStart,\n      lonEnd,\n      heightStart,\n      heightEnd\n    } = this;\n    const midLat = MathUtils.mapLinear(0.5, 0, 1, latStart, latEnd);\n    const midLon = MathUtils.mapLinear(0.5, 0, 1, lonStart, lonEnd);\n    const lonOffset = Math.floor(lonStart / HALF_PI) * HALF_PI;\n    const latlon = [[-PI / 2, 0], [PI / 2, 0], [0, lonOffset], [0, lonOffset + PI / 2], [0, lonOffset + PI], [0, lonOffset + 3 * PI / 2], [latStart, lonEnd], [latEnd, lonEnd], [latStart, lonStart], [latEnd, lonStart], [0, lonStart], [0, lonEnd], [midLat, midLon], [latStart, midLon], [latEnd, midLon], [midLat, lonStart], [midLat, lonEnd]];\n    const target = [];\n    const total = latlon.length;\n    for (let z = 0; z <= 1; z++) {\n      const height = MathUtils.mapLinear(z, 0, 1, heightStart, heightEnd);\n      for (let i = 0, l = total; i < l; i++) {\n        const [lat, lon] = latlon[i];\n        if (lat >= latStart && lat <= latEnd && lon >= lonStart && lon <= lonEnd) {\n          const v = getVector(usePool);\n          target.push(v);\n          this.getCartographicToPosition(lat, lon, height, v);\n        }\n      }\n    }\n    return target;\n  }\n  getBoundingBox(box, matrix) {\n    resetPool();\n    const {\n      latStart,\n      latEnd,\n      lonStart,\n      lonEnd\n    } = this;\n    const latRange = latEnd - latStart;\n    if (latRange < PI / 2) {\n      // get the midway point for the region\n      const midLat = MathUtils.mapLinear(0.5, 0, 1, latStart, latEnd);\n      const midLon = MathUtils.mapLinear(0.5, 0, 1, lonStart, lonEnd);\n\n      // get the frame matrix for the box - works well for smaller regions\n      this.getCartographicToNormal(midLat, midLon, _orthoZ);\n      _orthoY.set(0, 0, 1);\n      _orthoX.crossVectors(_orthoY, _orthoZ);\n      _orthoY.crossVectors(_orthoX, _orthoZ);\n      matrix.makeBasis(_orthoX, _orthoY, _orthoZ);\n    } else {\n      _orthoX.set(1, 0, 0);\n      _orthoY.set(0, 1, 0);\n      _orthoZ.set(0, 0, 1);\n      matrix.makeBasis(_orthoX, _orthoY, _orthoZ);\n    }\n\n    // transform the points into the local frame\n    _invMatrix.copy(matrix).invert();\n    const points = this._getPoints(true);\n    for (let i = 0, l = points.length; i < l; i++) {\n      points[i].applyMatrix4(_invMatrix);\n    }\n\n    // init the box\n    box.makeEmpty();\n    box.setFromPoints(points);\n  }\n  getBoundingSphere(sphere, center) {\n    resetPool();\n    const points = this._getPoints(true);\n    sphere.makeEmpty();\n    sphere.setFromPoints(points, center);\n  }\n}","map":{"version":3,"names":["MathUtils","Matrix4","Vector3","Ellipsoid","PI","Math","HALF_PI","_orthoX","_orthoY","_orthoZ","_invMatrix","_poolIndex","_pointsPool","getVector","usePool","resetPool","EllipsoidRegion","constructor","x","y","z","latStart","latEnd","lonStart","lonEnd","heightStart","heightEnd","_getPoints","midLat","mapLinear","midLon","lonOffset","floor","latlon","target","total","length","height","i","l","lat","lon","v","push","getCartographicToPosition","getBoundingBox","box","matrix","latRange","getCartographicToNormal","set","crossVectors","makeBasis","copy","invert","points","applyMatrix4","makeEmpty","setFromPoints","getBoundingSphere","sphere","center"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/3d-tiles-renderer/src/three/math/EllipsoidRegion.js"],"sourcesContent":["import { MathUtils, Matrix4 } from 'three';\nimport { Vector3 } from 'three';\nimport { Ellipsoid } from './Ellipsoid.js';\n\nconst PI = Math.PI;\nconst HALF_PI = PI / 2;\n\nconst _orthoX = new Vector3();\nconst _orthoY = new Vector3();\nconst _orthoZ = new Vector3();\nconst _invMatrix = new Matrix4();\n\nlet _poolIndex = 0;\nconst _pointsPool = [];\nfunction getVector( usePool = false ) {\n\n\tif ( ! usePool ) {\n\n\t\treturn new Vector3();\n\n\t}\n\n\tif ( ! _pointsPool[ _poolIndex ] ) {\n\n\t\t_pointsPool[ _poolIndex ] = new Vector3();\n\n\t}\n\n\t_poolIndex ++;\n\treturn _pointsPool[ _poolIndex - 1 ];\n\n}\n\nfunction resetPool() {\n\n\t_poolIndex = 0;\n\n}\n\nexport class EllipsoidRegion extends Ellipsoid {\n\n\tconstructor(\n\t\tx, y, z,\n\t\tlatStart = - HALF_PI, latEnd = HALF_PI,\n\t\tlonStart = 0, lonEnd = 2 * PI,\n\t\theightStart = 0, heightEnd = 0\n\t) {\n\n\t\tsuper( x, y, z );\n\t\tthis.latStart = latStart;\n\t\tthis.latEnd = latEnd;\n\t\tthis.lonStart = lonStart;\n\t\tthis.lonEnd = lonEnd;\n\t\tthis.heightStart = heightStart;\n\t\tthis.heightEnd = heightEnd;\n\n\t}\n\n\t_getPoints( usePool = false ) {\n\n\t\tconst {\n\t\t\tlatStart, latEnd,\n\t\t\tlonStart, lonEnd,\n\t\t\theightStart, heightEnd,\n\t\t} = this;\n\n\t\tconst midLat = MathUtils.mapLinear( 0.5, 0, 1, latStart, latEnd );\n\t\tconst midLon = MathUtils.mapLinear( 0.5, 0, 1, lonStart, lonEnd );\n\n\t\tconst lonOffset = Math.floor( lonStart / HALF_PI ) * HALF_PI;\n\t\tconst latlon = [\n\t\t\t[ - PI / 2, 0 ],\n\t\t\t[ PI / 2, 0 ],\n\t\t\t[ 0, lonOffset ],\n\t\t\t[ 0, lonOffset + PI / 2 ],\n\t\t\t[ 0, lonOffset + PI ],\n\t\t\t[ 0, lonOffset + 3 * PI / 2 ],\n\n\t\t\t[ latStart, lonEnd ],\n\t\t\t[ latEnd, lonEnd ],\n\t\t\t[ latStart, lonStart ],\n\t\t\t[ latEnd, lonStart ],\n\n\t\t\t[ 0, lonStart ],\n\t\t\t[ 0, lonEnd ],\n\n\t\t\t[ midLat, midLon ],\n\t\t\t[ latStart, midLon ],\n\t\t\t[ latEnd, midLon ],\n\t\t\t[ midLat, lonStart ],\n\t\t\t[ midLat, lonEnd ],\n\n\t\t];\n\n\t\tconst target = [];\n\t\tconst total = latlon.length;\n\n\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\tconst height = MathUtils.mapLinear( z, 0, 1, heightStart, heightEnd );\n\t\t\tfor ( let i = 0, l = total; i < l; i ++ ) {\n\n\t\t\t\tconst [ lat, lon ] = latlon[ i ];\n\t\t\t\tif ( lat >= latStart && lat <= latEnd && lon >= lonStart && lon <= lonEnd ) {\n\n\t\t\t\t\tconst v = getVector( usePool );\n\t\t\t\t\ttarget.push( v );\n\t\t\t\t\tthis.getCartographicToPosition( lat, lon, height, v );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( box, matrix ) {\n\n\t\tresetPool();\n\n\t\tconst {\n\t\t\tlatStart, latEnd,\n\t\t\tlonStart, lonEnd,\n\t\t} = this;\n\n\t\tconst latRange = latEnd - latStart;\n\t\tif ( latRange < PI / 2 ) {\n\n\t\t\t// get the midway point for the region\n\t\t\tconst midLat = MathUtils.mapLinear( 0.5, 0, 1, latStart, latEnd );\n\t\t\tconst midLon = MathUtils.mapLinear( 0.5, 0, 1, lonStart, lonEnd );\n\n\t\t\t// get the frame matrix for the box - works well for smaller regions\n\t\t\tthis.getCartographicToNormal( midLat, midLon, _orthoZ );\n\t\t\t_orthoY.set( 0, 0, 1 );\n\t\t\t_orthoX.crossVectors( _orthoY, _orthoZ );\n\t\t\t_orthoY.crossVectors( _orthoX, _orthoZ );\n\t\t\tmatrix.makeBasis( _orthoX, _orthoY, _orthoZ );\n\n\t\t} else {\n\n\t\t\t_orthoX.set( 1, 0, 0 );\n\t\t\t_orthoY.set( 0, 1, 0 );\n\t\t\t_orthoZ.set( 0, 0, 1 );\n\t\t\tmatrix.makeBasis( _orthoX, _orthoY, _orthoZ );\n\n\t\t}\n\n\t\t// transform the points into the local frame\n\t\t_invMatrix.copy( matrix ).invert();\n\n\t\tconst points = this._getPoints( true );\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tpoints[ i ].applyMatrix4( _invMatrix );\n\n\t\t}\n\n\t\t// init the box\n\t\tbox.makeEmpty();\n\t\tbox.setFromPoints( points );\n\n\t}\n\n\tgetBoundingSphere( sphere, center ) {\n\n\t\tresetPool();\n\n\t\tconst points = this._getPoints( true );\n\t\tsphere.makeEmpty();\n\t\tsphere.setFromPoints( points, center );\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*!\n  * message-compiler v9.2.2\n  * (c) 2022 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar shared = require('@intlify/shared');\nvar sourceMap = require('source-map');\nconst CompileErrorCodes = {\n  // tokenizer error codes\n  EXPECTED_TOKEN: 1,\n  INVALID_TOKEN_IN_PLACEHOLDER: 2,\n  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\n  UNKNOWN_ESCAPE_SEQUENCE: 4,\n  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\n  UNBALANCED_CLOSING_BRACE: 6,\n  UNTERMINATED_CLOSING_BRACE: 7,\n  EMPTY_PLACEHOLDER: 8,\n  NOT_ALLOW_NEST_PLACEHOLDER: 9,\n  INVALID_LINKED_FORMAT: 10,\n  // parser error codes\n  MUST_HAVE_MESSAGES_IN_PLURAL: 11,\n  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\n  UNEXPECTED_EMPTY_LINKED_KEY: 13,\n  UNEXPECTED_LEXICAL_ANALYSIS: 14,\n  // Special value for higher-order compilers to pick up the last code\n  // to avoid collision of error codes. This should always be kept as the last\n  // item.\n  __EXTEND_POINT__: 15\n};\n/** @internal */\nconst errorMessages = {\n  // tokenizer error messages\n  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,\n  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,\n  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,\n  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\\\{0}`,\n  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,\n  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,\n  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,\n  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,\n  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,\n  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,\n  // parser error messages\n  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,\n  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,\n  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,\n  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`\n};\nfunction createCompileError(code, loc, options = {}) {\n  const {\n    domain,\n    messages,\n    args\n  } = options;\n  const msg = shared.format((messages || errorMessages)[code] || '', ...(args || []));\n  const error = new SyntaxError(String(msg));\n  error.code = code;\n  if (loc) {\n    error.location = loc;\n  }\n  error.domain = domain;\n  return error;\n}\n/** @internal */\nfunction defaultOnError(error) {\n  throw error;\n}\nconst LocationStub = {\n  start: {\n    line: 1,\n    column: 1,\n    offset: 0\n  },\n  end: {\n    line: 1,\n    column: 1,\n    offset: 0\n  }\n};\nfunction createPosition(line, column, offset) {\n  return {\n    line,\n    column,\n    offset\n  };\n}\nfunction createLocation(start, end, source) {\n  const loc = {\n    start,\n    end\n  };\n  if (source != null) {\n    loc.source = source;\n  }\n  return loc;\n}\nconst CHAR_SP = ' ';\nconst CHAR_CR = '\\r';\nconst CHAR_LF = '\\n';\nconst CHAR_LS = String.fromCharCode(0x2028);\nconst CHAR_PS = String.fromCharCode(0x2029);\nfunction createScanner(str) {\n  const _buf = str;\n  let _index = 0;\n  let _line = 1;\n  let _column = 1;\n  let _peekOffset = 0;\n  const isCRLF = index => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\n  const isLF = index => _buf[index] === CHAR_LF;\n  const isPS = index => _buf[index] === CHAR_PS;\n  const isLS = index => _buf[index] === CHAR_LS;\n  const isLineEnd = index => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\n  const index = () => _index;\n  const line = () => _line;\n  const column = () => _column;\n  const peekOffset = () => _peekOffset;\n  const charAt = offset => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\n  const currentChar = () => charAt(_index);\n  const currentPeek = () => charAt(_index + _peekOffset);\n  function next() {\n    _peekOffset = 0;\n    if (isLineEnd(_index)) {\n      _line++;\n      _column = 0;\n    }\n    if (isCRLF(_index)) {\n      _index++;\n    }\n    _index++;\n    _column++;\n    return _buf[_index];\n  }\n  function peek() {\n    if (isCRLF(_index + _peekOffset)) {\n      _peekOffset++;\n    }\n    _peekOffset++;\n    return _buf[_index + _peekOffset];\n  }\n  function reset() {\n    _index = 0;\n    _line = 1;\n    _column = 1;\n    _peekOffset = 0;\n  }\n  function resetPeek(offset = 0) {\n    _peekOffset = offset;\n  }\n  function skipToPeek() {\n    const target = _index + _peekOffset;\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (target !== _index) {\n      next();\n    }\n    _peekOffset = 0;\n  }\n  return {\n    index,\n    line,\n    column,\n    peekOffset,\n    charAt,\n    currentChar,\n    currentPeek,\n    next,\n    peek,\n    reset,\n    resetPeek,\n    skipToPeek\n  };\n}\nconst EOF = undefined;\nconst LITERAL_DELIMITER = \"'\";\nconst ERROR_DOMAIN$1 = 'tokenizer';\nfunction createTokenizer(source, options = {}) {\n  const location = options.location !== false;\n  const _scnr = createScanner(source);\n  const currentOffset = () => _scnr.index();\n  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\n  const _initLoc = currentPosition();\n  const _initOffset = currentOffset();\n  const _context = {\n    currentType: 14 /* EOF */,\n    offset: _initOffset,\n    startLoc: _initLoc,\n    endLoc: _initLoc,\n    lastType: 14 /* EOF */,\n    lastOffset: _initOffset,\n    lastStartLoc: _initLoc,\n    lastEndLoc: _initLoc,\n    braceNest: 0,\n    inLinked: false,\n    text: ''\n  };\n  const context = () => _context;\n  const {\n    onError\n  } = options;\n  function emitError(code, pos, offset, ...args) {\n    const ctx = context();\n    pos.column += offset;\n    pos.offset += offset;\n    if (onError) {\n      const loc = createLocation(ctx.startLoc, pos);\n      const err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN$1,\n        args\n      });\n      onError(err);\n    }\n  }\n  function getToken(context, type, value) {\n    context.endLoc = currentPosition();\n    context.currentType = type;\n    const token = {\n      type\n    };\n    if (location) {\n      token.loc = createLocation(context.startLoc, context.endLoc);\n    }\n    if (value != null) {\n      token.value = value;\n    }\n    return token;\n  }\n  const getEndToken = context => getToken(context, 14 /* EOF */);\n  function eat(scnr, ch) {\n    if (scnr.currentChar() === ch) {\n      scnr.next();\n      return ch;\n    } else {\n      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n      return '';\n    }\n  }\n  function peekSpaces(scnr) {\n    let buf = '';\n    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\n      buf += scnr.currentPeek();\n      scnr.peek();\n    }\n    return buf;\n  }\n  function skipSpaces(scnr) {\n    const buf = peekSpaces(scnr);\n    scnr.skipToPeek();\n    return buf;\n  }\n  function isIdentifierStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n    const cc = ch.charCodeAt(0);\n    return cc >= 97 && cc <= 122 ||\n    // a-z\n    cc >= 65 && cc <= 90 ||\n    // A-Z\n    cc === 95 // _\n    ;\n  }\n\n  function isNumberStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n    const cc = ch.charCodeAt(0);\n    return cc >= 48 && cc <= 57; // 0-9\n  }\n\n  function isNamedIdentifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 2 /* BraceLeft */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n  function isListIdentifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 2 /* BraceLeft */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\n    const ret = isNumberStart(ch);\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLiteralStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 2 /* BraceLeft */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === LITERAL_DELIMITER;\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedDotStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 8 /* LinkedAlias */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \".\" /* LinkedDot */;\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedModifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 9 /* LinkedDot */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedDelimiterStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (!(currentType === 8 /* LinkedAlias */ || currentType === 12 /* LinkedModifier */)) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \":\" /* LinkedDelimiter */;\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedReferStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 10 /* LinkedDelimiter */) {\n      return false;\n    }\n    const fn = () => {\n      const ch = scnr.currentPeek();\n      if (ch === \"{\" /* BraceLeft */) {\n        return isIdentifierStart(scnr.peek());\n      } else if (ch === \"@\" /* LinkedAlias */ || ch === \"%\" /* Modulo */ || ch === \"|\" /* Pipe */ || ch === \":\" /* LinkedDelimiter */ || ch === \".\" /* LinkedDot */ || ch === CHAR_SP || !ch) {\n        return false;\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn();\n      } else {\n        // other characters\n        return isIdentifierStart(ch);\n      }\n    };\n    const ret = fn();\n    scnr.resetPeek();\n    return ret;\n  }\n  function isPluralStart(scnr) {\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \"|\" /* Pipe */;\n    scnr.resetPeek();\n    return ret;\n  }\n  function detectModuloStart(scnr) {\n    const spaces = peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \"%\" /* Modulo */ && scnr.peek() === \"{\" /* BraceLeft */;\n    scnr.resetPeek();\n    return {\n      isModulo: ret,\n      hasSpace: spaces.length > 0\n    };\n  }\n  function isTextStart(scnr, reset = true) {\n    const fn = (hasSpace = false, prev = '', detectModulo = false) => {\n      const ch = scnr.currentPeek();\n      if (ch === \"{\" /* BraceLeft */) {\n        return prev === \"%\" /* Modulo */ ? false : hasSpace;\n      } else if (ch === \"@\" /* LinkedAlias */ || !ch) {\n        return prev === \"%\" /* Modulo */ ? true : hasSpace;\n      } else if (ch === \"%\" /* Modulo */) {\n        scnr.peek();\n        return fn(hasSpace, \"%\" /* Modulo */, true);\n      } else if (ch === \"|\" /* Pipe */) {\n        return prev === \"%\" /* Modulo */ || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);\n      } else if (ch === CHAR_SP) {\n        scnr.peek();\n        return fn(true, CHAR_SP, detectModulo);\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn(true, CHAR_LF, detectModulo);\n      } else {\n        return true;\n      }\n    };\n    const ret = fn();\n    reset && scnr.resetPeek();\n    return ret;\n  }\n  function takeChar(scnr, fn) {\n    const ch = scnr.currentChar();\n    if (ch === EOF) {\n      return EOF;\n    }\n    if (fn(ch)) {\n      scnr.next();\n      return ch;\n    }\n    return null;\n  }\n  function takeIdentifierChar(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 97 && cc <= 122 ||\n      // a-z\n      cc >= 65 && cc <= 90 ||\n      // A-Z\n      cc >= 48 && cc <= 57 ||\n      // 0-9\n      cc === 95 ||\n      // _\n      cc === 36 // $\n      ;\n    };\n\n    return takeChar(scnr, closure);\n  }\n  function takeDigit(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 48 && cc <= 57; // 0-9\n    };\n\n    return takeChar(scnr, closure);\n  }\n  function takeHexDigit(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 48 && cc <= 57 ||\n      // 0-9\n      cc >= 65 && cc <= 70 ||\n      // A-F\n      cc >= 97 && cc <= 102; // a-f\n    };\n\n    return takeChar(scnr, closure);\n  }\n  function getDigits(scnr) {\n    let ch = '';\n    let num = '';\n    while (ch = takeDigit(scnr)) {\n      num += ch;\n    }\n    return num;\n  }\n  function readModulo(scnr) {\n    skipSpaces(scnr);\n    const ch = scnr.currentChar();\n    if (ch !== \"%\" /* Modulo */) {\n      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n    }\n    scnr.next();\n    return \"%\" /* Modulo */;\n  }\n\n  function readText(scnr) {\n    let buf = '';\n    while (true) {\n      const ch = scnr.currentChar();\n      if (ch === \"{\" /* BraceLeft */ || ch === \"}\" /* BraceRight */ || ch === \"@\" /* LinkedAlias */ || ch === \"|\" /* Pipe */ || !ch) {\n        break;\n      } else if (ch === \"%\" /* Modulo */) {\n        if (isTextStart(scnr)) {\n          buf += ch;\n          scnr.next();\n        } else {\n          break;\n        }\n      } else if (ch === CHAR_SP || ch === CHAR_LF) {\n        if (isTextStart(scnr)) {\n          buf += ch;\n          scnr.next();\n        } else if (isPluralStart(scnr)) {\n          break;\n        } else {\n          buf += ch;\n          scnr.next();\n        }\n      } else {\n        buf += ch;\n        scnr.next();\n      }\n    }\n    return buf;\n  }\n  function readNamedIdentifier(scnr) {\n    skipSpaces(scnr);\n    let ch = '';\n    let name = '';\n    while (ch = takeIdentifierChar(scnr)) {\n      name += ch;\n    }\n    if (scnr.currentChar() === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n    }\n    return name;\n  }\n  function readListIdentifier(scnr) {\n    skipSpaces(scnr);\n    let value = '';\n    if (scnr.currentChar() === '-') {\n      scnr.next();\n      value += `-${getDigits(scnr)}`;\n    } else {\n      value += getDigits(scnr);\n    }\n    if (scnr.currentChar() === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n    }\n    return value;\n  }\n  function readLiteral(scnr) {\n    skipSpaces(scnr);\n    eat(scnr, `\\'`);\n    let ch = '';\n    let literal = '';\n    const fn = x => x !== LITERAL_DELIMITER && x !== CHAR_LF;\n    while (ch = takeChar(scnr, fn)) {\n      if (ch === '\\\\') {\n        literal += readEscapeSequence(scnr);\n      } else {\n        literal += ch;\n      }\n    }\n    const current = scnr.currentChar();\n    if (current === CHAR_LF || current === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);\n      // TODO: Is it correct really?\n      if (current === CHAR_LF) {\n        scnr.next();\n        eat(scnr, `\\'`);\n      }\n      return literal;\n    }\n    eat(scnr, `\\'`);\n    return literal;\n  }\n  function readEscapeSequence(scnr) {\n    const ch = scnr.currentChar();\n    switch (ch) {\n      case '\\\\':\n      case `\\'`:\n        scnr.next();\n        return `\\\\${ch}`;\n      case 'u':\n        return readUnicodeEscapeSequence(scnr, ch, 4);\n      case 'U':\n        return readUnicodeEscapeSequence(scnr, ch, 6);\n      default:\n        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\n        return '';\n    }\n  }\n  function readUnicodeEscapeSequence(scnr, unicode, digits) {\n    eat(scnr, unicode);\n    let sequence = '';\n    for (let i = 0; i < digits; i++) {\n      const ch = takeHexDigit(scnr);\n      if (!ch) {\n        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\n        break;\n      }\n      sequence += ch;\n    }\n    return `\\\\${unicode}${sequence}`;\n  }\n  function readInvalidIdentifier(scnr) {\n    skipSpaces(scnr);\n    let ch = '';\n    let identifiers = '';\n    const closure = ch => ch !== \"{\" /* BraceLeft */ && ch !== \"}\" /* BraceRight */ && ch !== CHAR_SP && ch !== CHAR_LF;\n    while (ch = takeChar(scnr, closure)) {\n      identifiers += ch;\n    }\n    return identifiers;\n  }\n  function readLinkedModifier(scnr) {\n    let ch = '';\n    let name = '';\n    while (ch = takeIdentifierChar(scnr)) {\n      name += ch;\n    }\n    return name;\n  }\n  function readLinkedRefer(scnr) {\n    const fn = (detect = false, buf) => {\n      const ch = scnr.currentChar();\n      if (ch === \"{\" /* BraceLeft */ || ch === \"%\" /* Modulo */ || ch === \"@\" /* LinkedAlias */ || ch === \"|\" /* Pipe */ || !ch) {\n        return buf;\n      } else if (ch === CHAR_SP) {\n        return buf;\n      } else if (ch === CHAR_LF) {\n        buf += ch;\n        scnr.next();\n        return fn(detect, buf);\n      } else {\n        buf += ch;\n        scnr.next();\n        return fn(true, buf);\n      }\n    };\n    return fn(false, '');\n  }\n  function readPlural(scnr) {\n    skipSpaces(scnr);\n    const plural = eat(scnr, \"|\" /* Pipe */);\n    skipSpaces(scnr);\n    return plural;\n  }\n  // TODO: We need refactoring of token parsing ...\n  function readTokenInPlaceholder(scnr, context) {\n    let token = null;\n    const ch = scnr.currentChar();\n    switch (ch) {\n      case \"{\" /* BraceLeft */:\n        if (context.braceNest >= 1) {\n          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\n        }\n        scnr.next();\n        token = getToken(context, 2 /* BraceLeft */, \"{\" /* BraceLeft */);\n        skipSpaces(scnr);\n        context.braceNest++;\n        return token;\n      case \"}\" /* BraceRight */:\n        if (context.braceNest > 0 && context.currentType === 2 /* BraceLeft */) {\n          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\n        }\n        scnr.next();\n        token = getToken(context, 3 /* BraceRight */, \"}\" /* BraceRight */);\n        context.braceNest--;\n        context.braceNest > 0 && skipSpaces(scnr);\n        if (context.inLinked && context.braceNest === 0) {\n          context.inLinked = false;\n        }\n        return token;\n      case \"@\" /* LinkedAlias */:\n        if (context.braceNest > 0) {\n          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n        token = readTokenInLinked(scnr, context) || getEndToken(context);\n        context.braceNest = 0;\n        return token;\n      default:\n        let validNamedIdentifier = true;\n        let validListIdentifier = true;\n        let validLiteral = true;\n        if (isPluralStart(scnr)) {\n          if (context.braceNest > 0) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n          }\n          token = getToken(context, 1 /* Pipe */, readPlural(scnr));\n          // reset\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n        if (context.braceNest > 0 && (context.currentType === 5 /* Named */ || context.currentType === 6 /* List */ || context.currentType === 7 /* Literal */)) {\n          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n          context.braceNest = 0;\n          return readToken(scnr, context);\n        }\n        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context)) {\n          token = getToken(context, 5 /* Named */, readNamedIdentifier(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n        if (validListIdentifier = isListIdentifierStart(scnr, context)) {\n          token = getToken(context, 6 /* List */, readListIdentifier(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n        if (validLiteral = isLiteralStart(scnr, context)) {\n          token = getToken(context, 7 /* Literal */, readLiteral(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\n          // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\n          token = getToken(context, 13 /* InvalidPlace */, readInvalidIdentifier(scnr));\n          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\n          skipSpaces(scnr);\n          return token;\n        }\n        break;\n    }\n    return token;\n  }\n  // TODO: We need refactoring of token parsing ...\n  function readTokenInLinked(scnr, context) {\n    const {\n      currentType\n    } = context;\n    let token = null;\n    const ch = scnr.currentChar();\n    if ((currentType === 8 /* LinkedAlias */ || currentType === 9 /* LinkedDot */ || currentType === 12 /* LinkedModifier */ || currentType === 10 /* LinkedDelimiter */) && (ch === CHAR_LF || ch === CHAR_SP)) {\n      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n    }\n    switch (ch) {\n      case \"@\" /* LinkedAlias */:\n        scnr.next();\n        token = getToken(context, 8 /* LinkedAlias */, \"@\" /* LinkedAlias */);\n        context.inLinked = true;\n        return token;\n      case \".\" /* LinkedDot */:\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 9 /* LinkedDot */, \".\" /* LinkedDot */);\n      case \":\" /* LinkedDelimiter */:\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 10 /* LinkedDelimiter */, \":\" /* LinkedDelimiter */);\n      default:\n        if (isPluralStart(scnr)) {\n          token = getToken(context, 1 /* Pipe */, readPlural(scnr));\n          // reset\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n        if (isLinkedDotStart(scnr, context) || isLinkedDelimiterStart(scnr, context)) {\n          skipSpaces(scnr);\n          return readTokenInLinked(scnr, context);\n        }\n        if (isLinkedModifierStart(scnr, context)) {\n          skipSpaces(scnr);\n          return getToken(context, 12 /* LinkedModifier */, readLinkedModifier(scnr));\n        }\n        if (isLinkedReferStart(scnr, context)) {\n          skipSpaces(scnr);\n          if (ch === \"{\" /* BraceLeft */) {\n            // scan the placeholder\n            return readTokenInPlaceholder(scnr, context) || token;\n          } else {\n            return getToken(context, 11 /* LinkedKey */, readLinkedRefer(scnr));\n          }\n        }\n        if (currentType === 8 /* LinkedAlias */) {\n          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n        }\n        context.braceNest = 0;\n        context.inLinked = false;\n        return readToken(scnr, context);\n    }\n  }\n  // TODO: We need refactoring of token parsing ...\n  function readToken(scnr, context) {\n    let token = {\n      type: 14 /* EOF */\n    };\n    if (context.braceNest > 0) {\n      return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n    }\n    if (context.inLinked) {\n      return readTokenInLinked(scnr, context) || getEndToken(context);\n    }\n    const ch = scnr.currentChar();\n    switch (ch) {\n      case \"{\" /* BraceLeft */:\n        return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n      case \"}\" /* BraceRight */:\n        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\n        scnr.next();\n        return getToken(context, 3 /* BraceRight */, \"}\" /* BraceRight */);\n      case \"@\" /* LinkedAlias */:\n        return readTokenInLinked(scnr, context) || getEndToken(context);\n      default:\n        if (isPluralStart(scnr)) {\n          token = getToken(context, 1 /* Pipe */, readPlural(scnr));\n          // reset\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n        const {\n          isModulo,\n          hasSpace\n        } = detectModuloStart(scnr);\n        if (isModulo) {\n          return hasSpace ? getToken(context, 0 /* Text */, readText(scnr)) : getToken(context, 4 /* Modulo */, readModulo(scnr));\n        }\n        if (isTextStart(scnr)) {\n          return getToken(context, 0 /* Text */, readText(scnr));\n        }\n        break;\n    }\n    return token;\n  }\n  function nextToken() {\n    const {\n      currentType,\n      offset,\n      startLoc,\n      endLoc\n    } = _context;\n    _context.lastType = currentType;\n    _context.lastOffset = offset;\n    _context.lastStartLoc = startLoc;\n    _context.lastEndLoc = endLoc;\n    _context.offset = currentOffset();\n    _context.startLoc = currentPosition();\n    if (_scnr.currentChar() === EOF) {\n      return getToken(_context, 14 /* EOF */);\n    }\n\n    return readToken(_scnr, _context);\n  }\n  return {\n    nextToken,\n    currentOffset,\n    currentPosition,\n    context\n  };\n}\nconst ERROR_DOMAIN = 'parser';\n// Backslash backslash, backslash quote, uHHHH, UHHHHHH.\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\n  switch (match) {\n    case `\\\\\\\\`:\n      return `\\\\`;\n    case `\\\\\\'`:\n      return `\\'`;\n    default:\n      {\n        const codePoint = parseInt(codePoint4 || codePoint6, 16);\n        if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\n          return String.fromCodePoint(codePoint);\n        }\n        // invalid ...\n        // Replace them with U+FFFD REPLACEMENT CHARACTER.\n        return '�';\n      }\n  }\n}\nfunction createParser(options = {}) {\n  const location = options.location !== false;\n  const {\n    onError\n  } = options;\n  function emitError(tokenzer, code, start, offset, ...args) {\n    const end = tokenzer.currentPosition();\n    end.offset += offset;\n    end.column += offset;\n    if (onError) {\n      const loc = createLocation(start, end);\n      const err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN,\n        args\n      });\n      onError(err);\n    }\n  }\n  function startNode(type, offset, loc) {\n    const node = {\n      type,\n      start: offset,\n      end: offset\n    };\n    if (location) {\n      node.loc = {\n        start: loc,\n        end: loc\n      };\n    }\n    return node;\n  }\n  function endNode(node, offset, pos, type) {\n    node.end = offset;\n    if (type) {\n      node.type = type;\n    }\n    if (location && node.loc) {\n      node.loc.end = pos;\n    }\n  }\n  function parseText(tokenizer, value) {\n    const context = tokenizer.context();\n    const node = startNode(3 /* Text */, context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseList(tokenizer, index) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n    const node = startNode(5 /* List */, offset, loc);\n    node.index = parseInt(index, 10);\n    tokenizer.nextToken(); // skip brach right\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseNamed(tokenizer, key) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n    const node = startNode(4 /* Named */, offset, loc);\n    node.key = key;\n    tokenizer.nextToken(); // skip brach right\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseLiteral(tokenizer, value) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n    const node = startNode(9 /* Literal */, offset, loc);\n    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n    tokenizer.nextToken(); // skip brach right\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseLinkedModifier(tokenizer) {\n    const token = tokenizer.nextToken();\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get linked dot loc\n    const node = startNode(8 /* LinkedModifier */, offset, loc);\n    if (token.type !== 12 /* LinkedModifier */) {\n      // empty modifier\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\n      node.value = '';\n      endNode(node, offset, loc);\n      return {\n        nextConsumeToken: token,\n        node\n      };\n    }\n    // check token\n    if (token.value == null) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n    }\n    node.value = token.value || '';\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node\n    };\n  }\n  function parseLinkedKey(tokenizer, value) {\n    const context = tokenizer.context();\n    const node = startNode(7 /* LinkedKey */, context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseLinked(tokenizer) {\n    const context = tokenizer.context();\n    const linkedNode = startNode(6 /* Linked */, context.offset, context.startLoc);\n    let token = tokenizer.nextToken();\n    if (token.type === 9 /* LinkedDot */) {\n      const parsed = parseLinkedModifier(tokenizer);\n      linkedNode.modifier = parsed.node;\n      token = parsed.nextConsumeToken || tokenizer.nextToken();\n    }\n    // asset check token\n    if (token.type !== 10 /* LinkedDelimiter */) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n    }\n    token = tokenizer.nextToken();\n    // skip brace left\n    if (token.type === 2 /* BraceLeft */) {\n      token = tokenizer.nextToken();\n    }\n    switch (token.type) {\n      case 11 /* LinkedKey */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\n        break;\n      case 5 /* Named */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseNamed(tokenizer, token.value || '');\n        break;\n      case 6 /* List */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseList(tokenizer, token.value || '');\n        break;\n      case 7 /* Literal */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseLiteral(tokenizer, token.value || '');\n        break;\n      default:\n        // empty key\n        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\n        const nextContext = tokenizer.context();\n        const emptyLinkedKeyNode = startNode(7 /* LinkedKey */, nextContext.offset, nextContext.startLoc);\n        emptyLinkedKeyNode.value = '';\n        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\n        linkedNode.key = emptyLinkedKeyNode;\n        endNode(linkedNode, nextContext.offset, nextContext.startLoc);\n        return {\n          nextConsumeToken: token,\n          node: linkedNode\n        };\n    }\n    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node: linkedNode\n    };\n  }\n  function parseMessage(tokenizer) {\n    const context = tokenizer.context();\n    const startOffset = context.currentType === 1 /* Pipe */ ? tokenizer.currentOffset() : context.offset;\n    const startLoc = context.currentType === 1 /* Pipe */ ? context.endLoc : context.startLoc;\n    const node = startNode(2 /* Message */, startOffset, startLoc);\n    node.items = [];\n    let nextToken = null;\n    do {\n      const token = nextToken || tokenizer.nextToken();\n      nextToken = null;\n      switch (token.type) {\n        case 0 /* Text */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseText(tokenizer, token.value || ''));\n          break;\n        case 6 /* List */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseList(tokenizer, token.value || ''));\n          break;\n        case 5 /* Named */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseNamed(tokenizer, token.value || ''));\n          break;\n        case 7 /* Literal */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseLiteral(tokenizer, token.value || ''));\n          break;\n        case 8 /* LinkedAlias */:\n          const parsed = parseLinked(tokenizer);\n          node.items.push(parsed.node);\n          nextToken = parsed.nextConsumeToken || null;\n          break;\n      }\n    } while (context.currentType !== 14 /* EOF */ && context.currentType !== 1 /* Pipe */);\n    // adjust message node loc\n    const endOffset = context.currentType === 1 /* Pipe */ ? context.lastOffset : tokenizer.currentOffset();\n    const endLoc = context.currentType === 1 /* Pipe */ ? context.lastEndLoc : tokenizer.currentPosition();\n    endNode(node, endOffset, endLoc);\n    return node;\n  }\n  function parsePlural(tokenizer, offset, loc, msgNode) {\n    const context = tokenizer.context();\n    let hasEmptyMessage = msgNode.items.length === 0;\n    const node = startNode(1 /* Plural */, offset, loc);\n    node.cases = [];\n    node.cases.push(msgNode);\n    do {\n      const msg = parseMessage(tokenizer);\n      if (!hasEmptyMessage) {\n        hasEmptyMessage = msg.items.length === 0;\n      }\n      node.cases.push(msg);\n    } while (context.currentType !== 14 /* EOF */);\n    if (hasEmptyMessage) {\n      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\n    }\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseResource(tokenizer) {\n    const context = tokenizer.context();\n    const {\n      offset,\n      startLoc\n    } = context;\n    const msgNode = parseMessage(tokenizer);\n    if (context.currentType === 14 /* EOF */) {\n      return msgNode;\n    } else {\n      return parsePlural(tokenizer, offset, startLoc, msgNode);\n    }\n  }\n  function parse(source) {\n    const tokenizer = createTokenizer(source, shared.assign({}, options));\n    const context = tokenizer.context();\n    const node = startNode(0 /* Resource */, context.offset, context.startLoc);\n    if (location && node.loc) {\n      node.loc.source = source;\n    }\n    node.body = parseResource(tokenizer);\n    // assert whether achieved to EOF\n    if (context.currentType !== 14 /* EOF */) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\n    }\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  return {\n    parse\n  };\n}\nfunction getTokenCaption(token) {\n  if (token.type === 14 /* EOF */) {\n    return 'EOF';\n  }\n  const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\n  return name.length > 10 ? name.slice(0, 9) + '…' : name;\n}\nfunction createTransformer(ast, options = {} // eslint-disable-line\n) {\n  const _context = {\n    ast,\n    helpers: new Set()\n  };\n  const context = () => _context;\n  const helper = name => {\n    _context.helpers.add(name);\n    return name;\n  };\n  return {\n    context,\n    helper\n  };\n}\nfunction traverseNodes(nodes, transformer) {\n  for (let i = 0; i < nodes.length; i++) {\n    traverseNode(nodes[i], transformer);\n  }\n}\nfunction traverseNode(node, transformer) {\n  // TODO: if we need pre-hook of transform, should be implemented to here\n  switch (node.type) {\n    case 1 /* Plural */:\n      traverseNodes(node.cases, transformer);\n      transformer.helper(\"plural\" /* PLURAL */);\n      break;\n    case 2 /* Message */:\n      traverseNodes(node.items, transformer);\n      break;\n    case 6 /* Linked */:\n      const linked = node;\n      traverseNode(linked.key, transformer);\n      transformer.helper(\"linked\" /* LINKED */);\n      transformer.helper(\"type\" /* TYPE */);\n      break;\n    case 5 /* List */:\n      transformer.helper(\"interpolate\" /* INTERPOLATE */);\n      transformer.helper(\"list\" /* LIST */);\n      break;\n    case 4 /* Named */:\n      transformer.helper(\"interpolate\" /* INTERPOLATE */);\n      transformer.helper(\"named\" /* NAMED */);\n      break;\n  }\n  // TODO: if we need post-hook of transform, should be implemented to here\n}\n// transform AST\nfunction transform(ast, options = {} // eslint-disable-line\n) {\n  const transformer = createTransformer(ast);\n  transformer.helper(\"normalize\" /* NORMALIZE */);\n  // traverse\n  ast.body && traverseNode(ast.body, transformer);\n  // set meta information\n  const context = transformer.context();\n  ast.helpers = Array.from(context.helpers);\n}\nfunction createCodeGenerator(ast, options) {\n  const {\n    sourceMap: sourceMap$1,\n    filename,\n    breakLineCode,\n    needIndent: _needIndent\n  } = options;\n  const _context = {\n    source: ast.loc.source,\n    filename,\n    code: '',\n    column: 1,\n    line: 1,\n    offset: 0,\n    map: undefined,\n    breakLineCode,\n    needIndent: _needIndent,\n    indentLevel: 0\n  };\n  const context = () => _context;\n  function push(code, node) {\n    _context.code += code;\n    if (_context.map) {\n      if (node && node.loc && node.loc !== LocationStub) {\n        addMapping(node.loc.start, getMappingName(node));\n      }\n      advancePositionWithSource(_context, code);\n    }\n  }\n  function _newline(n, withBreakLine = true) {\n    const _breakLineCode = withBreakLine ? breakLineCode : '';\n    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\n  }\n  function indent(withNewLine = true) {\n    const level = ++_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n  function deindent(withNewLine = true) {\n    const level = --_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n  function newline() {\n    _newline(_context.indentLevel);\n  }\n  const helper = key => `_${key}`;\n  const needIndent = () => _context.needIndent;\n  function addMapping(loc, name) {\n    _context.map.addMapping({\n      name,\n      source: _context.filename,\n      original: {\n        line: loc.line,\n        column: loc.column - 1\n      },\n      generated: {\n        line: _context.line,\n        column: _context.column - 1\n      }\n    });\n  }\n  if (sourceMap$1) {\n    _context.map = new sourceMap.SourceMapGenerator();\n    _context.map.setSourceContent(filename, _context.source);\n  }\n  return {\n    context,\n    push,\n    indent,\n    deindent,\n    newline,\n    helper,\n    needIndent\n  };\n}\nfunction generateLinkedNode(generator, node) {\n  const {\n    helper\n  } = generator;\n  generator.push(`${helper(\"linked\" /* LINKED */)}(`);\n  generateNode(generator, node.key);\n  if (node.modifier) {\n    generator.push(`, `);\n    generateNode(generator, node.modifier);\n    generator.push(`, _type`);\n  } else {\n    generator.push(`, undefined, _type`);\n  }\n  generator.push(`)`);\n}\nfunction generateMessageNode(generator, node) {\n  const {\n    helper,\n    needIndent\n  } = generator;\n  generator.push(`${helper(\"normalize\" /* NORMALIZE */)}([`);\n  generator.indent(needIndent());\n  const length = node.items.length;\n  for (let i = 0; i < length; i++) {\n    generateNode(generator, node.items[i]);\n    if (i === length - 1) {\n      break;\n    }\n    generator.push(', ');\n  }\n  generator.deindent(needIndent());\n  generator.push('])');\n}\nfunction generatePluralNode(generator, node) {\n  const {\n    helper,\n    needIndent\n  } = generator;\n  if (node.cases.length > 1) {\n    generator.push(`${helper(\"plural\" /* PLURAL */)}([`);\n    generator.indent(needIndent());\n    const length = node.cases.length;\n    for (let i = 0; i < length; i++) {\n      generateNode(generator, node.cases[i]);\n      if (i === length - 1) {\n        break;\n      }\n      generator.push(', ');\n    }\n    generator.deindent(needIndent());\n    generator.push(`])`);\n  }\n}\nfunction generateResource(generator, node) {\n  if (node.body) {\n    generateNode(generator, node.body);\n  } else {\n    generator.push('null');\n  }\n}\nfunction generateNode(generator, node) {\n  const {\n    helper\n  } = generator;\n  switch (node.type) {\n    case 0 /* Resource */:\n      generateResource(generator, node);\n      break;\n    case 1 /* Plural */:\n      generatePluralNode(generator, node);\n      break;\n    case 2 /* Message */:\n      generateMessageNode(generator, node);\n      break;\n    case 6 /* Linked */:\n      generateLinkedNode(generator, node);\n      break;\n    case 8 /* LinkedModifier */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    case 7 /* LinkedKey */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    case 5 /* List */:\n      generator.push(`${helper(\"interpolate\" /* INTERPOLATE */)}(${helper(\"list\" /* LIST */)}(${node.index}))`, node);\n      break;\n    case 4 /* Named */:\n      generator.push(`${helper(\"interpolate\" /* INTERPOLATE */)}(${helper(\"named\" /* NAMED */)}(${JSON.stringify(node.key)}))`, node);\n      break;\n    case 9 /* Literal */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    case 3 /* Text */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    default:\n      {\n        throw new Error(`unhandled codegen node type: ${node.type}`);\n      }\n  }\n}\n// generate code from AST\nconst generate = (ast, options = {} // eslint-disable-line\n) => {\n  const mode = shared.isString(options.mode) ? options.mode : 'normal';\n  const filename = shared.isString(options.filename) ? options.filename : 'message.intl';\n  const sourceMap = !!options.sourceMap;\n  // prettier-ignore\n  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === 'arrow' ? ';' : '\\n';\n  const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\n  const helpers = ast.helpers || [];\n  const generator = createCodeGenerator(ast, {\n    mode,\n    filename,\n    sourceMap,\n    breakLineCode,\n    needIndent\n  });\n  generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\n  generator.indent(needIndent);\n  if (helpers.length > 0) {\n    generator.push(`const { ${helpers.map(s => `${s}: _${s}`).join(', ')} } = ctx`);\n    generator.newline();\n  }\n  generator.push(`return `);\n  generateNode(generator, ast);\n  generator.deindent(needIndent);\n  generator.push(`}`);\n  const {\n    code,\n    map\n  } = generator.context();\n  return {\n    ast,\n    code,\n    map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\n  };\n};\n\nfunction getMappingName(node) {\n  switch (node.type) {\n    case 3 /* Text */:\n    case 9 /* Literal */:\n    case 8 /* LinkedModifier */:\n    case 7 /* LinkedKey */:\n      return node.value;\n    case 5 /* List */:\n      return node.index.toString();\n    case 4 /* Named */:\n      return node.key;\n    default:\n      return undefined;\n  }\n}\nfunction advancePositionWithSource(pos, source, numberOfCharacters = source.length) {\n  let linesCount = 0;\n  let lastNewLinePos = -1;\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10 /* newline char code */) {\n      linesCount++;\n      lastNewLinePos = i;\n    }\n  }\n  pos.offset += numberOfCharacters;\n  pos.line += linesCount;\n  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;\n  return pos;\n}\nfunction baseCompile(source, options = {}) {\n  const assignedOptions = shared.assign({}, options);\n  // parse source codes\n  const parser = createParser(assignedOptions);\n  const ast = parser.parse(source);\n  // transform ASTs\n  transform(ast, assignedOptions);\n  // generate javascript codes\n  return generate(ast, assignedOptions);\n}\nexports.CompileErrorCodes = CompileErrorCodes;\nexports.ERROR_DOMAIN = ERROR_DOMAIN;\nexports.LocationStub = LocationStub;\nexports.baseCompile = baseCompile;\nexports.createCompileError = createCompileError;\nexports.createLocation = createLocation;\nexports.createParser = createParser;\nexports.createPosition = createPosition;\nexports.defaultOnError = defaultOnError;\nexports.errorMessages = errorMessages;","map":{"version":3,"names":["Object","defineProperty","exports","value","shared","require","sourceMap","CompileErrorCodes","EXPECTED_TOKEN","INVALID_TOKEN_IN_PLACEHOLDER","UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER","UNKNOWN_ESCAPE_SEQUENCE","INVALID_UNICODE_ESCAPE_SEQUENCE","UNBALANCED_CLOSING_BRACE","UNTERMINATED_CLOSING_BRACE","EMPTY_PLACEHOLDER","NOT_ALLOW_NEST_PLACEHOLDER","INVALID_LINKED_FORMAT","MUST_HAVE_MESSAGES_IN_PLURAL","UNEXPECTED_EMPTY_LINKED_MODIFIER","UNEXPECTED_EMPTY_LINKED_KEY","UNEXPECTED_LEXICAL_ANALYSIS","__EXTEND_POINT__","errorMessages","createCompileError","code","loc","options","domain","messages","args","msg","format","error","SyntaxError","String","location","defaultOnError","LocationStub","start","line","column","offset","end","createPosition","createLocation","source","CHAR_SP","CHAR_CR","CHAR_LF","CHAR_LS","fromCharCode","CHAR_PS","createScanner","str","_buf","_index","_line","_column","_peekOffset","isCRLF","index","isLF","isPS","isLS","isLineEnd","peekOffset","charAt","currentChar","currentPeek","next","peek","reset","resetPeek","skipToPeek","target","EOF","undefined","LITERAL_DELIMITER","ERROR_DOMAIN$1","createTokenizer","_scnr","currentOffset","currentPosition","_initLoc","_initOffset","_context","currentType","startLoc","endLoc","lastType","lastOffset","lastStartLoc","lastEndLoc","braceNest","inLinked","text","context","onError","emitError","pos","ctx","err","getToken","type","token","getEndToken","eat","scnr","ch","peekSpaces","buf","skipSpaces","isIdentifierStart","cc","charCodeAt","isNumberStart","isNamedIdentifierStart","ret","isListIdentifierStart","isLiteralStart","isLinkedDotStart","isLinkedModifierStart","isLinkedDelimiterStart","isLinkedReferStart","fn","isPluralStart","detectModuloStart","spaces","isModulo","hasSpace","length","isTextStart","prev","detectModulo","takeChar","takeIdentifierChar","closure","takeDigit","takeHexDigit","getDigits","num","readModulo","readText","readNamedIdentifier","name","readListIdentifier","readLiteral","literal","x","readEscapeSequence","current","readUnicodeEscapeSequence","unicode","digits","sequence","i","readInvalidIdentifier","identifiers","readLinkedModifier","readLinkedRefer","detect","readPlural","plural","readTokenInPlaceholder","readTokenInLinked","validNamedIdentifier","validListIdentifier","validLiteral","readToken","nextToken","ERROR_DOMAIN","KNOWN_ESCAPES","fromEscapeSequence","match","codePoint4","codePoint6","codePoint","parseInt","fromCodePoint","createParser","tokenzer","startNode","node","endNode","parseText","tokenizer","parseList","parseNamed","key","parseLiteral","replace","parseLinkedModifier","nextConsumeToken","getTokenCaption","parseLinkedKey","parseLinked","linkedNode","parsed","modifier","nextContext","emptyLinkedKeyNode","parseMessage","startOffset","items","push","endOffset","parsePlural","msgNode","hasEmptyMessage","cases","parseResource","parse","assign","body","slice","createTransformer","ast","helpers","Set","helper","add","traverseNodes","nodes","transformer","traverseNode","linked","transform","Array","from","createCodeGenerator","sourceMap$1","filename","breakLineCode","needIndent","_needIndent","map","indentLevel","addMapping","getMappingName","advancePositionWithSource","_newline","n","withBreakLine","_breakLineCode","repeat","indent","withNewLine","level","deindent","newline","original","generated","SourceMapGenerator","setSourceContent","generateLinkedNode","generator","generateNode","generateMessageNode","generatePluralNode","generateResource","JSON","stringify","Error","generate","mode","isString","s","join","toJSON","toString","numberOfCharacters","linesCount","lastNewLinePos","baseCompile","assignedOptions","parser"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/@intlify/message-compiler/dist/message-compiler.cjs.js"],"sourcesContent":["/*!\n  * message-compiler v9.2.2\n  * (c) 2022 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar shared = require('@intlify/shared');\nvar sourceMap = require('source-map');\n\nconst CompileErrorCodes = {\r\n    // tokenizer error codes\r\n    EXPECTED_TOKEN: 1,\r\n    INVALID_TOKEN_IN_PLACEHOLDER: 2,\r\n    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\r\n    UNKNOWN_ESCAPE_SEQUENCE: 4,\r\n    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\r\n    UNBALANCED_CLOSING_BRACE: 6,\r\n    UNTERMINATED_CLOSING_BRACE: 7,\r\n    EMPTY_PLACEHOLDER: 8,\r\n    NOT_ALLOW_NEST_PLACEHOLDER: 9,\r\n    INVALID_LINKED_FORMAT: 10,\r\n    // parser error codes\r\n    MUST_HAVE_MESSAGES_IN_PLURAL: 11,\r\n    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\r\n    UNEXPECTED_EMPTY_LINKED_KEY: 13,\r\n    UNEXPECTED_LEXICAL_ANALYSIS: 14,\r\n    // Special value for higher-order compilers to pick up the last code\r\n    // to avoid collision of error codes. This should always be kept as the last\r\n    // item.\r\n    __EXTEND_POINT__: 15\r\n};\r\n/** @internal */\r\nconst errorMessages = {\r\n    // tokenizer error messages\r\n    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,\r\n    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,\r\n    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,\r\n    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\\\{0}`,\r\n    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,\r\n    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,\r\n    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,\r\n    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,\r\n    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,\r\n    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,\r\n    // parser error messages\r\n    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,\r\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,\r\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,\r\n    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`\r\n};\r\nfunction createCompileError(code, loc, options = {}) {\r\n    const { domain, messages, args } = options;\r\n    const msg = shared.format((messages || errorMessages)[code] || '', ...(args || []))\r\n        ;\r\n    const error = new SyntaxError(String(msg));\r\n    error.code = code;\r\n    if (loc) {\r\n        error.location = loc;\r\n    }\r\n    error.domain = domain;\r\n    return error;\r\n}\r\n/** @internal */\r\nfunction defaultOnError(error) {\r\n    throw error;\r\n}\n\nconst LocationStub = {\r\n    start: { line: 1, column: 1, offset: 0 },\r\n    end: { line: 1, column: 1, offset: 0 }\r\n};\r\nfunction createPosition(line, column, offset) {\r\n    return { line, column, offset };\r\n}\r\nfunction createLocation(start, end, source) {\r\n    const loc = { start, end };\r\n    if (source != null) {\r\n        loc.source = source;\r\n    }\r\n    return loc;\r\n}\n\nconst CHAR_SP = ' ';\r\nconst CHAR_CR = '\\r';\r\nconst CHAR_LF = '\\n';\r\nconst CHAR_LS = String.fromCharCode(0x2028);\r\nconst CHAR_PS = String.fromCharCode(0x2029);\r\nfunction createScanner(str) {\r\n    const _buf = str;\r\n    let _index = 0;\r\n    let _line = 1;\r\n    let _column = 1;\r\n    let _peekOffset = 0;\r\n    const isCRLF = (index) => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\r\n    const isLF = (index) => _buf[index] === CHAR_LF;\r\n    const isPS = (index) => _buf[index] === CHAR_PS;\r\n    const isLS = (index) => _buf[index] === CHAR_LS;\r\n    const isLineEnd = (index) => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\r\n    const index = () => _index;\r\n    const line = () => _line;\r\n    const column = () => _column;\r\n    const peekOffset = () => _peekOffset;\r\n    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\r\n    const currentChar = () => charAt(_index);\r\n    const currentPeek = () => charAt(_index + _peekOffset);\r\n    function next() {\r\n        _peekOffset = 0;\r\n        if (isLineEnd(_index)) {\r\n            _line++;\r\n            _column = 0;\r\n        }\r\n        if (isCRLF(_index)) {\r\n            _index++;\r\n        }\r\n        _index++;\r\n        _column++;\r\n        return _buf[_index];\r\n    }\r\n    function peek() {\r\n        if (isCRLF(_index + _peekOffset)) {\r\n            _peekOffset++;\r\n        }\r\n        _peekOffset++;\r\n        return _buf[_index + _peekOffset];\r\n    }\r\n    function reset() {\r\n        _index = 0;\r\n        _line = 1;\r\n        _column = 1;\r\n        _peekOffset = 0;\r\n    }\r\n    function resetPeek(offset = 0) {\r\n        _peekOffset = offset;\r\n    }\r\n    function skipToPeek() {\r\n        const target = _index + _peekOffset;\r\n        // eslint-disable-next-line no-unmodified-loop-condition\r\n        while (target !== _index) {\r\n            next();\r\n        }\r\n        _peekOffset = 0;\r\n    }\r\n    return {\r\n        index,\r\n        line,\r\n        column,\r\n        peekOffset,\r\n        charAt,\r\n        currentChar,\r\n        currentPeek,\r\n        next,\r\n        peek,\r\n        reset,\r\n        resetPeek,\r\n        skipToPeek\r\n    };\r\n}\n\nconst EOF = undefined;\r\nconst LITERAL_DELIMITER = \"'\";\r\nconst ERROR_DOMAIN$1 = 'tokenizer';\r\nfunction createTokenizer(source, options = {}) {\r\n    const location = options.location !== false;\r\n    const _scnr = createScanner(source);\r\n    const currentOffset = () => _scnr.index();\r\n    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\r\n    const _initLoc = currentPosition();\r\n    const _initOffset = currentOffset();\r\n    const _context = {\r\n        currentType: 14 /* EOF */,\r\n        offset: _initOffset,\r\n        startLoc: _initLoc,\r\n        endLoc: _initLoc,\r\n        lastType: 14 /* EOF */,\r\n        lastOffset: _initOffset,\r\n        lastStartLoc: _initLoc,\r\n        lastEndLoc: _initLoc,\r\n        braceNest: 0,\r\n        inLinked: false,\r\n        text: ''\r\n    };\r\n    const context = () => _context;\r\n    const { onError } = options;\r\n    function emitError(code, pos, offset, ...args) {\r\n        const ctx = context();\r\n        pos.column += offset;\r\n        pos.offset += offset;\r\n        if (onError) {\r\n            const loc = createLocation(ctx.startLoc, pos);\r\n            const err = createCompileError(code, loc, {\r\n                domain: ERROR_DOMAIN$1,\r\n                args\r\n            });\r\n            onError(err);\r\n        }\r\n    }\r\n    function getToken(context, type, value) {\r\n        context.endLoc = currentPosition();\r\n        context.currentType = type;\r\n        const token = { type };\r\n        if (location) {\r\n            token.loc = createLocation(context.startLoc, context.endLoc);\r\n        }\r\n        if (value != null) {\r\n            token.value = value;\r\n        }\r\n        return token;\r\n    }\r\n    const getEndToken = (context) => getToken(context, 14 /* EOF */);\r\n    function eat(scnr, ch) {\r\n        if (scnr.currentChar() === ch) {\r\n            scnr.next();\r\n            return ch;\r\n        }\r\n        else {\r\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\r\n            return '';\r\n        }\r\n    }\r\n    function peekSpaces(scnr) {\r\n        let buf = '';\r\n        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\r\n            buf += scnr.currentPeek();\r\n            scnr.peek();\r\n        }\r\n        return buf;\r\n    }\r\n    function skipSpaces(scnr) {\r\n        const buf = peekSpaces(scnr);\r\n        scnr.skipToPeek();\r\n        return buf;\r\n    }\r\n    function isIdentifierStart(ch) {\r\n        if (ch === EOF) {\r\n            return false;\r\n        }\r\n        const cc = ch.charCodeAt(0);\r\n        return ((cc >= 97 && cc <= 122) || // a-z\r\n            (cc >= 65 && cc <= 90) || // A-Z\r\n            cc === 95 // _\r\n        );\r\n    }\r\n    function isNumberStart(ch) {\r\n        if (ch === EOF) {\r\n            return false;\r\n        }\r\n        const cc = ch.charCodeAt(0);\r\n        return cc >= 48 && cc <= 57; // 0-9\r\n    }\r\n    function isNamedIdentifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = isIdentifierStart(scnr.currentPeek());\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isListIdentifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\r\n        const ret = isNumberStart(ch);\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLiteralStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === LITERAL_DELIMITER;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedDotStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 8 /* LinkedAlias */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === \".\" /* LinkedDot */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedModifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 9 /* LinkedDot */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = isIdentifierStart(scnr.currentPeek());\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedDelimiterStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (!(currentType === 8 /* LinkedAlias */ ||\r\n            currentType === 12 /* LinkedModifier */)) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === \":\" /* LinkedDelimiter */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedReferStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 10 /* LinkedDelimiter */) {\r\n            return false;\r\n        }\r\n        const fn = () => {\r\n            const ch = scnr.currentPeek();\r\n            if (ch === \"{\" /* BraceLeft */) {\r\n                return isIdentifierStart(scnr.peek());\r\n            }\r\n            else if (ch === \"@\" /* LinkedAlias */ ||\r\n                ch === \"%\" /* Modulo */ ||\r\n                ch === \"|\" /* Pipe */ ||\r\n                ch === \":\" /* LinkedDelimiter */ ||\r\n                ch === \".\" /* LinkedDot */ ||\r\n                ch === CHAR_SP ||\r\n                !ch) {\r\n                return false;\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                scnr.peek();\r\n                return fn();\r\n            }\r\n            else {\r\n                // other characters\r\n                return isIdentifierStart(ch);\r\n            }\r\n        };\r\n        const ret = fn();\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isPluralStart(scnr) {\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === \"|\" /* Pipe */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function detectModuloStart(scnr) {\r\n        const spaces = peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === \"%\" /* Modulo */ &&\r\n            scnr.peek() === \"{\" /* BraceLeft */;\r\n        scnr.resetPeek();\r\n        return {\r\n            isModulo: ret,\r\n            hasSpace: spaces.length > 0\r\n        };\r\n    }\r\n    function isTextStart(scnr, reset = true) {\r\n        const fn = (hasSpace = false, prev = '', detectModulo = false) => {\r\n            const ch = scnr.currentPeek();\r\n            if (ch === \"{\" /* BraceLeft */) {\r\n                return prev === \"%\" /* Modulo */ ? false : hasSpace;\r\n            }\r\n            else if (ch === \"@\" /* LinkedAlias */ || !ch) {\r\n                return prev === \"%\" /* Modulo */ ? true : hasSpace;\r\n            }\r\n            else if (ch === \"%\" /* Modulo */) {\r\n                scnr.peek();\r\n                return fn(hasSpace, \"%\" /* Modulo */, true);\r\n            }\r\n            else if (ch === \"|\" /* Pipe */) {\r\n                return prev === \"%\" /* Modulo */ || detectModulo\r\n                    ? true\r\n                    : !(prev === CHAR_SP || prev === CHAR_LF);\r\n            }\r\n            else if (ch === CHAR_SP) {\r\n                scnr.peek();\r\n                return fn(true, CHAR_SP, detectModulo);\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                scnr.peek();\r\n                return fn(true, CHAR_LF, detectModulo);\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        };\r\n        const ret = fn();\r\n        reset && scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function takeChar(scnr, fn) {\r\n        const ch = scnr.currentChar();\r\n        if (ch === EOF) {\r\n            return EOF;\r\n        }\r\n        if (fn(ch)) {\r\n            scnr.next();\r\n            return ch;\r\n        }\r\n        return null;\r\n    }\r\n    function takeIdentifierChar(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return ((cc >= 97 && cc <= 122) || // a-z\r\n                (cc >= 65 && cc <= 90) || // A-Z\r\n                (cc >= 48 && cc <= 57) || // 0-9\r\n                cc === 95 || // _\r\n                cc === 36 // $\r\n            );\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function takeDigit(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return cc >= 48 && cc <= 57; // 0-9\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function takeHexDigit(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return ((cc >= 48 && cc <= 57) || // 0-9\r\n                (cc >= 65 && cc <= 70) || // A-F\r\n                (cc >= 97 && cc <= 102)); // a-f\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function getDigits(scnr) {\r\n        let ch = '';\r\n        let num = '';\r\n        while ((ch = takeDigit(scnr))) {\r\n            num += ch;\r\n        }\r\n        return num;\r\n    }\r\n    function readModulo(scnr) {\r\n        skipSpaces(scnr);\r\n        const ch = scnr.currentChar();\r\n        if (ch !== \"%\" /* Modulo */) {\r\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\r\n        }\r\n        scnr.next();\r\n        return \"%\" /* Modulo */;\r\n    }\r\n    function readText(scnr) {\r\n        let buf = '';\r\n        while (true) {\r\n            const ch = scnr.currentChar();\r\n            if (ch === \"{\" /* BraceLeft */ ||\r\n                ch === \"}\" /* BraceRight */ ||\r\n                ch === \"@\" /* LinkedAlias */ ||\r\n                ch === \"|\" /* Pipe */ ||\r\n                !ch) {\r\n                break;\r\n            }\r\n            else if (ch === \"%\" /* Modulo */) {\r\n                if (isTextStart(scnr)) {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            else if (ch === CHAR_SP || ch === CHAR_LF) {\r\n                if (isTextStart(scnr)) {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                }\r\n                else if (isPluralStart(scnr)) {\r\n                    break;\r\n                }\r\n                else {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                }\r\n            }\r\n            else {\r\n                buf += ch;\r\n                scnr.next();\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n    function readNamedIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let ch = '';\r\n        let name = '';\r\n        while ((ch = takeIdentifierChar(scnr))) {\r\n            name += ch;\r\n        }\r\n        if (scnr.currentChar() === EOF) {\r\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n        }\r\n        return name;\r\n    }\r\n    function readListIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let value = '';\r\n        if (scnr.currentChar() === '-') {\r\n            scnr.next();\r\n            value += `-${getDigits(scnr)}`;\r\n        }\r\n        else {\r\n            value += getDigits(scnr);\r\n        }\r\n        if (scnr.currentChar() === EOF) {\r\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n        }\r\n        return value;\r\n    }\r\n    function readLiteral(scnr) {\r\n        skipSpaces(scnr);\r\n        eat(scnr, `\\'`);\r\n        let ch = '';\r\n        let literal = '';\r\n        const fn = (x) => x !== LITERAL_DELIMITER && x !== CHAR_LF;\r\n        while ((ch = takeChar(scnr, fn))) {\r\n            if (ch === '\\\\') {\r\n                literal += readEscapeSequence(scnr);\r\n            }\r\n            else {\r\n                literal += ch;\r\n            }\r\n        }\r\n        const current = scnr.currentChar();\r\n        if (current === CHAR_LF || current === EOF) {\r\n            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);\r\n            // TODO: Is it correct really?\r\n            if (current === CHAR_LF) {\r\n                scnr.next();\r\n                eat(scnr, `\\'`);\r\n            }\r\n            return literal;\r\n        }\r\n        eat(scnr, `\\'`);\r\n        return literal;\r\n    }\r\n    function readEscapeSequence(scnr) {\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case '\\\\':\r\n            case `\\'`:\r\n                scnr.next();\r\n                return `\\\\${ch}`;\r\n            case 'u':\r\n                return readUnicodeEscapeSequence(scnr, ch, 4);\r\n            case 'U':\r\n                return readUnicodeEscapeSequence(scnr, ch, 6);\r\n            default:\r\n                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\r\n                return '';\r\n        }\r\n    }\r\n    function readUnicodeEscapeSequence(scnr, unicode, digits) {\r\n        eat(scnr, unicode);\r\n        let sequence = '';\r\n        for (let i = 0; i < digits; i++) {\r\n            const ch = takeHexDigit(scnr);\r\n            if (!ch) {\r\n                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\r\n                break;\r\n            }\r\n            sequence += ch;\r\n        }\r\n        return `\\\\${unicode}${sequence}`;\r\n    }\r\n    function readInvalidIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let ch = '';\r\n        let identifiers = '';\r\n        const closure = (ch) => ch !== \"{\" /* BraceLeft */ &&\r\n            ch !== \"}\" /* BraceRight */ &&\r\n            ch !== CHAR_SP &&\r\n            ch !== CHAR_LF;\r\n        while ((ch = takeChar(scnr, closure))) {\r\n            identifiers += ch;\r\n        }\r\n        return identifiers;\r\n    }\r\n    function readLinkedModifier(scnr) {\r\n        let ch = '';\r\n        let name = '';\r\n        while ((ch = takeIdentifierChar(scnr))) {\r\n            name += ch;\r\n        }\r\n        return name;\r\n    }\r\n    function readLinkedRefer(scnr) {\r\n        const fn = (detect = false, buf) => {\r\n            const ch = scnr.currentChar();\r\n            if (ch === \"{\" /* BraceLeft */ ||\r\n                ch === \"%\" /* Modulo */ ||\r\n                ch === \"@\" /* LinkedAlias */ ||\r\n                ch === \"|\" /* Pipe */ ||\r\n                !ch) {\r\n                return buf;\r\n            }\r\n            else if (ch === CHAR_SP) {\r\n                return buf;\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                buf += ch;\r\n                scnr.next();\r\n                return fn(detect, buf);\r\n            }\r\n            else {\r\n                buf += ch;\r\n                scnr.next();\r\n                return fn(true, buf);\r\n            }\r\n        };\r\n        return fn(false, '');\r\n    }\r\n    function readPlural(scnr) {\r\n        skipSpaces(scnr);\r\n        const plural = eat(scnr, \"|\" /* Pipe */);\r\n        skipSpaces(scnr);\r\n        return plural;\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readTokenInPlaceholder(scnr, context) {\r\n        let token = null;\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case \"{\" /* BraceLeft */:\r\n                if (context.braceNest >= 1) {\r\n                    emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\r\n                }\r\n                scnr.next();\r\n                token = getToken(context, 2 /* BraceLeft */, \"{\" /* BraceLeft */);\r\n                skipSpaces(scnr);\r\n                context.braceNest++;\r\n                return token;\r\n            case \"}\" /* BraceRight */:\r\n                if (context.braceNest > 0 &&\r\n                    context.currentType === 2 /* BraceLeft */) {\r\n                    emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\r\n                }\r\n                scnr.next();\r\n                token = getToken(context, 3 /* BraceRight */, \"}\" /* BraceRight */);\r\n                context.braceNest--;\r\n                context.braceNest > 0 && skipSpaces(scnr);\r\n                if (context.inLinked && context.braceNest === 0) {\r\n                    context.inLinked = false;\r\n                }\r\n                return token;\r\n            case \"@\" /* LinkedAlias */:\r\n                if (context.braceNest > 0) {\r\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n                }\r\n                token = readTokenInLinked(scnr, context) || getEndToken(context);\r\n                context.braceNest = 0;\r\n                return token;\r\n            default:\r\n                let validNamedIdentifier = true;\r\n                let validListIdentifier = true;\r\n                let validLiteral = true;\r\n                if (isPluralStart(scnr)) {\r\n                    if (context.braceNest > 0) {\r\n                        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n                    }\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                if (context.braceNest > 0 &&\r\n                    (context.currentType === 5 /* Named */ ||\r\n                        context.currentType === 6 /* List */ ||\r\n                        context.currentType === 7 /* Literal */)) {\r\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n                    context.braceNest = 0;\r\n                    return readToken(scnr, context);\r\n                }\r\n                if ((validNamedIdentifier = isNamedIdentifierStart(scnr, context))) {\r\n                    token = getToken(context, 5 /* Named */, readNamedIdentifier(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if ((validListIdentifier = isListIdentifierStart(scnr, context))) {\r\n                    token = getToken(context, 6 /* List */, readListIdentifier(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if ((validLiteral = isLiteralStart(scnr, context))) {\r\n                    token = getToken(context, 7 /* Literal */, readLiteral(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\r\n                    // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\r\n                    token = getToken(context, 13 /* InvalidPlace */, readInvalidIdentifier(scnr));\r\n                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                break;\r\n        }\r\n        return token;\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readTokenInLinked(scnr, context) {\r\n        const { currentType } = context;\r\n        let token = null;\r\n        const ch = scnr.currentChar();\r\n        if ((currentType === 8 /* LinkedAlias */ ||\r\n            currentType === 9 /* LinkedDot */ ||\r\n            currentType === 12 /* LinkedModifier */ ||\r\n            currentType === 10 /* LinkedDelimiter */) &&\r\n            (ch === CHAR_LF || ch === CHAR_SP)) {\r\n            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\r\n        }\r\n        switch (ch) {\r\n            case \"@\" /* LinkedAlias */:\r\n                scnr.next();\r\n                token = getToken(context, 8 /* LinkedAlias */, \"@\" /* LinkedAlias */);\r\n                context.inLinked = true;\r\n                return token;\r\n            case \".\" /* LinkedDot */:\r\n                skipSpaces(scnr);\r\n                scnr.next();\r\n                return getToken(context, 9 /* LinkedDot */, \".\" /* LinkedDot */);\r\n            case \":\" /* LinkedDelimiter */:\r\n                skipSpaces(scnr);\r\n                scnr.next();\r\n                return getToken(context, 10 /* LinkedDelimiter */, \":\" /* LinkedDelimiter */);\r\n            default:\r\n                if (isPluralStart(scnr)) {\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                if (isLinkedDotStart(scnr, context) ||\r\n                    isLinkedDelimiterStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    return readTokenInLinked(scnr, context);\r\n                }\r\n                if (isLinkedModifierStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    return getToken(context, 12 /* LinkedModifier */, readLinkedModifier(scnr));\r\n                }\r\n                if (isLinkedReferStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    if (ch === \"{\" /* BraceLeft */) {\r\n                        // scan the placeholder\r\n                        return readTokenInPlaceholder(scnr, context) || token;\r\n                    }\r\n                    else {\r\n                        return getToken(context, 11 /* LinkedKey */, readLinkedRefer(scnr));\r\n                    }\r\n                }\r\n                if (currentType === 8 /* LinkedAlias */) {\r\n                    emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\r\n                }\r\n                context.braceNest = 0;\r\n                context.inLinked = false;\r\n                return readToken(scnr, context);\r\n        }\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readToken(scnr, context) {\r\n        let token = { type: 14 /* EOF */ };\r\n        if (context.braceNest > 0) {\r\n            return readTokenInPlaceholder(scnr, context) || getEndToken(context);\r\n        }\r\n        if (context.inLinked) {\r\n            return readTokenInLinked(scnr, context) || getEndToken(context);\r\n        }\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case \"{\" /* BraceLeft */:\r\n                return readTokenInPlaceholder(scnr, context) || getEndToken(context);\r\n            case \"}\" /* BraceRight */:\r\n                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\r\n                scnr.next();\r\n                return getToken(context, 3 /* BraceRight */, \"}\" /* BraceRight */);\r\n            case \"@\" /* LinkedAlias */:\r\n                return readTokenInLinked(scnr, context) || getEndToken(context);\r\n            default:\r\n                if (isPluralStart(scnr)) {\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                const { isModulo, hasSpace } = detectModuloStart(scnr);\r\n                if (isModulo) {\r\n                    return hasSpace\r\n                        ? getToken(context, 0 /* Text */, readText(scnr))\r\n                        : getToken(context, 4 /* Modulo */, readModulo(scnr));\r\n                }\r\n                if (isTextStart(scnr)) {\r\n                    return getToken(context, 0 /* Text */, readText(scnr));\r\n                }\r\n                break;\r\n        }\r\n        return token;\r\n    }\r\n    function nextToken() {\r\n        const { currentType, offset, startLoc, endLoc } = _context;\r\n        _context.lastType = currentType;\r\n        _context.lastOffset = offset;\r\n        _context.lastStartLoc = startLoc;\r\n        _context.lastEndLoc = endLoc;\r\n        _context.offset = currentOffset();\r\n        _context.startLoc = currentPosition();\r\n        if (_scnr.currentChar() === EOF) {\r\n            return getToken(_context, 14 /* EOF */);\r\n        }\r\n        return readToken(_scnr, _context);\r\n    }\r\n    return {\r\n        nextToken,\r\n        currentOffset,\r\n        currentPosition,\r\n        context\r\n    };\r\n}\n\nconst ERROR_DOMAIN = 'parser';\r\n// Backslash backslash, backslash quote, uHHHH, UHHHHHH.\r\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\r\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\r\n    switch (match) {\r\n        case `\\\\\\\\`:\r\n            return `\\\\`;\r\n        case `\\\\\\'`:\r\n            return `\\'`;\r\n        default: {\r\n            const codePoint = parseInt(codePoint4 || codePoint6, 16);\r\n            if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\r\n                return String.fromCodePoint(codePoint);\r\n            }\r\n            // invalid ...\r\n            // Replace them with U+FFFD REPLACEMENT CHARACTER.\r\n            return '�';\r\n        }\r\n    }\r\n}\r\nfunction createParser(options = {}) {\r\n    const location = options.location !== false;\r\n    const { onError } = options;\r\n    function emitError(tokenzer, code, start, offset, ...args) {\r\n        const end = tokenzer.currentPosition();\r\n        end.offset += offset;\r\n        end.column += offset;\r\n        if (onError) {\r\n            const loc = createLocation(start, end);\r\n            const err = createCompileError(code, loc, {\r\n                domain: ERROR_DOMAIN,\r\n                args\r\n            });\r\n            onError(err);\r\n        }\r\n    }\r\n    function startNode(type, offset, loc) {\r\n        const node = {\r\n            type,\r\n            start: offset,\r\n            end: offset\r\n        };\r\n        if (location) {\r\n            node.loc = { start: loc, end: loc };\r\n        }\r\n        return node;\r\n    }\r\n    function endNode(node, offset, pos, type) {\r\n        node.end = offset;\r\n        if (type) {\r\n            node.type = type;\r\n        }\r\n        if (location && node.loc) {\r\n            node.loc.end = pos;\r\n        }\r\n    }\r\n    function parseText(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const node = startNode(3 /* Text */, context.offset, context.startLoc);\r\n        node.value = value;\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseList(tokenizer, index) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(5 /* List */, offset, loc);\r\n        node.index = parseInt(index, 10);\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseNamed(tokenizer, key) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(4 /* Named */, offset, loc);\r\n        node.key = key;\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLiteral(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(9 /* Literal */, offset, loc);\r\n        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLinkedModifier(tokenizer) {\r\n        const token = tokenizer.nextToken();\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get linked dot loc\r\n        const node = startNode(8 /* LinkedModifier */, offset, loc);\r\n        if (token.type !== 12 /* LinkedModifier */) {\r\n            // empty modifier\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\r\n            node.value = '';\r\n            endNode(node, offset, loc);\r\n            return {\r\n                nextConsumeToken: token,\r\n                node\r\n            };\r\n        }\r\n        // check token\r\n        if (token.value == null) {\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n        }\r\n        node.value = token.value || '';\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return {\r\n            node\r\n        };\r\n    }\r\n    function parseLinkedKey(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const node = startNode(7 /* LinkedKey */, context.offset, context.startLoc);\r\n        node.value = value;\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLinked(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const linkedNode = startNode(6 /* Linked */, context.offset, context.startLoc);\r\n        let token = tokenizer.nextToken();\r\n        if (token.type === 9 /* LinkedDot */) {\r\n            const parsed = parseLinkedModifier(tokenizer);\r\n            linkedNode.modifier = parsed.node;\r\n            token = parsed.nextConsumeToken || tokenizer.nextToken();\r\n        }\r\n        // asset check token\r\n        if (token.type !== 10 /* LinkedDelimiter */) {\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n        }\r\n        token = tokenizer.nextToken();\r\n        // skip brace left\r\n        if (token.type === 2 /* BraceLeft */) {\r\n            token = tokenizer.nextToken();\r\n        }\r\n        switch (token.type) {\r\n            case 11 /* LinkedKey */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\r\n                break;\r\n            case 5 /* Named */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseNamed(tokenizer, token.value || '');\r\n                break;\r\n            case 6 /* List */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseList(tokenizer, token.value || '');\r\n                break;\r\n            case 7 /* Literal */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseLiteral(tokenizer, token.value || '');\r\n                break;\r\n            default:\r\n                // empty key\r\n                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\r\n                const nextContext = tokenizer.context();\r\n                const emptyLinkedKeyNode = startNode(7 /* LinkedKey */, nextContext.offset, nextContext.startLoc);\r\n                emptyLinkedKeyNode.value = '';\r\n                endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\r\n                linkedNode.key = emptyLinkedKeyNode;\r\n                endNode(linkedNode, nextContext.offset, nextContext.startLoc);\r\n                return {\r\n                    nextConsumeToken: token,\r\n                    node: linkedNode\r\n                };\r\n        }\r\n        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return {\r\n            node: linkedNode\r\n        };\r\n    }\r\n    function parseMessage(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const startOffset = context.currentType === 1 /* Pipe */\r\n            ? tokenizer.currentOffset()\r\n            : context.offset;\r\n        const startLoc = context.currentType === 1 /* Pipe */\r\n            ? context.endLoc\r\n            : context.startLoc;\r\n        const node = startNode(2 /* Message */, startOffset, startLoc);\r\n        node.items = [];\r\n        let nextToken = null;\r\n        do {\r\n            const token = nextToken || tokenizer.nextToken();\r\n            nextToken = null;\r\n            switch (token.type) {\r\n                case 0 /* Text */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseText(tokenizer, token.value || ''));\r\n                    break;\r\n                case 6 /* List */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseList(tokenizer, token.value || ''));\r\n                    break;\r\n                case 5 /* Named */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseNamed(tokenizer, token.value || ''));\r\n                    break;\r\n                case 7 /* Literal */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseLiteral(tokenizer, token.value || ''));\r\n                    break;\r\n                case 8 /* LinkedAlias */:\r\n                    const parsed = parseLinked(tokenizer);\r\n                    node.items.push(parsed.node);\r\n                    nextToken = parsed.nextConsumeToken || null;\r\n                    break;\r\n            }\r\n        } while (context.currentType !== 14 /* EOF */ &&\r\n            context.currentType !== 1 /* Pipe */);\r\n        // adjust message node loc\r\n        const endOffset = context.currentType === 1 /* Pipe */\r\n            ? context.lastOffset\r\n            : tokenizer.currentOffset();\r\n        const endLoc = context.currentType === 1 /* Pipe */\r\n            ? context.lastEndLoc\r\n            : tokenizer.currentPosition();\r\n        endNode(node, endOffset, endLoc);\r\n        return node;\r\n    }\r\n    function parsePlural(tokenizer, offset, loc, msgNode) {\r\n        const context = tokenizer.context();\r\n        let hasEmptyMessage = msgNode.items.length === 0;\r\n        const node = startNode(1 /* Plural */, offset, loc);\r\n        node.cases = [];\r\n        node.cases.push(msgNode);\r\n        do {\r\n            const msg = parseMessage(tokenizer);\r\n            if (!hasEmptyMessage) {\r\n                hasEmptyMessage = msg.items.length === 0;\r\n            }\r\n            node.cases.push(msg);\r\n        } while (context.currentType !== 14 /* EOF */);\r\n        if (hasEmptyMessage) {\r\n            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\r\n        }\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseResource(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const { offset, startLoc } = context;\r\n        const msgNode = parseMessage(tokenizer);\r\n        if (context.currentType === 14 /* EOF */) {\r\n            return msgNode;\r\n        }\r\n        else {\r\n            return parsePlural(tokenizer, offset, startLoc, msgNode);\r\n        }\r\n    }\r\n    function parse(source) {\r\n        const tokenizer = createTokenizer(source, shared.assign({}, options));\r\n        const context = tokenizer.context();\r\n        const node = startNode(0 /* Resource */, context.offset, context.startLoc);\r\n        if (location && node.loc) {\r\n            node.loc.source = source;\r\n        }\r\n        node.body = parseResource(tokenizer);\r\n        // assert whether achieved to EOF\r\n        if (context.currentType !== 14 /* EOF */) {\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\r\n        }\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    return { parse };\r\n}\r\nfunction getTokenCaption(token) {\r\n    if (token.type === 14 /* EOF */) {\r\n        return 'EOF';\r\n    }\r\n    const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\r\n    return name.length > 10 ? name.slice(0, 9) + '…' : name;\r\n}\n\nfunction createTransformer(ast, options = {} // eslint-disable-line\r\n) {\r\n    const _context = {\r\n        ast,\r\n        helpers: new Set()\r\n    };\r\n    const context = () => _context;\r\n    const helper = (name) => {\r\n        _context.helpers.add(name);\r\n        return name;\r\n    };\r\n    return { context, helper };\r\n}\r\nfunction traverseNodes(nodes, transformer) {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        traverseNode(nodes[i], transformer);\r\n    }\r\n}\r\nfunction traverseNode(node, transformer) {\r\n    // TODO: if we need pre-hook of transform, should be implemented to here\r\n    switch (node.type) {\r\n        case 1 /* Plural */:\r\n            traverseNodes(node.cases, transformer);\r\n            transformer.helper(\"plural\" /* PLURAL */);\r\n            break;\r\n        case 2 /* Message */:\r\n            traverseNodes(node.items, transformer);\r\n            break;\r\n        case 6 /* Linked */:\r\n            const linked = node;\r\n            traverseNode(linked.key, transformer);\r\n            transformer.helper(\"linked\" /* LINKED */);\r\n            transformer.helper(\"type\" /* TYPE */);\r\n            break;\r\n        case 5 /* List */:\r\n            transformer.helper(\"interpolate\" /* INTERPOLATE */);\r\n            transformer.helper(\"list\" /* LIST */);\r\n            break;\r\n        case 4 /* Named */:\r\n            transformer.helper(\"interpolate\" /* INTERPOLATE */);\r\n            transformer.helper(\"named\" /* NAMED */);\r\n            break;\r\n    }\r\n    // TODO: if we need post-hook of transform, should be implemented to here\r\n}\r\n// transform AST\r\nfunction transform(ast, options = {} // eslint-disable-line\r\n) {\r\n    const transformer = createTransformer(ast);\r\n    transformer.helper(\"normalize\" /* NORMALIZE */);\r\n    // traverse\r\n    ast.body && traverseNode(ast.body, transformer);\r\n    // set meta information\r\n    const context = transformer.context();\r\n    ast.helpers = Array.from(context.helpers);\r\n}\n\nfunction createCodeGenerator(ast, options) {\r\n    const { sourceMap: sourceMap$1, filename, breakLineCode, needIndent: _needIndent } = options;\r\n    const _context = {\r\n        source: ast.loc.source,\r\n        filename,\r\n        code: '',\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        map: undefined,\r\n        breakLineCode,\r\n        needIndent: _needIndent,\r\n        indentLevel: 0\r\n    };\r\n    const context = () => _context;\r\n    function push(code, node) {\r\n        _context.code += code;\r\n        if (_context.map) {\r\n            if (node && node.loc && node.loc !== LocationStub) {\r\n                addMapping(node.loc.start, getMappingName(node));\r\n            }\r\n            advancePositionWithSource(_context, code);\r\n        }\r\n    }\r\n    function _newline(n, withBreakLine = true) {\r\n        const _breakLineCode = withBreakLine ? breakLineCode : '';\r\n        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\r\n    }\r\n    function indent(withNewLine = true) {\r\n        const level = ++_context.indentLevel;\r\n        withNewLine && _newline(level);\r\n    }\r\n    function deindent(withNewLine = true) {\r\n        const level = --_context.indentLevel;\r\n        withNewLine && _newline(level);\r\n    }\r\n    function newline() {\r\n        _newline(_context.indentLevel);\r\n    }\r\n    const helper = (key) => `_${key}`;\r\n    const needIndent = () => _context.needIndent;\r\n    function addMapping(loc, name) {\r\n        _context.map.addMapping({\r\n            name,\r\n            source: _context.filename,\r\n            original: {\r\n                line: loc.line,\r\n                column: loc.column - 1\r\n            },\r\n            generated: {\r\n                line: _context.line,\r\n                column: _context.column - 1\r\n            }\r\n        });\r\n    }\r\n    if (sourceMap$1) {\r\n        _context.map = new sourceMap.SourceMapGenerator();\r\n        _context.map.setSourceContent(filename, _context.source);\r\n    }\r\n    return {\r\n        context,\r\n        push,\r\n        indent,\r\n        deindent,\r\n        newline,\r\n        helper,\r\n        needIndent\r\n    };\r\n}\r\nfunction generateLinkedNode(generator, node) {\r\n    const { helper } = generator;\r\n    generator.push(`${helper(\"linked\" /* LINKED */)}(`);\r\n    generateNode(generator, node.key);\r\n    if (node.modifier) {\r\n        generator.push(`, `);\r\n        generateNode(generator, node.modifier);\r\n        generator.push(`, _type`);\r\n    }\r\n    else {\r\n        generator.push(`, undefined, _type`);\r\n    }\r\n    generator.push(`)`);\r\n}\r\nfunction generateMessageNode(generator, node) {\r\n    const { helper, needIndent } = generator;\r\n    generator.push(`${helper(\"normalize\" /* NORMALIZE */)}([`);\r\n    generator.indent(needIndent());\r\n    const length = node.items.length;\r\n    for (let i = 0; i < length; i++) {\r\n        generateNode(generator, node.items[i]);\r\n        if (i === length - 1) {\r\n            break;\r\n        }\r\n        generator.push(', ');\r\n    }\r\n    generator.deindent(needIndent());\r\n    generator.push('])');\r\n}\r\nfunction generatePluralNode(generator, node) {\r\n    const { helper, needIndent } = generator;\r\n    if (node.cases.length > 1) {\r\n        generator.push(`${helper(\"plural\" /* PLURAL */)}([`);\r\n        generator.indent(needIndent());\r\n        const length = node.cases.length;\r\n        for (let i = 0; i < length; i++) {\r\n            generateNode(generator, node.cases[i]);\r\n            if (i === length - 1) {\r\n                break;\r\n            }\r\n            generator.push(', ');\r\n        }\r\n        generator.deindent(needIndent());\r\n        generator.push(`])`);\r\n    }\r\n}\r\nfunction generateResource(generator, node) {\r\n    if (node.body) {\r\n        generateNode(generator, node.body);\r\n    }\r\n    else {\r\n        generator.push('null');\r\n    }\r\n}\r\nfunction generateNode(generator, node) {\r\n    const { helper } = generator;\r\n    switch (node.type) {\r\n        case 0 /* Resource */:\r\n            generateResource(generator, node);\r\n            break;\r\n        case 1 /* Plural */:\r\n            generatePluralNode(generator, node);\r\n            break;\r\n        case 2 /* Message */:\r\n            generateMessageNode(generator, node);\r\n            break;\r\n        case 6 /* Linked */:\r\n            generateLinkedNode(generator, node);\r\n            break;\r\n        case 8 /* LinkedModifier */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 7 /* LinkedKey */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 5 /* List */:\r\n            generator.push(`${helper(\"interpolate\" /* INTERPOLATE */)}(${helper(\"list\" /* LIST */)}(${node.index}))`, node);\r\n            break;\r\n        case 4 /* Named */:\r\n            generator.push(`${helper(\"interpolate\" /* INTERPOLATE */)}(${helper(\"named\" /* NAMED */)}(${JSON.stringify(node.key)}))`, node);\r\n            break;\r\n        case 9 /* Literal */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 3 /* Text */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        default:\r\n            {\r\n                throw new Error(`unhandled codegen node type: ${node.type}`);\r\n            }\r\n    }\r\n}\r\n// generate code from AST\r\nconst generate = (ast, options = {} // eslint-disable-line\r\n) => {\r\n    const mode = shared.isString(options.mode) ? options.mode : 'normal';\r\n    const filename = shared.isString(options.filename)\r\n        ? options.filename\r\n        : 'message.intl';\r\n    const sourceMap = !!options.sourceMap;\r\n    // prettier-ignore\r\n    const breakLineCode = options.breakLineCode != null\r\n        ? options.breakLineCode\r\n        : mode === 'arrow'\r\n            ? ';'\r\n            : '\\n';\r\n    const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\r\n    const helpers = ast.helpers || [];\r\n    const generator = createCodeGenerator(ast, {\r\n        mode,\r\n        filename,\r\n        sourceMap,\r\n        breakLineCode,\r\n        needIndent\r\n    });\r\n    generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\r\n    generator.indent(needIndent);\r\n    if (helpers.length > 0) {\r\n        generator.push(`const { ${helpers.map(s => `${s}: _${s}`).join(', ')} } = ctx`);\r\n        generator.newline();\r\n    }\r\n    generator.push(`return `);\r\n    generateNode(generator, ast);\r\n    generator.deindent(needIndent);\r\n    generator.push(`}`);\r\n    const { code, map } = generator.context();\r\n    return {\r\n        ast,\r\n        code,\r\n        map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\r\n    };\r\n};\r\nfunction getMappingName(node) {\r\n    switch (node.type) {\r\n        case 3 /* Text */:\r\n        case 9 /* Literal */:\r\n        case 8 /* LinkedModifier */:\r\n        case 7 /* LinkedKey */:\r\n            return node.value;\r\n        case 5 /* List */:\r\n            return node.index.toString();\r\n        case 4 /* Named */:\r\n            return node.key;\r\n        default:\r\n            return undefined;\r\n    }\r\n}\r\nfunction advancePositionWithSource(pos, source, numberOfCharacters = source.length) {\r\n    let linesCount = 0;\r\n    let lastNewLinePos = -1;\r\n    for (let i = 0; i < numberOfCharacters; i++) {\r\n        if (source.charCodeAt(i) === 10 /* newline char code */) {\r\n            linesCount++;\r\n            lastNewLinePos = i;\r\n        }\r\n    }\r\n    pos.offset += numberOfCharacters;\r\n    pos.line += linesCount;\r\n    pos.column =\r\n        lastNewLinePos === -1\r\n            ? pos.column + numberOfCharacters\r\n            : numberOfCharacters - lastNewLinePos;\r\n    return pos;\r\n}\n\nfunction baseCompile(source, options = {}) {\r\n    const assignedOptions = shared.assign({}, options);\r\n    // parse source codes\r\n    const parser = createParser(assignedOptions);\r\n    const ast = parser.parse(source);\r\n    // transform ASTs\r\n    transform(ast, assignedOptions);\r\n    // generate javascript codes\r\n    return generate(ast, assignedOptions);\r\n}\n\nexports.CompileErrorCodes = CompileErrorCodes;\nexports.ERROR_DOMAIN = ERROR_DOMAIN;\nexports.LocationStub = LocationStub;\nexports.baseCompile = baseCompile;\nexports.createCompileError = createCompileError;\nexports.createLocation = createLocation;\nexports.createParser = createParser;\nexports.createPosition = createPosition;\nexports.defaultOnError = defaultOnError;\nexports.errorMessages = errorMessages;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
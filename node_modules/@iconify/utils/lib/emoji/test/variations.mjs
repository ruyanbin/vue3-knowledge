import { splitEmojiSequences, joinEmojiSequences, getUnqualifiedEmojiSequence } from '../cleanup.mjs';
import { convertEmojiSequenceToUTF32 } from '../convert.mjs';
import { vs16Emoji, keycapEmoji } from '../data.mjs';
import { getEmojiSequenceKeyword } from '../format.mjs';

function guessQualifiedEmojiSequence(sequence) {
  const split = splitEmojiSequences(sequence).map((part) => {
    if (part.indexOf(vs16Emoji) !== -1) {
      return part;
    }
    if (part.length === 2 && part[1] === keycapEmoji) {
      return [part[0], vs16Emoji, part[1]];
    }
    return part.length === 1 ? [part[0], vs16Emoji] : part;
  });
  return joinEmojiSequences(split);
}
function getQualifiedEmojiVariation(item, testData) {
  const unqualifiedSequence = getUnqualifiedEmojiSequence(
    convertEmojiSequenceToUTF32(item.sequence)
  );
  const key = getEmojiSequenceKeyword(unqualifiedSequence);
  const testDataItem = testData?.[key];
  const result = {
    ...item,
    sequence: testDataItem ? testDataItem.sequence : guessQualifiedEmojiSequence(unqualifiedSequence)
  };
  if (result.sequenceKey) {
    result.sequenceKey = key;
  }
  return result;
}
function getQualifiedEmojiVariations(items, testData) {
  const results = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < items.length; i++) {
    const result = getQualifiedEmojiVariation(items[i], testData);
    const key = getEmojiSequenceKeyword(
      getUnqualifiedEmojiSequence(result.sequence)
    );
    if (!results[key] || results[key].sequence.length < result.sequence.length) {
      results[key] = result;
    }
  }
  return Object.values(results);
}

export { getQualifiedEmojiVariation, getQualifiedEmojiVariations, guessQualifiedEmojiSequence };

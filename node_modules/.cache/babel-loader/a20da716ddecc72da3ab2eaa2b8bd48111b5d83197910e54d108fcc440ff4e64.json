{"ast":null,"code":"import { LOADED, FAILED } from './constants.js';\nfunction isDownloadFinished(value) {\n  return value === LOADED || value === FAILED;\n}\n\n// Checks whether this tile was last used on the given frame.\nfunction isUsedThisFrame(tile, frameCount) {\n  return tile.__lastFrameVisited === frameCount && tile.__used;\n}\n\n// Resets the frame frame information for the given tile\nfunction resetFrameState(tile, frameCount) {\n  if (tile.__lastFrameVisited !== frameCount) {\n    tile.__lastFrameVisited = frameCount;\n    tile.__used = false;\n    tile.__inFrustum = false;\n    tile.__isLeaf = false;\n    tile.__visible = false;\n    tile.__active = false;\n    tile.__error = Infinity;\n    tile.__distanceFromCamera = Infinity;\n    tile.__childrenWereVisible = false;\n    tile.__allChildrenLoaded = false;\n  }\n}\n\n// Recursively mark tiles used down to the next tile with content\nfunction recursivelyMarkUsed(tile, frameCount, lruCache) {\n  resetFrameState(tile, frameCount);\n  tile.__used = true;\n  lruCache.markUsed(tile);\n  if (tile.__contentEmpty) {\n    const children = tile.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      recursivelyMarkUsed(children[i], frameCount, lruCache);\n    }\n  }\n}\nfunction recursivelyLoadTiles(tile, depthFromRenderedParent, renderer) {\n  // Try to load any external tile set children if the external tile set has loaded.\n  const doTraverse = tile.__contentEmpty && (!tile.__externalTileSet || isDownloadFinished(tile.__loadingState));\n  if (doTraverse) {\n    const children = tile.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      // don't increment depth to rendered parent here because we should treat\n      // the next layer of rendered children as just a single depth away for the\n      // sake of sorting.\n      const child = children[i];\n      child.__depthFromRenderedParent = depthFromRenderedParent;\n      recursivelyLoadTiles(child, depthFromRenderedParent, renderer);\n    }\n  } else {\n    renderer.requestTileContents(tile);\n  }\n}\n\n// Helper function for recursively traversing a tile set. If `beforeCb` returns `true` then the\n// traversal will end early.\nexport function traverseSet(tile, beforeCb = null, afterCb = null, parent = null, depth = 0) {\n  if (beforeCb && beforeCb(tile, parent, depth)) {\n    if (afterCb) {\n      afterCb(tile, parent, depth);\n    }\n    return;\n  }\n  const children = tile.children;\n  for (let i = 0, l = children.length; i < l; i++) {\n    traverseSet(children[i], beforeCb, afterCb, tile, depth + 1);\n  }\n  if (afterCb) {\n    afterCb(tile, parent, depth);\n  }\n}\n\n// Determine which tiles are within the camera frustum.\n// TODO: this is marking items as used in the lrucache, which means some data is\n// being kept around that isn't being used -- is that okay?\nexport function determineFrustumSet(tile, renderer) {\n  const stats = renderer.stats;\n  const frameCount = renderer.frameCount;\n  const errorTarget = renderer.errorTarget;\n  const maxDepth = renderer.maxDepth;\n  const loadSiblings = renderer.loadSiblings;\n  const lruCache = renderer.lruCache;\n  const stopAtEmptyTiles = renderer.stopAtEmptyTiles;\n  resetFrameState(tile, frameCount);\n\n  // Early out if this tile is not within view.\n  const inFrustum = renderer.tileInView(tile);\n  if (inFrustum === false) {\n    return false;\n  }\n  tile.__used = true;\n  lruCache.markUsed(tile);\n  tile.__inFrustum = true;\n  stats.inFrustum++;\n\n  // Early out if this tile has less error than we're targeting but don't stop\n  // at an external tile set.\n  if ((stopAtEmptyTiles || !tile.__contentEmpty) && !tile.__externalTileSet) {\n    // compute the _error and __distanceFromCamera fields\n    renderer.calculateError(tile);\n    const error = tile.__error;\n    if (error <= errorTarget) {\n      return true;\n    }\n\n    // Early out if we've reached the maximum allowed depth.\n    if (renderer.maxDepth > 0 && tile.__depth + 1 >= maxDepth) {\n      return true;\n    }\n  }\n\n  // Traverse children and see if any children are in view.\n  let anyChildrenUsed = false;\n  const children = tile.children;\n  for (let i = 0, l = children.length; i < l; i++) {\n    const c = children[i];\n    const r = determineFrustumSet(c, renderer);\n    anyChildrenUsed = anyChildrenUsed || r;\n  }\n\n  // If there are children within view and we are loading siblings then mark\n  // all sibling tiles as used, as well.\n  if (anyChildrenUsed && loadSiblings) {\n    for (let i = 0, l = children.length; i < l; i++) {\n      const c = children[i];\n      recursivelyMarkUsed(c, frameCount, lruCache);\n    }\n  }\n  return true;\n}\n\n// Traverse and mark the tiles that are at the leaf nodes of the \"used\" tree.\nexport function markUsedSetLeaves(tile, renderer) {\n  const stats = renderer.stats;\n  const frameCount = renderer.frameCount;\n  if (!isUsedThisFrame(tile, frameCount)) {\n    return;\n  }\n  stats.used++;\n\n  // This tile is a leaf if none of the children had been used.\n  const children = tile.children;\n  let anyChildrenUsed = false;\n  for (let i = 0, l = children.length; i < l; i++) {\n    const c = children[i];\n    anyChildrenUsed = anyChildrenUsed || isUsedThisFrame(c, frameCount);\n  }\n  if (!anyChildrenUsed) {\n    // TODO: This isn't necessarily right because it's possible that a parent tile is considered in the\n    // frustum while the child tiles are not, making them unused. If all children have loaded and were properly\n    // considered to be in the used set then we shouldn't set ourselves to a leaf here.\n    tile.__isLeaf = true;\n  } else {\n    let childrenWereVisible = false;\n    let allChildrenLoaded = true;\n    for (let i = 0, l = children.length; i < l; i++) {\n      const c = children[i];\n      markUsedSetLeaves(c, renderer);\n      childrenWereVisible = childrenWereVisible || c.__wasSetVisible || c.__childrenWereVisible;\n      if (isUsedThisFrame(c, frameCount)) {\n        const childLoaded = c.__allChildrenLoaded || !c.__contentEmpty && isDownloadFinished(c.__loadingState) || c.__externalTileSet && c.__loadingState === FAILED;\n        allChildrenLoaded = allChildrenLoaded && childLoaded;\n      }\n    }\n    tile.__childrenWereVisible = childrenWereVisible;\n    tile.__allChildrenLoaded = allChildrenLoaded;\n  }\n}\n\n// Skip past tiles we consider unrenderable because they are outside the error threshold.\nexport function skipTraversal(tile, renderer) {\n  const stats = renderer.stats;\n  const frameCount = renderer.frameCount;\n  if (!isUsedThisFrame(tile, frameCount)) {\n    return;\n  }\n  const parent = tile.parent;\n  const parentDepthToParent = parent ? parent.__depthFromRenderedParent : -1;\n  tile.__depthFromRenderedParent = parentDepthToParent;\n\n  // Request the tile contents or mark it as visible if we've found a leaf.\n  const lruCache = renderer.lruCache;\n  if (tile.__isLeaf) {\n    tile.__depthFromRenderedParent++;\n    if (tile.__loadingState === LOADED) {\n      if (tile.__inFrustum) {\n        tile.__visible = true;\n        stats.visible++;\n      }\n      tile.__active = true;\n      stats.active++;\n    } else if (!lruCache.isFull() && (!tile.__contentEmpty || tile.__externalTileSet)) {\n      renderer.requestTileContents(tile);\n    }\n    return;\n  }\n  const errorRequirement = (renderer.errorTarget + 1) * renderer.errorThreshold;\n  const meetsSSE = tile.__error <= errorRequirement;\n  const includeTile = meetsSSE || tile.refine === 'ADD';\n  const hasModel = !tile.__contentEmpty;\n  const hasContent = hasModel || tile.__externalTileSet;\n  const loadedContent = isDownloadFinished(tile.__loadingState) && hasContent;\n  const childrenWereVisible = tile.__childrenWereVisible;\n  const children = tile.children;\n  const allChildrenHaveContent = tile.__allChildrenLoaded;\n\n  // Increment the relative depth of the node to the nearest rendered parent if it has content\n  // and is being rendered.\n  if (includeTile && hasModel) {\n    tile.__depthFromRenderedParent++;\n  }\n\n  // If we've met the SSE requirements and we can load content then fire a fetch.\n  if (includeTile && !loadedContent && !lruCache.isFull() && hasContent) {\n    renderer.requestTileContents(tile);\n  }\n\n  // Only mark this tile as visible if it meets the screen space error requirements, has loaded content, not\n  // all children have loaded yet, and if no children were visible last frame. We want to keep children visible\n  // that _were_ visible to avoid a pop in level of detail as the camera moves around and parent / sibling tiles\n  // load in.\n\n  // Skip the tile entirely if there's no content to load\n  if (meetsSSE && !allChildrenHaveContent && !childrenWereVisible && loadedContent || tile.refine === 'ADD' && loadedContent) {\n    if (tile.__inFrustum) {\n      tile.__visible = true;\n      stats.visible++;\n    }\n    tile.__active = true;\n    stats.active++;\n  }\n\n  // If we're additive then don't stop the traversal here because it doesn't matter whether the children load in\n  // at the same rate.\n  if (tile.refine !== 'ADD' && meetsSSE && !allChildrenHaveContent && loadedContent) {\n    // load the child content if we've found that we've been loaded so we can move down to the next tile\n    // layer when the data has loaded.\n    for (let i = 0, l = children.length; i < l; i++) {\n      const c = children[i];\n      if (isUsedThisFrame(c, frameCount) && !lruCache.isFull()) {\n        c.__depthFromRenderedParent = tile.__depthFromRenderedParent + 1;\n        recursivelyLoadTiles(c, c.__depthFromRenderedParent, renderer);\n      }\n    }\n  } else {\n    for (let i = 0, l = children.length; i < l; i++) {\n      const c = children[i];\n      if (isUsedThisFrame(c, frameCount)) {\n        skipTraversal(c, renderer);\n      }\n    }\n  }\n}\n\n// Final traverse to toggle tile visibility.\nexport function toggleTiles(tile, renderer) {\n  const frameCount = renderer.frameCount;\n  const isUsed = isUsedThisFrame(tile, frameCount);\n  if (isUsed || tile.__usedLastFrame) {\n    let setActive = false;\n    let setVisible = false;\n    if (isUsed) {\n      // enable visibility if active due to shadows\n      setActive = tile.__active;\n      if (renderer.displayActiveTiles) {\n        setVisible = tile.__active || tile.__visible;\n      } else {\n        setVisible = tile.__visible;\n      }\n    }\n\n    // If the active or visible state changed then call the functions.\n    if (!tile.__contentEmpty && tile.__loadingState === LOADED) {\n      if (tile.__wasSetActive !== setActive) {\n        renderer.setTileActive(tile, setActive);\n      }\n      if (tile.__wasSetVisible !== setVisible) {\n        renderer.setTileVisible(tile, setVisible);\n      }\n    }\n    tile.__wasSetActive = setActive;\n    tile.__wasSetVisible = setVisible;\n    tile.__usedLastFrame = isUsed;\n    const children = tile.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      const c = children[i];\n      toggleTiles(c, renderer);\n    }\n  }\n}","map":{"version":3,"names":["LOADED","FAILED","isDownloadFinished","value","isUsedThisFrame","tile","frameCount","__lastFrameVisited","__used","resetFrameState","__inFrustum","__isLeaf","__visible","__active","__error","Infinity","__distanceFromCamera","__childrenWereVisible","__allChildrenLoaded","recursivelyMarkUsed","lruCache","markUsed","__contentEmpty","children","i","l","length","recursivelyLoadTiles","depthFromRenderedParent","renderer","doTraverse","__externalTileSet","__loadingState","child","__depthFromRenderedParent","requestTileContents","traverseSet","beforeCb","afterCb","parent","depth","determineFrustumSet","stats","errorTarget","maxDepth","loadSiblings","stopAtEmptyTiles","inFrustum","tileInView","calculateError","error","__depth","anyChildrenUsed","c","r","markUsedSetLeaves","used","childrenWereVisible","allChildrenLoaded","__wasSetVisible","childLoaded","skipTraversal","parentDepthToParent","visible","active","isFull","errorRequirement","errorThreshold","meetsSSE","includeTile","refine","hasModel","hasContent","loadedContent","allChildrenHaveContent","toggleTiles","isUsed","__usedLastFrame","setActive","setVisible","displayActiveTiles","__wasSetActive","setTileActive","setTileVisible"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/3d-tiles-renderer/src/base/traverseFunctions.js"],"sourcesContent":["import { LOADED, FAILED } from './constants.js';\n\nfunction isDownloadFinished( value ) {\n\n\treturn value === LOADED || value === FAILED;\n\n}\n\n// Checks whether this tile was last used on the given frame.\nfunction isUsedThisFrame( tile, frameCount ) {\n\n\treturn tile.__lastFrameVisited === frameCount && tile.__used;\n\n}\n\n// Resets the frame frame information for the given tile\nfunction resetFrameState( tile, frameCount ) {\n\n\tif ( tile.__lastFrameVisited !== frameCount ) {\n\n\t\ttile.__lastFrameVisited = frameCount;\n\t\ttile.__used = false;\n\t\ttile.__inFrustum = false;\n\t\ttile.__isLeaf = false;\n\t\ttile.__visible = false;\n\t\ttile.__active = false;\n\t\ttile.__error = Infinity;\n\t\ttile.__distanceFromCamera = Infinity;\n\t\ttile.__childrenWereVisible = false;\n\t\ttile.__allChildrenLoaded = false;\n\n\t}\n\n}\n\n// Recursively mark tiles used down to the next tile with content\nfunction recursivelyMarkUsed( tile, frameCount, lruCache ) {\n\n\tresetFrameState( tile, frameCount );\n\n\ttile.__used = true;\n\tlruCache.markUsed( tile );\n\tif ( tile.__contentEmpty ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], frameCount, lruCache );\n\n\t\t}\n\n\t}\n\n}\n\nfunction recursivelyLoadTiles( tile, depthFromRenderedParent, renderer ) {\n\n\t// Try to load any external tile set children if the external tile set has loaded.\n\tconst doTraverse =\n\t\ttile.__contentEmpty && (\n\t\t\t! tile.__externalTileSet ||\n\t\t\tisDownloadFinished( tile.__loadingState )\n\t\t);\n\tif ( doTraverse ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t// don't increment depth to rendered parent here because we should treat\n\t\t\t// the next layer of rendered children as just a single depth away for the\n\t\t\t// sake of sorting.\n\t\t\tconst child = children[ i ];\n\t\t\tchild.__depthFromRenderedParent = depthFromRenderedParent;\n\t\t\trecursivelyLoadTiles( child, depthFromRenderedParent, renderer );\n\n\t\t}\n\n\t} else {\n\n\t\trenderer.requestTileContents( tile );\n\n\t}\n\n}\n\n// Helper function for recursively traversing a tile set. If `beforeCb` returns `true` then the\n// traversal will end early.\nexport function traverseSet( tile, beforeCb = null, afterCb = null, parent = null, depth = 0 ) {\n\n\tif ( beforeCb && beforeCb( tile, parent, depth ) ) {\n\n\t\tif ( afterCb ) {\n\n\t\t\tafterCb( tile, parent, depth );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\ttraverseSet( children[ i ], beforeCb, afterCb, tile, depth + 1 );\n\n\t}\n\n\tif ( afterCb ) {\n\n\t\tafterCb( tile, parent, depth );\n\n\t}\n\n}\n\n// Determine which tiles are within the camera frustum.\n// TODO: this is marking items as used in the lrucache, which means some data is\n// being kept around that isn't being used -- is that okay?\nexport function determineFrustumSet( tile, renderer ) {\n\n\tconst stats = renderer.stats;\n\tconst frameCount = renderer.frameCount;\n\tconst errorTarget = renderer.errorTarget;\n\tconst maxDepth = renderer.maxDepth;\n\tconst loadSiblings = renderer.loadSiblings;\n\tconst lruCache = renderer.lruCache;\n\tconst stopAtEmptyTiles = renderer.stopAtEmptyTiles;\n\tresetFrameState( tile, frameCount );\n\n\t// Early out if this tile is not within view.\n\tconst inFrustum = renderer.tileInView( tile );\n\tif ( inFrustum === false ) {\n\n\t\treturn false;\n\n\t}\n\n\ttile.__used = true;\n\tlruCache.markUsed( tile );\n\n\ttile.__inFrustum = true;\n\tstats.inFrustum ++;\n\n\t// Early out if this tile has less error than we're targeting but don't stop\n\t// at an external tile set.\n\tif ( ( stopAtEmptyTiles || ! tile.__contentEmpty ) && ! tile.__externalTileSet ) {\n\n\t\t// compute the _error and __distanceFromCamera fields\n\t\trenderer.calculateError( tile );\n\n\t\tconst error = tile.__error;\n\t\tif ( error <= errorTarget ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// Early out if we've reached the maximum allowed depth.\n\t\tif ( renderer.maxDepth > 0 && tile.__depth + 1 >= maxDepth ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\t// Traverse children and see if any children are in view.\n\tlet anyChildrenUsed = false;\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tconst r = determineFrustumSet( c, renderer );\n\t\tanyChildrenUsed = anyChildrenUsed || r;\n\n\t}\n\n\t// If there are children within view and we are loading siblings then mark\n\t// all sibling tiles as used, as well.\n\tif ( anyChildrenUsed && loadSiblings ) {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\trecursivelyMarkUsed( c, frameCount, lruCache );\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\n// Traverse and mark the tiles that are at the leaf nodes of the \"used\" tree.\nexport function markUsedSetLeaves( tile, renderer ) {\n\n\tconst stats = renderer.stats;\n\tconst frameCount = renderer.frameCount;\n\tif ( ! isUsedThisFrame( tile, frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\tstats.used ++;\n\n\t// This tile is a leaf if none of the children had been used.\n\tconst children = tile.children;\n\tlet anyChildrenUsed = false;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, frameCount );\n\n\t}\n\n\n\tif ( ! anyChildrenUsed ) {\n\n\t\t// TODO: This isn't necessarily right because it's possible that a parent tile is considered in the\n\t\t// frustum while the child tiles are not, making them unused. If all children have loaded and were properly\n\t\t// considered to be in the used set then we shouldn't set ourselves to a leaf here.\n\t\ttile.__isLeaf = true;\n\n\t} else {\n\n\t\tlet childrenWereVisible = false;\n\t\tlet allChildrenLoaded = true;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tmarkUsedSetLeaves( c, renderer );\n\t\t\tchildrenWereVisible = childrenWereVisible || c.__wasSetVisible || c.__childrenWereVisible;\n\n\t\t\tif ( isUsedThisFrame( c, frameCount ) ) {\n\n\t\t\t\tconst childLoaded =\n\t\t\t\t\tc.__allChildrenLoaded ||\n\t\t\t\t\t( ! c.__contentEmpty && isDownloadFinished( c.__loadingState ) ) ||\n\t\t\t\t\t( c.__externalTileSet && c.__loadingState === FAILED );\n\t\t\t\tallChildrenLoaded = allChildrenLoaded && childLoaded;\n\n\t\t\t}\n\n\t\t}\n\t\ttile.__childrenWereVisible = childrenWereVisible;\n\t\ttile.__allChildrenLoaded = allChildrenLoaded;\n\n\n\t}\n\n}\n\n// Skip past tiles we consider unrenderable because they are outside the error threshold.\nexport function skipTraversal( tile, renderer ) {\n\n\tconst stats = renderer.stats;\n\tconst frameCount = renderer.frameCount;\n\tif ( ! isUsedThisFrame( tile, frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\tconst parent = tile.parent;\n\tconst parentDepthToParent = parent ? parent.__depthFromRenderedParent : - 1;\n\ttile.__depthFromRenderedParent = parentDepthToParent;\n\n\t// Request the tile contents or mark it as visible if we've found a leaf.\n\tconst lruCache = renderer.lruCache;\n\tif ( tile.__isLeaf ) {\n\n\t\ttile.__depthFromRenderedParent ++;\n\n\t\tif ( tile.__loadingState === LOADED ) {\n\n\t\t\tif ( tile.__inFrustum ) {\n\n\t\t\t\ttile.__visible = true;\n\t\t\t\tstats.visible ++;\n\n\t\t\t}\n\t\t\ttile.__active = true;\n\t\t\tstats.active ++;\n\n\t\t} else if ( ! lruCache.isFull() && ( ! tile.__contentEmpty || tile.__externalTileSet ) ) {\n\n\t\t\trenderer.requestTileContents( tile );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\tconst errorRequirement = ( renderer.errorTarget + 1 ) * renderer.errorThreshold;\n\tconst meetsSSE = tile.__error <= errorRequirement;\n\tconst includeTile = meetsSSE || tile.refine === 'ADD';\n\tconst hasModel = ! tile.__contentEmpty;\n\tconst hasContent = hasModel || tile.__externalTileSet;\n\tconst loadedContent = isDownloadFinished( tile.__loadingState ) && hasContent;\n\tconst childrenWereVisible = tile.__childrenWereVisible;\n\tconst children = tile.children;\n\tconst allChildrenHaveContent = tile.__allChildrenLoaded;\n\n\t// Increment the relative depth of the node to the nearest rendered parent if it has content\n\t// and is being rendered.\n\tif ( includeTile && hasModel ) {\n\n\t\ttile.__depthFromRenderedParent ++;\n\n\t}\n\n\t// If we've met the SSE requirements and we can load content then fire a fetch.\n\tif ( includeTile && ! loadedContent && ! lruCache.isFull() && hasContent ) {\n\n\t\trenderer.requestTileContents( tile );\n\n\t}\n\n\t// Only mark this tile as visible if it meets the screen space error requirements, has loaded content, not\n\t// all children have loaded yet, and if no children were visible last frame. We want to keep children visible\n\t// that _were_ visible to avoid a pop in level of detail as the camera moves around and parent / sibling tiles\n\t// load in.\n\n\t// Skip the tile entirely if there's no content to load\n\tif (\n\t\t( meetsSSE && ! allChildrenHaveContent && ! childrenWereVisible && loadedContent )\n\t\t\t|| ( tile.refine === 'ADD' && loadedContent )\n\t) {\n\n\t\tif ( tile.__inFrustum ) {\n\n\t\t\ttile.__visible = true;\n\t\t\tstats.visible ++;\n\n\t\t}\n\t\ttile.__active = true;\n\t\tstats.active ++;\n\n\t}\n\n\t// If we're additive then don't stop the traversal here because it doesn't matter whether the children load in\n\t// at the same rate.\n\tif ( tile.refine !== 'ADD' && meetsSSE && ! allChildrenHaveContent && loadedContent ) {\n\n\t\t// load the child content if we've found that we've been loaded so we can move down to the next tile\n\t\t// layer when the data has loaded.\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tif ( isUsedThisFrame( c, frameCount ) && ! lruCache.isFull() ) {\n\n\t\t\t\tc.__depthFromRenderedParent = tile.__depthFromRenderedParent + 1;\n\t\t\t\trecursivelyLoadTiles( c, c.__depthFromRenderedParent, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tif ( isUsedThisFrame( c, frameCount ) ) {\n\n\t\t\t\tskipTraversal( c, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Final traverse to toggle tile visibility.\nexport function toggleTiles( tile, renderer ) {\n\n\tconst frameCount = renderer.frameCount;\n\tconst isUsed = isUsedThisFrame( tile, frameCount );\n\tif ( isUsed || tile.__usedLastFrame ) {\n\n\t\tlet setActive = false;\n\t\tlet setVisible = false;\n\t\tif ( isUsed ) {\n\n\t\t\t// enable visibility if active due to shadows\n\t\t\tsetActive = tile.__active;\n\t\t\tif ( renderer.displayActiveTiles ) {\n\n\t\t\t\tsetVisible = tile.__active || tile.__visible;\n\n\t\t\t} else {\n\n\t\t\t\tsetVisible = tile.__visible;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// If the active or visible state changed then call the functions.\n\t\tif ( ! tile.__contentEmpty && tile.__loadingState === LOADED ) {\n\n\t\t\tif ( tile.__wasSetActive !== setActive ) {\n\n\t\t\t\trenderer.setTileActive( tile, setActive );\n\n\t\t\t}\n\n\t\t\tif ( tile.__wasSetVisible !== setVisible ) {\n\n\t\t\t\trenderer.setTileVisible( tile, setVisible );\n\n\t\t\t}\n\n\t\t}\n\t\ttile.__wasSetActive = setActive;\n\t\ttile.__wasSetVisible = setVisible;\n\t\ttile.__usedLastFrame = isUsed;\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\ttoggleTiles( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
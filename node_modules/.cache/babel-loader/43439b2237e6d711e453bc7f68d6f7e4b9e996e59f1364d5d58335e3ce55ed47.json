{"ast":null,"code":"import { Box3Helper, Group, MeshStandardMaterial, PointsMaterial, Sphere } from 'three';\nimport { getIndexedRandomColor } from './utilities.js';\nimport { TilesRenderer } from './TilesRenderer.js';\nimport { SphereHelper } from './objects/SphereHelper.js';\nimport { EllipsoidRegionLineHelper } from './objects/EllipsoidRegionHelper.js';\nconst ORIGINAL_MATERIAL = Symbol('ORIGINAL_MATERIAL');\nconst HAS_RANDOM_COLOR = Symbol('HAS_RANDOM_COLOR');\nconst HAS_RANDOM_NODE_COLOR = Symbol('HAS_RANDOM_NODE_COLOR');\nfunction emptyRaycast() {}\nexport const NONE = 0;\nexport const SCREEN_ERROR = 1;\nexport const GEOMETRIC_ERROR = 2;\nexport const DISTANCE = 3;\nexport const DEPTH = 4;\nexport const RELATIVE_DEPTH = 5;\nexport const IS_LEAF = 6;\nexport const RANDOM_COLOR = 7;\nexport const RANDOM_NODE_COLOR = 8;\nexport const CUSTOM_COLOR = 9;\nexport class DebugTilesRenderer extends TilesRenderer {\n  constructor(...args) {\n    super(...args);\n    const tilesGroup = this.group;\n    const boxGroup = new Group();\n    boxGroup.name = 'DebugTilesRenderer.boxGroup';\n    tilesGroup.add(boxGroup);\n    const sphereGroup = new Group();\n    sphereGroup.name = 'DebugTilesRenderer.sphereGroup';\n    tilesGroup.add(sphereGroup);\n    const regionGroup = new Group();\n    regionGroup.name = 'DebugTilesRenderer.regionGroup';\n    tilesGroup.add(regionGroup);\n    this.displayBoxBounds = false;\n    this.displaySphereBounds = false;\n    this.displayRegionBounds = false;\n    this.colorMode = NONE;\n    this.customColorCallback = null;\n    this.boxGroup = boxGroup;\n    this.sphereGroup = sphereGroup;\n    this.regionGroup = regionGroup;\n    this.maxDebugDepth = -1;\n    this.maxDebugDistance = -1;\n    this.maxDebugError = -1;\n    this.getDebugColor = (value, target) => {\n      target.setRGB(value, value, value);\n    };\n    this.extremeDebugDepth = -1;\n    this.extremeDebugError = -1;\n  }\n  initExtremes() {\n    // initialize the extreme values of the hierarchy\n    let maxDepth = -1;\n    this.traverse(tile => {\n      maxDepth = Math.max(maxDepth, tile.__depth);\n    });\n    let maxError = -1;\n    this.traverse(tile => {\n      maxError = Math.max(maxError, tile.geometricError);\n    });\n    this.extremeDebugDepth = maxDepth;\n    this.extremeDebugError = maxError;\n  }\n  fetchTileSet(...args) {\n    const pr = super.fetchTileSet(...args);\n    pr.then(() => {\n      // defer to after the loaded tileset has been initialized\n      Promise.resolve().then(() => {\n        this.initExtremes();\n      });\n    }).catch(() => {\n\n      // error is logged internally\n    });\n    return pr;\n  }\n  getTileInformationFromActiveObject(object) {\n    // Find which tile this scene is associated with. This is slow and\n    // intended for debug purposes only.\n    let targetTile = null;\n    const activeTiles = this.activeTiles;\n    activeTiles.forEach(tile => {\n      if (targetTile) {\n        return true;\n      }\n      const scene = tile.cached.scene;\n      if (scene) {\n        scene.traverse(c => {\n          if (c === object) {\n            targetTile = tile;\n          }\n        });\n      }\n    });\n    if (targetTile) {\n      return {\n        distanceToCamera: targetTile.__distanceFromCamera,\n        geometricError: targetTile.geometricError,\n        screenSpaceError: targetTile.__error,\n        depth: targetTile.__depth,\n        isLeaf: targetTile.__isLeaf\n      };\n    } else {\n      return null;\n    }\n  }\n  update() {\n    super.update();\n    if (!this.root) {\n      return;\n    }\n\n    // set box or sphere visibility\n    this.boxGroup.visible = this.displayBoxBounds;\n    this.sphereGroup.visible = this.displaySphereBounds;\n    this.regionGroup.visible = this.displayRegionBounds;\n\n    // get max values to use for materials\n    let maxDepth = -1;\n    if (this.maxDebugDepth === -1) {\n      maxDepth = this.extremeDebugDepth;\n    } else {\n      maxDepth = this.maxDebugDepth;\n    }\n    let maxError = -1;\n    if (this.maxDebugError === -1) {\n      maxError = this.extremeDebugError;\n    } else {\n      maxError = this.maxDebugError;\n    }\n    let maxDistance = -1;\n    if (this.maxDebugDistance === -1) {\n      maxDistance = this.root.cached.sphere.radius;\n    } else {\n      maxDistance = this.maxDebugDistance;\n    }\n    const errorTarget = this.errorTarget;\n    const colorMode = this.colorMode;\n    const visibleTiles = this.visibleTiles;\n    visibleTiles.forEach(tile => {\n      const scene = tile.cached.scene;\n\n      // create a random color per-tile\n      let h, s, l;\n      if (colorMode === RANDOM_COLOR) {\n        h = Math.random();\n        s = 0.5 + Math.random() * 0.5;\n        l = 0.375 + Math.random() * 0.25;\n      }\n      scene.traverse(c => {\n        if (colorMode === RANDOM_NODE_COLOR) {\n          h = Math.random();\n          s = 0.5 + Math.random() * 0.5;\n          l = 0.375 + Math.random() * 0.25;\n        }\n        const currMaterial = c.material;\n        if (currMaterial) {\n          // Reset the material if needed\n          const originalMaterial = c[ORIGINAL_MATERIAL];\n          if (colorMode === NONE && currMaterial !== originalMaterial) {\n            c.material.dispose();\n            c.material = c[ORIGINAL_MATERIAL];\n          } else if (colorMode !== NONE && currMaterial === originalMaterial) {\n            if (c.isPoints) {\n              const pointsMaterial = new PointsMaterial();\n              pointsMaterial.size = originalMaterial.size;\n              pointsMaterial.sizeAttenuation = originalMaterial.sizeAttenuation;\n              c.material = pointsMaterial;\n            } else {\n              c.material = new MeshStandardMaterial();\n              c.material.flatShading = true;\n            }\n          }\n          if (colorMode !== RANDOM_COLOR) {\n            delete c.material[HAS_RANDOM_COLOR];\n          }\n          if (colorMode !== RANDOM_NODE_COLOR) {\n            delete c.material[HAS_RANDOM_NODE_COLOR];\n          }\n\n          // Set the color on the basic material\n          switch (colorMode) {\n            case DEPTH:\n              {\n                const val = tile.__depth / maxDepth;\n                this.getDebugColor(val, c.material.color);\n                break;\n              }\n            case RELATIVE_DEPTH:\n              {\n                const val = tile.__depthFromRenderedParent / maxDepth;\n                this.getDebugColor(val, c.material.color);\n                break;\n              }\n            case SCREEN_ERROR:\n              {\n                const val = tile.__error / errorTarget;\n                if (val > 1.0) {\n                  c.material.color.setRGB(1.0, 0.0, 0.0);\n                } else {\n                  this.getDebugColor(val, c.material.color);\n                }\n                break;\n              }\n            case GEOMETRIC_ERROR:\n              {\n                const val = Math.min(tile.geometricError / maxError, 1);\n                this.getDebugColor(val, c.material.color);\n                break;\n              }\n            case DISTANCE:\n              {\n                // We don't update the distance if the geometric error is 0.0 so\n                // it will always be black.\n                const val = Math.min(tile.__distanceFromCamera / maxDistance, 1);\n                this.getDebugColor(val, c.material.color);\n                break;\n              }\n            case IS_LEAF:\n              {\n                if (!tile.children || tile.children.length === 0) {\n                  this.getDebugColor(1.0, c.material.color);\n                } else {\n                  this.getDebugColor(0.0, c.material.color);\n                }\n                break;\n              }\n            case RANDOM_NODE_COLOR:\n              {\n                if (!c.material[HAS_RANDOM_NODE_COLOR]) {\n                  c.material.color.setHSL(h, s, l);\n                  c.material[HAS_RANDOM_NODE_COLOR] = true;\n                }\n                break;\n              }\n            case RANDOM_COLOR:\n              {\n                if (!c.material[HAS_RANDOM_COLOR]) {\n                  c.material.color.setHSL(h, s, l);\n                  c.material[HAS_RANDOM_COLOR] = true;\n                }\n                break;\n              }\n            case CUSTOM_COLOR:\n              {\n                if (this.customColorCallback) {\n                  this.customColorCallback(tile, c);\n                } else {\n                  console.warn('DebugTilesRenderer: customColorCallback not defined');\n                }\n                break;\n              }\n          }\n        }\n      });\n    });\n  }\n  setTileVisible(tile, visible) {\n    super.setTileVisible(tile, visible);\n    const cached = tile.cached;\n    const sphereGroup = this.sphereGroup;\n    const boxGroup = this.boxGroup;\n    const regionGroup = this.regionGroup;\n    const boxHelperGroup = cached.boxHelperGroup;\n    const sphereHelper = cached.sphereHelper;\n    const regionHelper = cached.regionHelper;\n    if (!visible) {\n      if (boxHelperGroup) {\n        boxGroup.remove(boxHelperGroup);\n      }\n      if (sphereHelper) {\n        sphereGroup.remove(sphereHelper);\n      }\n      if (regionHelper) {\n        regionGroup.remove(regionHelper);\n      }\n    } else {\n      if (boxHelperGroup) {\n        boxGroup.add(boxHelperGroup);\n        boxHelperGroup.updateMatrixWorld(true);\n      }\n      if (sphereHelper) {\n        sphereGroup.add(sphereHelper);\n        sphereHelper.updateMatrixWorld(true);\n      }\n      if (regionHelper) {\n        regionGroup.add(regionHelper);\n        regionHelper.updateMatrixWorld(true);\n      }\n    }\n  }\n  parseTile(buffer, tile, extension) {\n    return super.parseTile(buffer, tile, extension).then(() => {\n      const cached = tile.cached;\n      const scene = cached.scene;\n      if (scene) {\n        if (cached.box && cached.boxTransform) {\n          const cachedBox = cached.box;\n          const cachedBoxMat = cached.boxTransform;\n\n          // Create debug bounding box\n          // In some cases the bounding box may have a scale of 0 in one dimension resulting\n          // in the NaNs in an extracted rotation so we disable matrix updates instead.\n          const boxHelperGroup = new Group();\n          boxHelperGroup.name = 'DebugTilesRenderer.boxHelperGroup';\n          boxHelperGroup.matrix.copy(cachedBoxMat);\n          boxHelperGroup.matrixAutoUpdate = false;\n          const boxHelper = new Box3Helper(cachedBox, getIndexedRandomColor(tile.__depth));\n          boxHelper.raycast = emptyRaycast;\n          boxHelperGroup.add(boxHelper);\n          cached.boxHelperGroup = boxHelperGroup;\n          if (this.visibleTiles.has(tile) && this.displayBoxBounds) {\n            this.boxGroup.add(boxHelperGroup);\n            boxHelperGroup.updateMatrixWorld(true);\n          }\n        }\n        if (cached.sphere) {\n          // Create debug bounding sphere\n          const cachedSphere = cached.sphere;\n          const sphereHelper = new SphereHelper(cachedSphere, getIndexedRandomColor(tile.__depth));\n          sphereHelper.raycast = emptyRaycast;\n          cached.sphereHelper = sphereHelper;\n          if (this.visibleTiles.has(tile) && this.displaySphereBounds) {\n            this.sphereGroup.add(sphereHelper);\n            sphereHelper.updateMatrixWorld(true);\n          }\n        }\n        if (cached.region) {\n          // Create debug bounding region\n          const cachedRegion = cached.region;\n          const regionHelper = new EllipsoidRegionLineHelper(cachedRegion, getIndexedRandomColor(tile.__depth));\n          regionHelper.raycast = emptyRaycast;\n\n          // recenter the geometry to avoid rendering artifacts\n          const sphere = new Sphere();\n          cachedRegion.getBoundingSphere(sphere);\n          regionHelper.position.copy(sphere.center);\n          sphere.center.multiplyScalar(-1);\n          regionHelper.geometry.translate(...sphere.center);\n          cached.regionHelper = regionHelper;\n          if (this.visibleTiles.has(tile) && this.displayRegionBounds) {\n            this.regionGroup.add(regionHelper);\n            regionHelper.updateMatrixWorld(true);\n          }\n        }\n\n        // Cache the original materials\n        scene.traverse(c => {\n          const material = c.material;\n          if (material) {\n            c[ORIGINAL_MATERIAL] = material;\n          }\n        });\n      }\n    });\n  }\n  disposeTile(tile) {\n    super.disposeTile(tile);\n    const cached = tile.cached;\n    if (cached.boxHelperGroup) {\n      cached.boxHelperGroup.children[0].geometry.dispose();\n      delete cached.boxHelperGroup;\n    }\n    if (cached.sphereHelper) {\n      cached.sphereHelper.geometry.dispose();\n      delete cached.sphereHelper;\n    }\n  }\n}","map":{"version":3,"names":["Box3Helper","Group","MeshStandardMaterial","PointsMaterial","Sphere","getIndexedRandomColor","TilesRenderer","SphereHelper","EllipsoidRegionLineHelper","ORIGINAL_MATERIAL","Symbol","HAS_RANDOM_COLOR","HAS_RANDOM_NODE_COLOR","emptyRaycast","NONE","SCREEN_ERROR","GEOMETRIC_ERROR","DISTANCE","DEPTH","RELATIVE_DEPTH","IS_LEAF","RANDOM_COLOR","RANDOM_NODE_COLOR","CUSTOM_COLOR","DebugTilesRenderer","constructor","args","tilesGroup","group","boxGroup","name","add","sphereGroup","regionGroup","displayBoxBounds","displaySphereBounds","displayRegionBounds","colorMode","customColorCallback","maxDebugDepth","maxDebugDistance","maxDebugError","getDebugColor","value","target","setRGB","extremeDebugDepth","extremeDebugError","initExtremes","maxDepth","traverse","tile","Math","max","__depth","maxError","geometricError","fetchTileSet","pr","then","Promise","resolve","catch","getTileInformationFromActiveObject","object","targetTile","activeTiles","forEach","scene","cached","c","distanceToCamera","__distanceFromCamera","screenSpaceError","__error","depth","isLeaf","__isLeaf","update","root","visible","maxDistance","sphere","radius","errorTarget","visibleTiles","h","s","l","random","currMaterial","material","originalMaterial","dispose","isPoints","pointsMaterial","size","sizeAttenuation","flatShading","val","color","__depthFromRenderedParent","min","children","length","setHSL","console","warn","setTileVisible","boxHelperGroup","sphereHelper","regionHelper","remove","updateMatrixWorld","parseTile","buffer","extension","box","boxTransform","cachedBox","cachedBoxMat","matrix","copy","matrixAutoUpdate","boxHelper","raycast","has","cachedSphere","region","cachedRegion","getBoundingSphere","position","center","multiplyScalar","geometry","translate","disposeTile"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/3d-tiles-renderer/src/three/DebugTilesRenderer.js"],"sourcesContent":["import { Box3Helper, Group, MeshStandardMaterial, PointsMaterial, Sphere } from 'three';\nimport { getIndexedRandomColor } from './utilities.js';\nimport { TilesRenderer } from './TilesRenderer.js';\nimport { SphereHelper } from './objects/SphereHelper.js';\nimport { EllipsoidRegionLineHelper } from './objects/EllipsoidRegionHelper.js';\n\nconst ORIGINAL_MATERIAL = Symbol( 'ORIGINAL_MATERIAL' );\nconst HAS_RANDOM_COLOR = Symbol( 'HAS_RANDOM_COLOR' );\nconst HAS_RANDOM_NODE_COLOR = Symbol( 'HAS_RANDOM_NODE_COLOR' );\n\nfunction emptyRaycast() {}\n\nexport const NONE = 0;\nexport const SCREEN_ERROR = 1;\nexport const GEOMETRIC_ERROR = 2;\nexport const DISTANCE = 3;\nexport const DEPTH = 4;\nexport const RELATIVE_DEPTH = 5;\nexport const IS_LEAF = 6;\nexport const RANDOM_COLOR = 7;\nexport const RANDOM_NODE_COLOR = 8;\nexport const CUSTOM_COLOR = 9;\n\nexport class DebugTilesRenderer extends TilesRenderer {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconst tilesGroup = this.group;\n\t\tconst boxGroup = new Group();\n\t\tboxGroup.name = 'DebugTilesRenderer.boxGroup';\n\t\ttilesGroup.add( boxGroup );\n\n\t\tconst sphereGroup = new Group();\n\t\tsphereGroup.name = 'DebugTilesRenderer.sphereGroup';\n\t\ttilesGroup.add( sphereGroup );\n\n\t\tconst regionGroup = new Group();\n\t\tregionGroup.name = 'DebugTilesRenderer.regionGroup';\n\t\ttilesGroup.add( regionGroup );\n\n\t\tthis.displayBoxBounds = false;\n\t\tthis.displaySphereBounds = false;\n\t\tthis.displayRegionBounds = false;\n\t\tthis.colorMode = NONE;\n\t\tthis.customColorCallback = null;\n\t\tthis.boxGroup = boxGroup;\n\t\tthis.sphereGroup = sphereGroup;\n\t\tthis.regionGroup = regionGroup;\n\t\tthis.maxDebugDepth = - 1;\n\t\tthis.maxDebugDistance = - 1;\n\t\tthis.maxDebugError = - 1;\n\n\t\tthis.getDebugColor = ( value, target ) => {\n\n\t\t\ttarget.setRGB( value, value, value );\n\n\t\t};\n\n\t\tthis.extremeDebugDepth = - 1;\n\t\tthis.extremeDebugError = - 1;\n\n\t}\n\n\tinitExtremes() {\n\n\t\t// initialize the extreme values of the hierarchy\n\t\tlet maxDepth = - 1;\n\t\tthis.traverse( tile => {\n\n\t\t\tmaxDepth = Math.max( maxDepth, tile.__depth );\n\n\t\t} );\n\n\t\tlet maxError = - 1;\n\t\tthis.traverse( tile => {\n\n\t\t\tmaxError = Math.max( maxError, tile.geometricError );\n\n\t\t} );\n\n\t\tthis.extremeDebugDepth = maxDepth;\n\t\tthis.extremeDebugError = maxError;\n\n\t}\n\n\tfetchTileSet( ...args ) {\n\n\t\tconst pr = super.fetchTileSet( ...args );\n\t\tpr\n\t\t\t.then( () => {\n\n\t\t\t\t// defer to after the loaded tileset has been initialized\n\t\t\t\tPromise.resolve().then( () => {\n\n\t\t\t\t\tthis.initExtremes();\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.catch( () => {\n\n\t\t\t\t// error is logged internally\n\n\t\t\t} );\n\n\t\treturn pr;\n\n\t}\n\n\tgetTileInformationFromActiveObject( object ) {\n\n\t\t// Find which tile this scene is associated with. This is slow and\n\t\t// intended for debug purposes only.\n\t\tlet targetTile = null;\n\t\tconst activeTiles = this.activeTiles;\n\t\tactiveTiles.forEach( tile => {\n\n\t\t\tif ( targetTile ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tconst scene = tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.traverse( c => {\n\n\t\t\t\t\tif ( c === object ) {\n\n\t\t\t\t\t\ttargetTile = tile;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( targetTile ) {\n\n\t\t\treturn {\n\n\t\t\t\tdistanceToCamera: targetTile.__distanceFromCamera,\n\t\t\t\tgeometricError: targetTile.geometricError,\n\t\t\t\tscreenSpaceError: targetTile.__error,\n\t\t\t\tdepth: targetTile.__depth,\n\t\t\t\tisLeaf: targetTile.__isLeaf\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tsuper.update();\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// set box or sphere visibility\n\t\tthis.boxGroup.visible = this.displayBoxBounds;\n\t\tthis.sphereGroup.visible = this.displaySphereBounds;\n\t\tthis.regionGroup.visible = this.displayRegionBounds;\n\n\t\t// get max values to use for materials\n\t\tlet maxDepth = - 1;\n\t\tif ( this.maxDebugDepth === - 1 ) {\n\n\t\t\tmaxDepth = this.extremeDebugDepth;\n\n\t\t} else {\n\n\t\t\tmaxDepth = this.maxDebugDepth;\n\n\t\t}\n\n\t\tlet maxError = - 1;\n\t\tif ( this.maxDebugError === - 1 ) {\n\n\t\t\tmaxError = this.extremeDebugError;\n\n\t\t} else {\n\n\t\t\tmaxError = this.maxDebugError;\n\n\t\t}\n\n\t\tlet maxDistance = - 1;\n\t\tif ( this.maxDebugDistance === - 1 ) {\n\n\t\t\tmaxDistance = this.root.cached.sphere.radius;\n\n\t\t} else {\n\n\t\t\tmaxDistance = this.maxDebugDistance;\n\n\t\t}\n\n\t\tconst errorTarget = this.errorTarget;\n\t\tconst colorMode = this.colorMode;\n\t\tconst visibleTiles = this.visibleTiles;\n\t\tvisibleTiles.forEach( tile => {\n\n\t\t\tconst scene = tile.cached.scene;\n\n\t\t\t// create a random color per-tile\n\t\t\tlet h, s, l;\n\t\t\tif ( colorMode === RANDOM_COLOR ) {\n\n\t\t\t\th = Math.random();\n\t\t\t\ts = 0.5 + Math.random() * 0.5;\n\t\t\t\tl = 0.375 + Math.random() * 0.25;\n\n\t\t\t}\n\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( colorMode === RANDOM_NODE_COLOR ) {\n\n\t\t\t\t\th = Math.random();\n\t\t\t\t\ts = 0.5 + Math.random() * 0.5;\n\t\t\t\t\tl = 0.375 + Math.random() * 0.25;\n\n\t\t\t\t}\n\n\t\t\t\tconst currMaterial = c.material;\n\t\t\t\tif ( currMaterial ) {\n\n\t\t\t\t\t// Reset the material if needed\n\t\t\t\t\tconst originalMaterial = c[ ORIGINAL_MATERIAL ];\n\t\t\t\t\tif ( colorMode === NONE && currMaterial !== originalMaterial ) {\n\n\t\t\t\t\t\tc.material.dispose();\n\t\t\t\t\t\tc.material = c[ ORIGINAL_MATERIAL ];\n\n\t\t\t\t\t} else if ( colorMode !== NONE && currMaterial === originalMaterial ) {\n\n\t\t\t\t\t\tif ( c.isPoints ) {\n\n\t\t\t\t\t\t\tconst pointsMaterial = new PointsMaterial();\n\t\t\t\t\t\t\tpointsMaterial.size = originalMaterial.size;\n\t\t\t\t\t\t\tpointsMaterial.sizeAttenuation = originalMaterial.sizeAttenuation;\n\t\t\t\t\t\t\tc.material = pointsMaterial;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tc.material = new MeshStandardMaterial();\n\t\t\t\t\t\t\tc.material.flatShading = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( colorMode !== RANDOM_COLOR ) {\n\n\t\t\t\t\t\tdelete c.material[ HAS_RANDOM_COLOR ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( colorMode !== RANDOM_NODE_COLOR ) {\n\n\t\t\t\t\t\tdelete c.material[ HAS_RANDOM_NODE_COLOR ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the color on the basic material\n\t\t\t\t\tswitch ( colorMode ) {\n\n\t\t\t\t\t\tcase DEPTH: {\n\n\t\t\t\t\t\t\tconst val = tile.__depth / maxDepth;\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RELATIVE_DEPTH: {\n\n\t\t\t\t\t\t\tconst val = tile.__depthFromRenderedParent / maxDepth;\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase SCREEN_ERROR: {\n\n\t\t\t\t\t\t\tconst val = tile.__error / errorTarget;\n\t\t\t\t\t\t\tif ( val > 1.0 ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setRGB( 1.0, 0.0, 0.0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase GEOMETRIC_ERROR: {\n\n\t\t\t\t\t\t\tconst val = Math.min( tile.geometricError / maxError, 1 );\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase DISTANCE: {\n\n\t\t\t\t\t\t\t// We don't update the distance if the geometric error is 0.0 so\n\t\t\t\t\t\t\t// it will always be black.\n\t\t\t\t\t\t\tconst val = Math.min( tile.__distanceFromCamera / maxDistance, 1 );\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase IS_LEAF: {\n\n\t\t\t\t\t\t\tif ( ! tile.children || tile.children.length === 0 ) {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( 1.0, c.material.color );\n\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( 0.0, c.material.color );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RANDOM_NODE_COLOR: {\n\n\t\t\t\t\t\t\tif ( ! c.material[ HAS_RANDOM_NODE_COLOR ] ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setHSL( h, s, l );\n\t\t\t\t\t\t\t\tc.material[ HAS_RANDOM_NODE_COLOR ] = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RANDOM_COLOR: {\n\n\t\t\t\t\t\t\tif ( ! c.material[ HAS_RANDOM_COLOR ] ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setHSL( h, s, l );\n\t\t\t\t\t\t\t\tc.material[ HAS_RANDOM_COLOR ] = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase CUSTOM_COLOR: {\n\n\t\t\t\t\t\t\tif ( this.customColorCallback ) {\n\n\t\t\t\t\t\t\t\tthis.customColorCallback( tile, c );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'DebugTilesRenderer: customColorCallback not defined' );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tsuper.setTileVisible( tile, visible );\n\n\t\tconst cached = tile.cached;\n\t\tconst sphereGroup = this.sphereGroup;\n\t\tconst boxGroup = this.boxGroup;\n\t\tconst regionGroup = this.regionGroup;\n\t\tconst boxHelperGroup = cached.boxHelperGroup;\n\t\tconst sphereHelper = cached.sphereHelper;\n\t\tconst regionHelper = cached.regionHelper;\n\n\t\tif ( ! visible ) {\n\n\t\t\tif ( boxHelperGroup ) {\n\n\t\t\t\tboxGroup.remove( boxHelperGroup );\n\n\t\t\t}\n\n\t\t\tif ( sphereHelper ) {\n\n\t\t\t\tsphereGroup.remove( sphereHelper );\n\n\t\t\t}\n\n\t\t\tif ( regionHelper ) {\n\n\t\t\t\tregionGroup.remove( regionHelper );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( boxHelperGroup ) {\n\n\t\t\t\tboxGroup.add( boxHelperGroup );\n\t\t\t\tboxHelperGroup.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t\tif ( sphereHelper ) {\n\n\t\t\t\tsphereGroup.add( sphereHelper );\n\t\t\t\tsphereHelper.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t\tif ( regionHelper ) {\n\n\t\t\t\tregionGroup.add( regionHelper );\n\t\t\t\tregionHelper.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tparseTile( buffer, tile, extension ) {\n\n\t\treturn super\n\t\t\t.parseTile( buffer, tile, extension )\n\t\t\t.then( () => {\n\n\t\t\t\tconst cached = tile.cached;\n\t\t\t\tconst scene = cached.scene;\n\t\t\t\tif ( scene ) {\n\n\t\t\t\t\tif ( cached.box && cached.boxTransform ) {\n\n\t\t\t\t\t\tconst cachedBox = cached.box;\n\t\t\t\t\t\tconst cachedBoxMat = cached.boxTransform;\n\n\t\t\t\t\t\t// Create debug bounding box\n\t\t\t\t\t\t// In some cases the bounding box may have a scale of 0 in one dimension resulting\n\t\t\t\t\t\t// in the NaNs in an extracted rotation so we disable matrix updates instead.\n\t\t\t\t\t\tconst boxHelperGroup = new Group();\n\t\t\t\t\t\tboxHelperGroup.name = 'DebugTilesRenderer.boxHelperGroup';\n\t\t\t\t\t\tboxHelperGroup.matrix.copy( cachedBoxMat );\n\t\t\t\t\t\tboxHelperGroup.matrixAutoUpdate = false;\n\n\t\t\t\t\t\tconst boxHelper = new Box3Helper( cachedBox, getIndexedRandomColor( tile.__depth ) );\n\t\t\t\t\t\tboxHelper.raycast = emptyRaycast;\n\t\t\t\t\t\tboxHelperGroup.add( boxHelper );\n\n\t\t\t\t\t\tcached.boxHelperGroup = boxHelperGroup;\n\n\t\t\t\t\t\tif ( this.visibleTiles.has( tile ) && this.displayBoxBounds ) {\n\n\t\t\t\t\t\t\tthis.boxGroup.add( boxHelperGroup );\n\t\t\t\t\t\t\tboxHelperGroup.updateMatrixWorld( true );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cached.sphere ) {\n\n\t\t\t\t\t\t// Create debug bounding sphere\n\t\t\t\t\t\tconst cachedSphere = cached.sphere;\n\t\t\t\t\t\tconst sphereHelper = new SphereHelper( cachedSphere, getIndexedRandomColor( tile.__depth ) );\n\t\t\t\t\t\tsphereHelper.raycast = emptyRaycast;\n\t\t\t\t\t\tcached.sphereHelper = sphereHelper;\n\n\t\t\t\t\t\tif ( this.visibleTiles.has( tile ) && this.displaySphereBounds ) {\n\n\t\t\t\t\t\t\tthis.sphereGroup.add( sphereHelper );\n\t\t\t\t\t\t\tsphereHelper.updateMatrixWorld( true );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cached.region ) {\n\n\t\t\t\t\t\t// Create debug bounding region\n\t\t\t\t\t\tconst cachedRegion = cached.region;\n\t\t\t\t\t\tconst regionHelper = new EllipsoidRegionLineHelper( cachedRegion, getIndexedRandomColor( tile.__depth ) );\n\t\t\t\t\t\tregionHelper.raycast = emptyRaycast;\n\n\t\t\t\t\t\t// recenter the geometry to avoid rendering artifacts\n\t\t\t\t\t\tconst sphere = new Sphere();\n\t\t\t\t\t\tcachedRegion.getBoundingSphere( sphere );\n\t\t\t\t\t\tregionHelper.position.copy( sphere.center );\n\n\t\t\t\t\t\tsphere.center.multiplyScalar( - 1 );\n\t\t\t\t\t\tregionHelper.geometry.translate( ...sphere.center );\n\n\t\t\t\t\t\tcached.regionHelper = regionHelper;\n\n\t\t\t\t\t\tif ( this.visibleTiles.has( tile ) && this.displayRegionBounds ) {\n\n\t\t\t\t\t\t\tthis.regionGroup.add( regionHelper );\n\t\t\t\t\t\t\tregionHelper.updateMatrixWorld( true );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Cache the original materials\n\t\t\t\t\tscene.traverse( c => {\n\n\t\t\t\t\t\tconst material = c.material;\n\t\t\t\t\t\tif ( material ) {\n\n\t\t\t\t\t\t\tc[ ORIGINAL_MATERIAL ] = material;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tsuper.disposeTile( tile );\n\n\t\tconst cached = tile.cached;\n\t\tif ( cached.boxHelperGroup ) {\n\n\t\t\tcached.boxHelperGroup.children[ 0 ].geometry.dispose();\n\t\t\tdelete cached.boxHelperGroup;\n\n\t\t}\n\n\t\tif ( cached.sphereHelper ) {\n\n\t\t\tcached.sphereHelper.geometry.dispose();\n\t\t\tdelete cached.sphereHelper;\n\n\t\t}\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { rectToClientRect as t, computePosition as e } from \"@floating-ui/core\";\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from \"@floating-ui/core\";\nfunction n(t) {\n  var e;\n  return (null == (e = t.ownerDocument) ? void 0 : e.defaultView) || window;\n}\nfunction o(t) {\n  return n(t).getComputedStyle(t);\n}\nfunction i(t) {\n  return f(t) ? (t.nodeName || \"\").toLowerCase() : \"\";\n}\nlet r;\nfunction l() {\n  if (r) return r;\n  const t = navigator.userAgentData;\n  return t && Array.isArray(t.brands) ? (r = t.brands.map(t => t.brand + \"/\" + t.version).join(\" \"), r) : navigator.userAgent;\n}\nfunction c(t) {\n  return t instanceof n(t).HTMLElement;\n}\nfunction s(t) {\n  return t instanceof n(t).Element;\n}\nfunction f(t) {\n  return t instanceof n(t).Node;\n}\nfunction u(t) {\n  if (\"undefined\" == typeof ShadowRoot) return !1;\n  return t instanceof n(t).ShadowRoot || t instanceof ShadowRoot;\n}\nfunction a(t) {\n  const {\n    overflow: e,\n    overflowX: n,\n    overflowY: i,\n    display: r\n  } = o(t);\n  return /auto|scroll|overlay|hidden|clip/.test(e + i + n) && ![\"inline\", \"contents\"].includes(r);\n}\nfunction d(t) {\n  return [\"table\", \"td\", \"th\"].includes(i(t));\n}\nfunction h(t) {\n  const e = /firefox/i.test(l()),\n    n = o(t),\n    i = n.backdropFilter || n.WebkitBackdropFilter;\n  return \"none\" !== n.transform || \"none\" !== n.perspective || !!i && \"none\" !== i || e && \"filter\" === n.willChange || e && !!n.filter && \"none\" !== n.filter || [\"transform\", \"perspective\"].some(t => n.willChange.includes(t)) || [\"paint\", \"layout\", \"strict\", \"content\"].some(t => {\n    const e = n.contain;\n    return null != e && e.includes(t);\n  });\n}\nfunction p() {\n  return !/^((?!chrome|android).)*safari/i.test(l());\n}\nfunction g(t) {\n  return [\"html\", \"body\", \"#document\"].includes(i(t));\n}\nconst m = Math.min,\n  y = Math.max,\n  x = Math.round;\nfunction w(t) {\n  const e = o(t);\n  let n = parseFloat(e.width),\n    i = parseFloat(e.height);\n  const r = t.offsetWidth,\n    l = t.offsetHeight,\n    c = x(n) !== r || x(i) !== l;\n  return c && (n = r, i = l), {\n    width: n,\n    height: i,\n    fallback: c\n  };\n}\nfunction v(t) {\n  return s(t) ? t : t.contextElement;\n}\nconst b = {\n  x: 1,\n  y: 1\n};\nfunction L(t) {\n  const e = v(t);\n  if (!c(e)) return b;\n  const n = e.getBoundingClientRect(),\n    {\n      width: o,\n      height: i,\n      fallback: r\n    } = w(e);\n  let l = (r ? x(n.width) : n.width) / o,\n    s = (r ? x(n.height) : n.height) / i;\n  return l && Number.isFinite(l) || (l = 1), s && Number.isFinite(s) || (s = 1), {\n    x: l,\n    y: s\n  };\n}\nfunction E(t, e, o, i) {\n  var r, l;\n  void 0 === e && (e = !1), void 0 === o && (o = !1);\n  const c = t.getBoundingClientRect(),\n    f = v(t);\n  let u = b;\n  e && (i ? s(i) && (u = L(i)) : u = L(t));\n  const a = f ? n(f) : window,\n    d = !p() && o;\n  let h = (c.left + (d && (null == (r = a.visualViewport) ? void 0 : r.offsetLeft) || 0)) / u.x,\n    g = (c.top + (d && (null == (l = a.visualViewport) ? void 0 : l.offsetTop) || 0)) / u.y,\n    m = c.width / u.x,\n    y = c.height / u.y;\n  if (f) {\n    const t = n(f),\n      e = i && s(i) ? n(i) : i;\n    let o = t.frameElement;\n    for (; o && i && e !== t;) {\n      const t = L(o),\n        e = o.getBoundingClientRect(),\n        i = getComputedStyle(o);\n      e.x += (o.clientLeft + parseFloat(i.paddingLeft)) * t.x, e.y += (o.clientTop + parseFloat(i.paddingTop)) * t.y, h *= t.x, g *= t.y, m *= t.x, y *= t.y, h += e.x, g += e.y, o = n(o).frameElement;\n    }\n  }\n  return {\n    width: m,\n    height: y,\n    top: g,\n    right: h + m,\n    bottom: g + y,\n    left: h,\n    x: h,\n    y: g\n  };\n}\nfunction R(t) {\n  return ((f(t) ? t.ownerDocument : t.document) || window.document).documentElement;\n}\nfunction T(t) {\n  return s(t) ? {\n    scrollLeft: t.scrollLeft,\n    scrollTop: t.scrollTop\n  } : {\n    scrollLeft: t.pageXOffset,\n    scrollTop: t.pageYOffset\n  };\n}\nfunction C(t) {\n  return E(R(t)).left + T(t).scrollLeft;\n}\nfunction F(t, e, n) {\n  const o = c(e),\n    r = R(e),\n    l = E(t, !0, \"fixed\" === n, e);\n  let s = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const f = {\n    x: 0,\n    y: 0\n  };\n  if (o || !o && \"fixed\" !== n) if ((\"body\" !== i(e) || a(r)) && (s = T(e)), c(e)) {\n    const t = E(e, !0);\n    f.x = t.x + e.clientLeft, f.y = t.y + e.clientTop;\n  } else r && (f.x = C(r));\n  return {\n    x: l.left + s.scrollLeft - f.x,\n    y: l.top + s.scrollTop - f.y,\n    width: l.width,\n    height: l.height\n  };\n}\nfunction W(t) {\n  if (\"html\" === i(t)) return t;\n  const e = t.assignedSlot || t.parentNode || (u(t) ? t.host : null) || R(t);\n  return u(e) ? e.host : e;\n}\nfunction D(t) {\n  return c(t) && \"fixed\" !== o(t).position ? t.offsetParent : null;\n}\nfunction S(t) {\n  const e = n(t);\n  let r = D(t);\n  for (; r && d(r) && \"static\" === o(r).position;) r = D(r);\n  return r && (\"html\" === i(r) || \"body\" === i(r) && \"static\" === o(r).position && !h(r)) ? e : r || function (t) {\n    let e = W(t);\n    for (; c(e) && !g(e);) {\n      if (h(e)) return e;\n      e = W(e);\n    }\n    return null;\n  }(t) || e;\n}\nfunction A(t) {\n  const e = W(t);\n  return g(e) ? t.ownerDocument.body : c(e) && a(e) ? e : A(e);\n}\nfunction H(t, e) {\n  var o;\n  void 0 === e && (e = []);\n  const i = A(t),\n    r = i === (null == (o = t.ownerDocument) ? void 0 : o.body),\n    l = n(i);\n  return r ? e.concat(l, l.visualViewport || [], a(i) ? i : []) : e.concat(i, H(i));\n}\nfunction O(e, i, r) {\n  return \"viewport\" === i ? t(function (t, e) {\n    const o = n(t),\n      i = R(t),\n      r = o.visualViewport;\n    let l = i.clientWidth,\n      c = i.clientHeight,\n      s = 0,\n      f = 0;\n    if (r) {\n      l = r.width, c = r.height;\n      const t = p();\n      (t || !t && \"fixed\" === e) && (s = r.offsetLeft, f = r.offsetTop);\n    }\n    return {\n      width: l,\n      height: c,\n      x: s,\n      y: f\n    };\n  }(e, r)) : s(i) ? function (t, e) {\n    const n = E(t, !0, \"fixed\" === e),\n      o = n.top + t.clientTop,\n      i = n.left + t.clientLeft,\n      r = c(t) ? L(t) : {\n        x: 1,\n        y: 1\n      },\n      l = t.clientWidth * r.x,\n      s = t.clientHeight * r.y,\n      f = i * r.x,\n      u = o * r.y;\n    return {\n      top: u,\n      left: f,\n      right: f + l,\n      bottom: u + s,\n      x: f,\n      y: u,\n      width: l,\n      height: s\n    };\n  }(i, r) : t(function (t) {\n    var e;\n    const n = R(t),\n      i = T(t),\n      r = null == (e = t.ownerDocument) ? void 0 : e.body,\n      l = y(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0),\n      c = y(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0);\n    let s = -i.scrollLeft + C(t);\n    const f = -i.scrollTop;\n    return \"rtl\" === o(r || n).direction && (s += y(n.clientWidth, r ? r.clientWidth : 0) - l), {\n      width: l,\n      height: c,\n      x: s,\n      y: f\n    };\n  }(R(e)));\n}\nconst P = {\n  getClippingRect: function (t) {\n    let {\n      element: e,\n      boundary: n,\n      rootBoundary: r,\n      strategy: l\n    } = t;\n    const c = \"clippingAncestors\" === n ? function (t, e) {\n        const n = e.get(t);\n        if (n) return n;\n        let r = H(t).filter(t => s(t) && \"body\" !== i(t)),\n          l = null;\n        const c = \"fixed\" === o(t).position;\n        let f = c ? W(t) : t;\n        for (; s(f) && !g(f);) {\n          const t = o(f),\n            e = h(f);\n          (c ? e || l : e || \"static\" !== t.position || !l || ![\"absolute\", \"fixed\"].includes(l.position)) ? l = t : r = r.filter(t => t !== f), f = W(f);\n        }\n        return e.set(t, r), r;\n      }(e, this._c) : [].concat(n),\n      f = [...c, r],\n      u = f[0],\n      a = f.reduce((t, n) => {\n        const o = O(e, n, l);\n        return t.top = y(o.top, t.top), t.right = m(o.right, t.right), t.bottom = m(o.bottom, t.bottom), t.left = y(o.left, t.left), t;\n      }, O(e, u, l));\n    return {\n      width: a.right - a.left,\n      height: a.bottom - a.top,\n      x: a.left,\n      y: a.top\n    };\n  },\n  convertOffsetParentRelativeRectToViewportRelativeRect: function (t) {\n    let {\n      rect: e,\n      offsetParent: n,\n      strategy: o\n    } = t;\n    const r = c(n),\n      l = R(n);\n    if (n === l) return e;\n    let s = {\n        scrollLeft: 0,\n        scrollTop: 0\n      },\n      f = {\n        x: 1,\n        y: 1\n      };\n    const u = {\n      x: 0,\n      y: 0\n    };\n    if ((r || !r && \"fixed\" !== o) && ((\"body\" !== i(n) || a(l)) && (s = T(n)), c(n))) {\n      const t = E(n);\n      f = L(n), u.x = t.x + n.clientLeft, u.y = t.y + n.clientTop;\n    }\n    return {\n      width: e.width * f.x,\n      height: e.height * f.y,\n      x: e.x * f.x - s.scrollLeft * f.x + u.x,\n      y: e.y * f.y - s.scrollTop * f.y + u.y\n    };\n  },\n  isElement: s,\n  getDimensions: function (t) {\n    return w(t);\n  },\n  getOffsetParent: S,\n  getDocumentElement: R,\n  getScale: L,\n  async getElementRects(t) {\n    let {\n      reference: e,\n      floating: n,\n      strategy: o\n    } = t;\n    const i = this.getOffsetParent || S,\n      r = this.getDimensions;\n    return {\n      reference: F(e, await i(n), o),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await r(n))\n      }\n    };\n  },\n  getClientRects: t => Array.from(t.getClientRects()),\n  isRTL: t => \"rtl\" === o(t).direction\n};\nfunction z(t, e, n, o) {\n  void 0 === o && (o = {});\n  const {\n      ancestorScroll: i = !0,\n      ancestorResize: r = !0,\n      elementResize: l = !0,\n      animationFrame: c = !1\n    } = o,\n    f = i && !c,\n    u = f || r ? [...(s(t) ? H(t) : t.contextElement ? H(t.contextElement) : []), ...H(e)] : [];\n  u.forEach(t => {\n    f && t.addEventListener(\"scroll\", n, {\n      passive: !0\n    }), r && t.addEventListener(\"resize\", n);\n  });\n  let a,\n    d = null;\n  if (l) {\n    let o = !0;\n    d = new ResizeObserver(() => {\n      o || n(), o = !1;\n    }), s(t) && !c && d.observe(t), s(t) || !t.contextElement || c || d.observe(t.contextElement), d.observe(e);\n  }\n  let h = c ? E(t) : null;\n  return c && function e() {\n    const o = E(t);\n    !h || o.x === h.x && o.y === h.y && o.width === h.width && o.height === h.height || n();\n    h = o, a = requestAnimationFrame(e);\n  }(), n(), () => {\n    var t;\n    u.forEach(t => {\n      f && t.removeEventListener(\"scroll\", n), r && t.removeEventListener(\"resize\", n);\n    }), null == (t = d) || t.disconnect(), d = null, c && cancelAnimationFrame(a);\n  };\n}\nconst V = (t, n, o) => {\n  const i = new Map(),\n    r = {\n      platform: P,\n      ...o\n    },\n    l = {\n      ...r.platform,\n      _c: i\n    };\n  return e(t, n, {\n    ...r,\n    platform: l\n  });\n};\nexport { z as autoUpdate, V as computePosition, H as getOverflowAncestors, P as platform };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { TilesRendererBase } from '../base/TilesRendererBase.js';\nimport { WGS84_HEIGHT, WGS84_RADIUS } from '../base/constants.js';\nimport { B3DMLoader } from './B3DMLoader.js';\nimport { PNTSLoader } from './PNTSLoader.js';\nimport { I3DMLoader } from './I3DMLoader.js';\nimport { CMPTLoader } from './CMPTLoader.js';\nimport { GLTFExtensionLoader } from './GLTFExtensionLoader.js';\nimport { TilesGroup } from './TilesGroup.js';\nimport { EllipsoidRegion } from './math/EllipsoidRegion.js';\nimport { Matrix4, Box3, Sphere, Vector3, Vector2, Frustum, LoadingManager } from 'three';\nimport { raycastTraverse, raycastTraverseFirstHit } from './raycastTraverse.js';\nimport { readMagicBytes } from '../utilities/readMagicBytes.js';\nconst INITIAL_FRUSTUM_CULLED = Symbol('INITIAL_FRUSTUM_CULLED');\nconst tempMat = new Matrix4();\nconst tempMat2 = new Matrix4();\nconst tempVector = new Vector3();\nconst vecX = new Vector3();\nconst vecY = new Vector3();\nconst vecZ = new Vector3();\nconst X_AXIS = new Vector3(1, 0, 0);\nconst Y_AXIS = new Vector3(0, 1, 0);\nfunction updateFrustumCulled(object, toInitialValue) {\n  object.traverse(c => {\n    c.frustumCulled = c[INITIAL_FRUSTUM_CULLED] && toInitialValue;\n  });\n}\nexport class TilesRenderer extends TilesRendererBase {\n  get autoDisableRendererCulling() {\n    return this._autoDisableRendererCulling;\n  }\n  set autoDisableRendererCulling(value) {\n    if (this._autoDisableRendererCulling !== value) {\n      super._autoDisableRendererCulling = value;\n      this.forEachLoadedModel(scene => {\n        updateFrustumCulled(scene, !value);\n      });\n    }\n  }\n  constructor(...args) {\n    super(...args);\n    this.group = new TilesGroup(this);\n    this.cameras = [];\n    this.cameraMap = new Map();\n    this.cameraInfo = [];\n    this.activeTiles = new Set();\n    this.visibleTiles = new Set();\n    this._autoDisableRendererCulling = true;\n    this.optimizeRaycast = true;\n    this.onLoadTileSet = null;\n    this.onLoadModel = null;\n    this.onDisposeModel = null;\n    this.onTileVisibilityChange = null;\n    const manager = new LoadingManager();\n    manager.setURLModifier(url => {\n      if (this.preprocessURL) {\n        return this.preprocessURL(url);\n      } else {\n        return url;\n      }\n    });\n    this.manager = manager;\n\n    // Setting up the override raycasting function to be used by\n    // 3D objects created by this renderer\n    const tilesRenderer = this;\n    this._overridenRaycast = function (raycaster, intersects) {\n      if (!tilesRenderer.optimizeRaycast) {\n        Object.getPrototypeOf(this).raycast.call(this, raycaster, intersects);\n      }\n    };\n  }\n\n  /* Public API */\n  getBounds(box) {\n    if (!this.root) {\n      return false;\n    }\n    const cached = this.root.cached;\n    const boundingBox = cached.box;\n    const obbMat = cached.boxTransform;\n    if (boundingBox) {\n      box.copy(boundingBox);\n      box.applyMatrix4(obbMat);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  getOrientedBounds(box, matrix) {\n    if (!this.root) {\n      return false;\n    }\n    const cached = this.root.cached;\n    const boundingBox = cached.box;\n    const obbMat = cached.boxTransform;\n    if (boundingBox) {\n      box.copy(boundingBox);\n      matrix.copy(obbMat);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  getBoundingSphere(sphere) {\n    if (!this.root) {\n      return false;\n    }\n    const boundingSphere = this.root.cached.sphere;\n    if (boundingSphere) {\n      sphere.copy(boundingSphere);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  forEachLoadedModel(callback) {\n    this.traverse(tile => {\n      const scene = tile.cached.scene;\n      if (scene) {\n        callback(scene, tile);\n      }\n    });\n  }\n  raycast(raycaster, intersects) {\n    if (!this.root) {\n      return;\n    }\n    if (raycaster.firstHitOnly) {\n      const hit = raycastTraverseFirstHit(this.root, this.group, this.activeTiles, raycaster);\n      if (hit) {\n        intersects.push(hit);\n      }\n    } else {\n      raycastTraverse(this.root, this.group, this.activeTiles, raycaster, intersects);\n    }\n  }\n  hasCamera(camera) {\n    return this.cameraMap.has(camera);\n  }\n  setCamera(camera) {\n    const cameras = this.cameras;\n    const cameraMap = this.cameraMap;\n    if (!cameraMap.has(camera)) {\n      cameraMap.set(camera, new Vector2());\n      cameras.push(camera);\n      return true;\n    }\n    return false;\n  }\n  setResolution(camera, xOrVec, y) {\n    const cameraMap = this.cameraMap;\n    if (!cameraMap.has(camera)) {\n      return false;\n    }\n    if (xOrVec instanceof Vector2) {\n      cameraMap.get(camera).copy(xOrVec);\n    } else {\n      cameraMap.get(camera).set(xOrVec, y);\n    }\n    return true;\n  }\n  setResolutionFromRenderer(camera, renderer) {\n    const cameraMap = this.cameraMap;\n    if (!cameraMap.has(camera)) {\n      return false;\n    }\n    const resolution = cameraMap.get(camera);\n    renderer.getSize(resolution);\n    resolution.multiplyScalar(renderer.getPixelRatio());\n    return true;\n  }\n  deleteCamera(camera) {\n    const cameras = this.cameras;\n    const cameraMap = this.cameraMap;\n    if (cameraMap.has(camera)) {\n      const index = cameras.indexOf(camera);\n      cameras.splice(index, 1);\n      cameraMap.delete(camera);\n      return true;\n    }\n    return false;\n  }\n\n  /* Overriden */\n  fetchTileSet(url, ...rest) {\n    const pr = super.fetchTileSet(url, ...rest);\n    pr.then(json => {\n      if (this.onLoadTileSet) {\n        // Push this onto the end of the event stack to ensure this runs\n        // after the base renderer has placed the provided json where it\n        // needs to be placed and is ready for an update.\n        Promise.resolve().then(() => {\n          this.onLoadTileSet(json, url);\n        });\n      }\n    });\n    return pr;\n  }\n  update() {\n    const group = this.group;\n    const cameras = this.cameras;\n    const cameraMap = this.cameraMap;\n    const cameraInfo = this.cameraInfo;\n    if (cameras.length === 0) {\n      console.warn('TilesRenderer: no cameras defined. Cannot update 3d tiles.');\n      return;\n    }\n\n    // automatically scale the array of cameraInfo to match the cameras\n    while (cameraInfo.length > cameras.length) {\n      cameraInfo.pop();\n    }\n    while (cameraInfo.length < cameras.length) {\n      cameraInfo.push({\n        frustum: new Frustum(),\n        isOrthographic: false,\n        sseDenominator: -1,\n        // used if isOrthographic:false\n        position: new Vector3(),\n        invScale: -1,\n        pixelSize: 0 // used if isOrthographic:true\n      });\n    }\n\n    // extract scale of group container\n    tempMat2.copy(group.matrixWorld).invert();\n    tempVector.setFromMatrixScale(tempMat2);\n    const invScale = tempVector.x;\n    if (Math.abs(Math.max(tempVector.x - tempVector.y, tempVector.x - tempVector.z)) > 1e-6) {\n      console.warn('ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.');\n    }\n\n    // store the camera cameraInfo in the 3d tiles root frame\n    for (let i = 0, l = cameraInfo.length; i < l; i++) {\n      const camera = cameras[i];\n      const info = cameraInfo[i];\n      const frustum = info.frustum;\n      const position = info.position;\n      const resolution = cameraMap.get(camera);\n      if (resolution.width === 0 || resolution.height === 0) {\n        console.warn('TilesRenderer: resolution for camera error calculation is not set.');\n      }\n\n      // Read the calculated projection matrix directly to support custom Camera implementations\n      const projection = camera.projectionMatrix.elements;\n\n      // The last element of the projection matrix is 1 for orthographic, 0 for perspective\n      info.isOrthographic = projection[15] === 1;\n      if (info.isOrthographic) {\n        // See OrthographicCamera.updateProjectionMatrix and Matrix4.makeOrthographic:\n        // the view width and height are used to populate matrix elements 0 and 5.\n        const w = 2 / projection[0];\n        const h = 2 / projection[5];\n        info.pixelSize = Math.max(h / resolution.height, w / resolution.width);\n      } else {\n        // See PerspectiveCamera.updateProjectionMatrix and Matrix4.makePerspective:\n        // the vertical FOV is used to populate matrix element 5.\n        info.sseDenominator = 2 / projection[5] / resolution.height;\n      }\n      info.invScale = invScale;\n\n      // get frustum in group root frame\n      tempMat.copy(group.matrixWorld);\n      tempMat.premultiply(camera.matrixWorldInverse);\n      tempMat.premultiply(camera.projectionMatrix);\n      frustum.setFromProjectionMatrix(tempMat);\n\n      // get transform position in group root frame\n      position.set(0, 0, 0);\n      position.applyMatrix4(camera.matrixWorld);\n      position.applyMatrix4(tempMat2);\n    }\n    super.update();\n  }\n  preprocessNode(tile, parentTile, tileSetDir) {\n    super.preprocessNode(tile, parentTile, tileSetDir);\n    const transform = new Matrix4();\n    if (tile.transform) {\n      const transformArr = tile.transform;\n      for (let i = 0; i < 16; i++) {\n        transform.elements[i] = transformArr[i];\n      }\n    } else {\n      transform.identity();\n    }\n    if (parentTile) {\n      transform.premultiply(parentTile.cached.transform);\n    }\n    const transformInverse = new Matrix4().copy(transform).invert();\n    let box = null;\n    let boxTransform = null;\n    let boxTransformInverse = null;\n    if ('box' in tile.boundingVolume) {\n      const data = tile.boundingVolume.box;\n      box = new Box3();\n      boxTransform = new Matrix4();\n      boxTransformInverse = new Matrix4();\n\n      // get the extents of the bounds in each axis\n      vecX.set(data[3], data[4], data[5]);\n      vecY.set(data[6], data[7], data[8]);\n      vecZ.set(data[9], data[10], data[11]);\n      const scaleX = vecX.length();\n      const scaleY = vecY.length();\n      const scaleZ = vecZ.length();\n      vecX.normalize();\n      vecY.normalize();\n      vecZ.normalize();\n\n      // handle the case where the box has a dimension of 0 in one axis\n      if (scaleX === 0) {\n        vecX.crossVectors(vecY, vecZ);\n      }\n      if (scaleY === 0) {\n        vecY.crossVectors(vecX, vecZ);\n      }\n      if (scaleZ === 0) {\n        vecZ.crossVectors(vecX, vecY);\n      }\n\n      // create the oriented frame that the box exists in\n      boxTransform.set(vecX.x, vecY.x, vecZ.x, data[0], vecX.y, vecY.y, vecZ.y, data[1], vecX.z, vecY.z, vecZ.z, data[2], 0, 0, 0, 1);\n      boxTransform.premultiply(transform);\n      boxTransformInverse.copy(boxTransform).invert();\n\n      // scale the box by the extents\n      box.min.set(-scaleX, -scaleY, -scaleZ);\n      box.max.set(scaleX, scaleY, scaleZ);\n    }\n    let sphere = null;\n    if ('sphere' in tile.boundingVolume) {\n      const data = tile.boundingVolume.sphere;\n      sphere = new Sphere();\n      sphere.center.set(data[0], data[1], data[2]);\n      sphere.radius = data[3];\n      sphere.applyMatrix4(transform);\n    } else if ('box' in tile.boundingVolume) {\n      const data = tile.boundingVolume.box;\n      sphere = new Sphere();\n      box.getBoundingSphere(sphere);\n      sphere.center.set(data[0], data[1], data[2]);\n      sphere.applyMatrix4(transform);\n    }\n    let region = null;\n    if ('region' in tile.boundingVolume) {\n      const data = tile.boundingVolume.region;\n      const [west, south, east, north, minHeight, maxHeight] = data;\n      region = new EllipsoidRegion(WGS84_RADIUS, WGS84_RADIUS, WGS84_HEIGHT, south, north, west, east, minHeight, maxHeight);\n      if (sphere === null) {\n        sphere = new Sphere();\n        region.getBoundingSphere(sphere);\n      }\n      if (box === null) {\n        box = new Box3();\n        boxTransform = new Matrix4();\n        boxTransformInverse = new Matrix4();\n        region.getBoundingBox(box, boxTransform);\n        boxTransformInverse.copy(boxTransform).invert();\n      }\n    }\n    tile.cached = {\n      loadIndex: 0,\n      transform,\n      transformInverse,\n      active: false,\n      inFrustum: [],\n      box,\n      boxTransform,\n      boxTransformInverse,\n      sphere,\n      region,\n      scene: null,\n      geometry: null,\n      material: null\n    };\n  }\n  parseTile(buffer, tile, extension) {\n    tile._loadIndex = tile._loadIndex || 0;\n    tile._loadIndex++;\n    const uri = tile.content.uri;\n    const uriSplits = uri.split(/[\\\\\\/]/g);\n    uriSplits.pop();\n    const workingPath = uriSplits.join('/');\n    const fetchOptions = this.fetchOptions;\n    const manager = this.manager;\n    const loadIndex = tile._loadIndex;\n    let promise = null;\n    const upAxis = this.rootTileSet.asset && this.rootTileSet.asset.gltfUpAxis || 'y';\n    const cached = tile.cached;\n    const cachedTransform = cached.transform;\n    switch (upAxis.toLowerCase()) {\n      case 'x':\n        tempMat.makeRotationAxis(Y_AXIS, -Math.PI / 2);\n        break;\n      case 'y':\n        tempMat.makeRotationAxis(X_AXIS, Math.PI / 2);\n        break;\n      case 'z':\n        tempMat.identity();\n        break;\n    }\n    const fileType = readMagicBytes(buffer) || extension;\n    switch (fileType) {\n      case 'b3dm':\n        {\n          const loader = new B3DMLoader(manager);\n          loader.workingPath = workingPath;\n          loader.fetchOptions = fetchOptions;\n          loader.adjustmentTransform.copy(tempMat);\n          promise = loader.parse(buffer).then(res => res.scene);\n          break;\n        }\n      case 'pnts':\n        {\n          const loader = new PNTSLoader(manager);\n          loader.workingPath = workingPath;\n          loader.fetchOptions = fetchOptions;\n          promise = loader.parse(buffer).then(res => res.scene);\n          break;\n        }\n      case 'i3dm':\n        {\n          const loader = new I3DMLoader(manager);\n          loader.workingPath = workingPath;\n          loader.fetchOptions = fetchOptions;\n          loader.adjustmentTransform.copy(tempMat);\n          promise = loader.parse(buffer).then(res => res.scene);\n          break;\n        }\n      case 'cmpt':\n        {\n          const loader = new CMPTLoader(manager);\n          loader.workingPath = workingPath;\n          loader.fetchOptions = fetchOptions;\n          loader.adjustmentTransform.copy(tempMat);\n          promise = loader.parse(buffer).then(res => res.scene);\n          break;\n        }\n\n      // 3DTILES_content_gltf\n      case 'gltf':\n      case 'glb':\n        const loader = new GLTFExtensionLoader(manager);\n        loader.workingPath = workingPath;\n        loader.fetchOptions = fetchOptions;\n        promise = loader.parse(buffer).then(res => res.scene);\n        break;\n      default:\n        console.warn(`TilesRenderer: Content type \"${fileType}\" not supported.`);\n        promise = Promise.resolve(null);\n        break;\n    }\n    return promise.then(scene => {\n      if (tile._loadIndex !== loadIndex) {\n        return;\n      }\n      // ensure the matrix is up to date in case the scene has a transform applied\n      scene.updateMatrix();\n\n      // apply the local up-axis correction rotation\n      // GLTFLoader seems to never set a transformation on the root scene object so\n      // any transformations applied to it can be assumed to be applied after load\n      // (such as applying RTC_CENTER) meaning they should happen _after_ the z-up\n      // rotation fix which is why \"multiply\" happens here.\n      if (fileType === 'glb' || fileType === 'gltf') {\n        scene.matrix.multiply(tempMat);\n      }\n      scene.matrix.premultiply(cachedTransform);\n      scene.matrix.decompose(scene.position, scene.quaternion, scene.scale);\n      scene.traverse(c => {\n        c[INITIAL_FRUSTUM_CULLED] = c.frustumCulled;\n      });\n      updateFrustumCulled(scene, !this.autoDisableRendererCulling);\n      cached.scene = scene;\n\n      // We handle raycasting in a custom way so remove it from here\n      scene.traverse(c => {\n        c.raycast = this._overridenRaycast;\n      });\n      const materials = [];\n      const geometry = [];\n      const textures = [];\n      scene.traverse(c => {\n        if (c.geometry) {\n          geometry.push(c.geometry);\n        }\n        if (c.material) {\n          const material = c.material;\n          materials.push(c.material);\n          for (const key in material) {\n            const value = material[key];\n            if (value && value.isTexture) {\n              textures.push(value);\n            }\n          }\n        }\n      });\n      cached.materials = materials;\n      cached.geometry = geometry;\n      cached.textures = textures;\n      if (this.onLoadModel) {\n        this.onLoadModel(scene, tile);\n      }\n    });\n  }\n  disposeTile(tile) {\n    // This could get called before the tile has finished downloading\n    const cached = tile.cached;\n    if (cached.scene) {\n      const materials = cached.materials;\n      const geometry = cached.geometry;\n      const textures = cached.textures;\n      const parent = cached.scene.parent;\n      for (let i = 0, l = geometry.length; i < l; i++) {\n        geometry[i].dispose();\n      }\n      for (let i = 0, l = materials.length; i < l; i++) {\n        materials[i].dispose();\n      }\n      for (let i = 0, l = textures.length; i < l; i++) {\n        const texture = textures[i];\n        texture.dispose();\n      }\n      if (parent) {\n        parent.remove(cached.scene);\n      }\n      if (this.onDisposeModel) {\n        this.onDisposeModel(cached.scene, tile);\n      }\n      cached.scene = null;\n      cached.materials = null;\n      cached.textures = null;\n      cached.geometry = null;\n    }\n    this.activeTiles.delete(tile);\n    this.visibleTiles.delete(tile);\n    tile._loadIndex++;\n  }\n  setTileVisible(tile, visible) {\n    const scene = tile.cached.scene;\n    const visibleTiles = this.visibleTiles;\n    const group = this.group;\n    if (visible) {\n      group.add(scene);\n      visibleTiles.add(tile);\n      scene.updateMatrixWorld(true);\n    } else {\n      group.remove(scene);\n      visibleTiles.delete(tile);\n    }\n    if (this.onTileVisibilityChange) {\n      this.onTileVisibilityChange(scene, tile, visible);\n    }\n  }\n  setTileActive(tile, active) {\n    const activeTiles = this.activeTiles;\n    if (active) {\n      activeTiles.add(tile);\n    } else {\n      activeTiles.delete(tile);\n    }\n  }\n  calculateError(tile) {\n    const cached = tile.cached;\n    const inFrustum = cached.inFrustum;\n    const cameras = this.cameras;\n    const cameraInfo = this.cameraInfo;\n\n    // TODO: Use the content bounding volume here?\n    // TODO: We should use the largest distance to the tile between\n    // all available bounding volume types.\n    const boundingSphere = cached.sphere;\n    const boundingBox = cached.box;\n    const boxTransformInverse = cached.boxTransformInverse;\n    const transformInverse = cached.transformInverse;\n    const useBox = boundingBox && boxTransformInverse;\n    let maxError = -Infinity;\n    let minDistance = Infinity;\n    for (let i = 0, l = cameras.length; i < l; i++) {\n      if (!inFrustum[i]) {\n        continue;\n      }\n\n      // transform camera position into local frame of the tile bounding box\n      const info = cameraInfo[i];\n      const invScale = info.invScale;\n      let error;\n      if (info.isOrthographic) {\n        const pixelSize = info.pixelSize;\n        error = tile.geometricError / (pixelSize * invScale);\n      } else {\n        tempVector.copy(info.position);\n        let distance;\n        if (useBox) {\n          tempVector.applyMatrix4(boxTransformInverse);\n          distance = boundingBox.distanceToPoint(tempVector);\n        } else {\n          tempVector.applyMatrix4(transformInverse);\n          // Sphere#distanceToPoint is negative inside the sphere, whereas Box3#distanceToPoint is\n          // zero inside the box. Clipping the distance to a minimum of zero ensures that both\n          // types of bounding volume behave the same way.\n          distance = Math.max(boundingSphere.distanceToPoint(tempVector), 0);\n        }\n        const scaledDistance = distance * invScale;\n        const sseDenominator = info.sseDenominator;\n        error = tile.geometricError / (scaledDistance * sseDenominator);\n        minDistance = Math.min(minDistance, scaledDistance);\n      }\n      maxError = Math.max(maxError, error);\n    }\n    tile.__distanceFromCamera = minDistance;\n    tile.__error = maxError;\n  }\n  tileInView(tile) {\n    // TODO: we should use the more precise bounding volumes here if possible\n    // cache the root-space planes\n    // Use separating axis theorem for frustum and obb\n\n    const cached = tile.cached;\n    const sphere = cached.sphere;\n    const inFrustum = cached.inFrustum;\n    if (sphere) {\n      const cameraInfo = this.cameraInfo;\n      let inView = false;\n      for (let i = 0, l = cameraInfo.length; i < l; i++) {\n        // Track which camera frustums this tile is in so we can use it\n        // to ignore the error calculations for cameras that can't see it\n        const frustum = cameraInfo[i].frustum;\n        if (frustum.intersectsSphere(sphere)) {\n          inView = true;\n          inFrustum[i] = true;\n        } else {\n          inFrustum[i] = false;\n        }\n      }\n      return inView;\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["TilesRendererBase","WGS84_HEIGHT","WGS84_RADIUS","B3DMLoader","PNTSLoader","I3DMLoader","CMPTLoader","GLTFExtensionLoader","TilesGroup","EllipsoidRegion","Matrix4","Box3","Sphere","Vector3","Vector2","Frustum","LoadingManager","raycastTraverse","raycastTraverseFirstHit","readMagicBytes","INITIAL_FRUSTUM_CULLED","Symbol","tempMat","tempMat2","tempVector","vecX","vecY","vecZ","X_AXIS","Y_AXIS","updateFrustumCulled","object","toInitialValue","traverse","c","frustumCulled","TilesRenderer","autoDisableRendererCulling","_autoDisableRendererCulling","value","forEachLoadedModel","scene","constructor","args","group","cameras","cameraMap","Map","cameraInfo","activeTiles","Set","visibleTiles","optimizeRaycast","onLoadTileSet","onLoadModel","onDisposeModel","onTileVisibilityChange","manager","setURLModifier","url","preprocessURL","tilesRenderer","_overridenRaycast","raycaster","intersects","Object","getPrototypeOf","raycast","call","getBounds","box","root","cached","boundingBox","obbMat","boxTransform","copy","applyMatrix4","getOrientedBounds","matrix","getBoundingSphere","sphere","boundingSphere","callback","tile","firstHitOnly","hit","push","hasCamera","camera","has","setCamera","set","setResolution","xOrVec","y","get","setResolutionFromRenderer","renderer","resolution","getSize","multiplyScalar","getPixelRatio","deleteCamera","index","indexOf","splice","delete","fetchTileSet","rest","pr","then","json","Promise","resolve","update","length","console","warn","pop","frustum","isOrthographic","sseDenominator","position","invScale","pixelSize","matrixWorld","invert","setFromMatrixScale","x","Math","abs","max","z","i","l","info","width","height","projection","projectionMatrix","elements","w","h","premultiply","matrixWorldInverse","setFromProjectionMatrix","preprocessNode","parentTile","tileSetDir","transform","transformArr","identity","transformInverse","boxTransformInverse","boundingVolume","data","scaleX","scaleY","scaleZ","normalize","crossVectors","min","center","radius","region","west","south","east","north","minHeight","maxHeight","getBoundingBox","loadIndex","active","inFrustum","geometry","material","parseTile","buffer","extension","_loadIndex","uri","content","uriSplits","split","workingPath","join","fetchOptions","promise","upAxis","rootTileSet","asset","gltfUpAxis","cachedTransform","toLowerCase","makeRotationAxis","PI","fileType","loader","adjustmentTransform","parse","res","updateMatrix","multiply","decompose","quaternion","scale","materials","textures","key","isTexture","disposeTile","parent","dispose","texture","remove","setTileVisible","visible","add","updateMatrixWorld","setTileActive","calculateError","useBox","maxError","Infinity","minDistance","error","geometricError","distance","distanceToPoint","scaledDistance","__distanceFromCamera","__error","tileInView","inView","intersectsSphere"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/3d-tiles-renderer/src/three/TilesRenderer.js"],"sourcesContent":["import { TilesRendererBase } from '../base/TilesRendererBase.js';\nimport { WGS84_HEIGHT, WGS84_RADIUS } from '../base/constants.js';\nimport { B3DMLoader } from './B3DMLoader.js';\nimport { PNTSLoader } from './PNTSLoader.js';\nimport { I3DMLoader } from './I3DMLoader.js';\nimport { CMPTLoader } from './CMPTLoader.js';\nimport { GLTFExtensionLoader } from './GLTFExtensionLoader.js';\nimport { TilesGroup } from './TilesGroup.js';\nimport { EllipsoidRegion } from './math/EllipsoidRegion.js';\nimport {\n\tMatrix4,\n\tBox3,\n\tSphere,\n\tVector3,\n\tVector2,\n\tFrustum,\n\tLoadingManager\n} from 'three';\nimport { raycastTraverse, raycastTraverseFirstHit } from './raycastTraverse.js';\nimport { readMagicBytes } from '../utilities/readMagicBytes.js';\n\nconst INITIAL_FRUSTUM_CULLED = Symbol( 'INITIAL_FRUSTUM_CULLED' );\nconst tempMat = new Matrix4();\nconst tempMat2 = new Matrix4();\nconst tempVector = new Vector3();\nconst vecX = new Vector3();\nconst vecY = new Vector3();\nconst vecZ = new Vector3();\n\nconst X_AXIS = new Vector3( 1, 0, 0 );\nconst Y_AXIS = new Vector3( 0, 1, 0 );\n\nfunction updateFrustumCulled( object, toInitialValue ) {\n\n\tobject.traverse( c => {\n\n\t\tc.frustumCulled = c[ INITIAL_FRUSTUM_CULLED ] && toInitialValue;\n\n\t} );\n\n}\n\nexport class TilesRenderer extends TilesRendererBase {\n\n\tget autoDisableRendererCulling() {\n\n\t\treturn this._autoDisableRendererCulling;\n\n\t}\n\n\tset autoDisableRendererCulling( value ) {\n\n\t\tif ( this._autoDisableRendererCulling !== value ) {\n\n\t\t\tsuper._autoDisableRendererCulling = value;\n\t\t\tthis.forEachLoadedModel( ( scene ) => {\n\n\t\t\t\tupdateFrustumCulled( scene, ! value );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.group = new TilesGroup( this );\n\t\tthis.cameras = [];\n\t\tthis.cameraMap = new Map();\n\t\tthis.cameraInfo = [];\n\t\tthis.activeTiles = new Set();\n\t\tthis.visibleTiles = new Set();\n\t\tthis._autoDisableRendererCulling = true;\n\t\tthis.optimizeRaycast = true;\n\n\t\tthis.onLoadTileSet = null;\n\t\tthis.onLoadModel = null;\n\t\tthis.onDisposeModel = null;\n\t\tthis.onTileVisibilityChange = null;\n\n\t\tconst manager = new LoadingManager();\n\t\tmanager.setURLModifier( url => {\n\n\t\t\tif ( this.preprocessURL ) {\n\n\t\t\t\treturn this.preprocessURL( url );\n\n\t\t\t} else {\n\n\t\t\t\treturn url;\n\n\t\t\t}\n\n\t\t} );\n\t\tthis.manager = manager;\n\n\t\t// Setting up the override raycasting function to be used by\n\t\t// 3D objects created by this renderer\n\t\tconst tilesRenderer = this;\n\t\tthis._overridenRaycast = function ( raycaster, intersects ) {\n\n\t\t\tif ( ! tilesRenderer.optimizeRaycast ) {\n\n\t\t\t\tObject.getPrototypeOf( this ).raycast.call( this, raycaster, intersects );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/* Public API */\n\tgetBounds( box ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst cached = this.root.cached;\n\t\tconst boundingBox = cached.box;\n\t\tconst obbMat = cached.boxTransform;\n\n\t\tif ( boundingBox ) {\n\n\t\t\tbox.copy( boundingBox );\n\t\t\tbox.applyMatrix4( obbMat );\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetOrientedBounds( box, matrix ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst cached = this.root.cached;\n\t\tconst boundingBox = cached.box;\n\t\tconst obbMat = cached.boxTransform;\n\n\t\tif ( boundingBox ) {\n\n\t\t\tbox.copy( boundingBox );\n\t\t\tmatrix.copy( obbMat );\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetBoundingSphere( sphere ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingSphere = this.root.cached.sphere;\n\n\t\tif ( boundingSphere ) {\n\n\t\t\tsphere.copy( boundingSphere );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tforEachLoadedModel( callback ) {\n\n\t\tthis.traverse( tile => {\n\n\t\t\tconst scene = tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tcallback( scene, tile );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( raycaster.firstHitOnly ) {\n\n\t\t\tconst hit = raycastTraverseFirstHit( this.root, this.group, this.activeTiles, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\traycastTraverse( this.root, this.group, this.activeTiles, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\thasCamera( camera ) {\n\n\t\treturn this.cameraMap.has( camera );\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\tcameraMap.set( camera, new Vector2() );\n\t\t\tcameras.push( camera );\n\t\t\treturn true;\n\n\t\t}\n\t\treturn false;\n\n\t}\n\n\tsetResolution( camera, xOrVec, y ) {\n\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( xOrVec instanceof Vector2 ) {\n\n\t\t\tcameraMap.get( camera ).copy( xOrVec );\n\n\t\t} else {\n\n\t\t\tcameraMap.get( camera ).set( xOrVec, y );\n\n\t\t}\n\t\treturn true;\n\n\t}\n\n\tsetResolutionFromRenderer( camera, renderer ) {\n\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst resolution = cameraMap.get( camera );\n\t\trenderer.getSize( resolution );\n\t\tresolution.multiplyScalar( renderer.getPixelRatio() );\n\t\treturn true;\n\n\t}\n\n\tdeleteCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( cameraMap.has( camera ) ) {\n\n\t\t\tconst index = cameras.indexOf( camera );\n\t\t\tcameras.splice( index, 1 );\n\t\t\tcameraMap.delete( camera );\n\t\t\treturn true;\n\n\t\t}\n\t\treturn false;\n\n\t}\n\n\t/* Overriden */\n\tfetchTileSet( url, ...rest ) {\n\n\t\tconst pr = super.fetchTileSet( url, ...rest );\n\t\tpr.then( json => {\n\n\t\t\tif ( this.onLoadTileSet ) {\n\n\t\t\t\t// Push this onto the end of the event stack to ensure this runs\n\t\t\t\t// after the base renderer has placed the provided json where it\n\t\t\t\t// needs to be placed and is ready for an update.\n\t\t\t\tPromise.resolve().then( () => {\n\n\t\t\t\t\tthis.onLoadTileSet( json, url );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\t\treturn pr;\n\n\t}\n\n\tupdate() {\n\n\t\tconst group = this.group;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tconst cameraInfo = this.cameraInfo;\n\n\t\tif ( cameras.length === 0 ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: no cameras defined. Cannot update 3d tiles.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// automatically scale the array of cameraInfo to match the cameras\n\t\twhile ( cameraInfo.length > cameras.length ) {\n\n\t\t\tcameraInfo.pop();\n\n\t\t}\n\n\t\twhile ( cameraInfo.length < cameras.length ) {\n\n\t\t\tcameraInfo.push( {\n\n\t\t\t\tfrustum: new Frustum(),\n\t\t\t\tisOrthographic: false,\n\t\t\t\tsseDenominator: - 1, // used if isOrthographic:false\n\t\t\t\tposition: new Vector3(),\n\t\t\t\tinvScale: - 1,\n\t\t\t\tpixelSize: 0, // used if isOrthographic:true\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// extract scale of group container\n\t\ttempMat2.copy( group.matrixWorld ).invert();\n\n\t\ttempVector.setFromMatrixScale( tempMat2 );\n\t\tconst invScale = tempVector.x;\n\n\t\tif ( Math.abs( Math.max( tempVector.x - tempVector.y, tempVector.x - tempVector.z ) ) > 1e-6 ) {\n\n\t\t\tconsole.warn( 'ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.' );\n\n\t\t}\n\n\t\t// store the camera cameraInfo in the 3d tiles root frame\n\t\tfor ( let i = 0, l = cameraInfo.length; i < l; i ++ ) {\n\n\t\t\tconst camera = cameras[ i ];\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tconst frustum = info.frustum;\n\t\t\tconst position = info.position;\n\t\t\tconst resolution = cameraMap.get( camera );\n\n\t\t\tif ( resolution.width === 0 || resolution.height === 0 ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: resolution for camera error calculation is not set.' );\n\n\t\t\t}\n\n\t\t\t// Read the calculated projection matrix directly to support custom Camera implementations\n\t\t\tconst projection = camera.projectionMatrix.elements;\n\n\t\t\t// The last element of the projection matrix is 1 for orthographic, 0 for perspective\n\t\t\tinfo.isOrthographic = projection[ 15 ] === 1;\n\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\t// See OrthographicCamera.updateProjectionMatrix and Matrix4.makeOrthographic:\n\t\t\t\t// the view width and height are used to populate matrix elements 0 and 5.\n\t\t\t\tconst w = 2 / projection[ 0 ];\n\t\t\t\tconst h = 2 / projection[ 5 ];\n\t\t\t\tinfo.pixelSize = Math.max( h / resolution.height, w / resolution.width );\n\n\t\t\t} else {\n\n\t\t\t\t// See PerspectiveCamera.updateProjectionMatrix and Matrix4.makePerspective:\n\t\t\t\t// the vertical FOV is used to populate matrix element 5.\n\t\t\t\tinfo.sseDenominator = ( 2 / projection[ 5 ] ) / resolution.height;\n\n\t\t\t}\n\n\t\t\tinfo.invScale = invScale;\n\n\t\t\t// get frustum in group root frame\n\t\t\ttempMat.copy( group.matrixWorld );\n\t\t\ttempMat.premultiply( camera.matrixWorldInverse );\n\t\t\ttempMat.premultiply( camera.projectionMatrix );\n\n\t\t\tfrustum.setFromProjectionMatrix( tempMat );\n\n\t\t\t// get transform position in group root frame\n\t\t\tposition.set( 0, 0, 0 );\n\t\t\tposition.applyMatrix4( camera.matrixWorld );\n\t\t\tposition.applyMatrix4( tempMat2 );\n\n\t\t}\n\n\t\tsuper.update();\n\n\t}\n\n\tpreprocessNode( tile, parentTile, tileSetDir ) {\n\n\t\tsuper.preprocessNode( tile, parentTile, tileSetDir );\n\n\t\tconst transform = new Matrix4();\n\t\tif ( tile.transform ) {\n\n\t\t\tconst transformArr = tile.transform;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransform.elements[ i ] = transformArr[ i ];\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttransform.identity();\n\n\t\t}\n\n\t\tif ( parentTile ) {\n\n\t\t\ttransform.premultiply( parentTile.cached.transform );\n\n\t\t}\n\n\t\tconst transformInverse = new Matrix4().copy( transform ).invert();\n\n\t\tlet box = null;\n\t\tlet boxTransform = null;\n\t\tlet boxTransformInverse = null;\n\t\tif ( 'box' in tile.boundingVolume ) {\n\n\t\t\tconst data = tile.boundingVolume.box;\n\t\t\tbox = new Box3();\n\t\t\tboxTransform = new Matrix4();\n\t\t\tboxTransformInverse = new Matrix4();\n\n\t\t\t// get the extents of the bounds in each axis\n\t\t\tvecX.set( data[ 3 ], data[ 4 ], data[ 5 ] );\n\t\t\tvecY.set( data[ 6 ], data[ 7 ], data[ 8 ] );\n\t\t\tvecZ.set( data[ 9 ], data[ 10 ], data[ 11 ] );\n\n\t\t\tconst scaleX = vecX.length();\n\t\t\tconst scaleY = vecY.length();\n\t\t\tconst scaleZ = vecZ.length();\n\n\t\t\tvecX.normalize();\n\t\t\tvecY.normalize();\n\t\t\tvecZ.normalize();\n\n\t\t\t// handle the case where the box has a dimension of 0 in one axis\n\t\t\tif ( scaleX === 0 ) {\n\n\t\t\t\tvecX.crossVectors( vecY, vecZ );\n\n\t\t\t}\n\n\t\t\tif ( scaleY === 0 ) {\n\n\t\t\t\tvecY.crossVectors( vecX, vecZ );\n\n\t\t\t}\n\n\t\t\tif ( scaleZ === 0 ) {\n\n\t\t\t\tvecZ.crossVectors( vecX, vecY );\n\n\t\t\t}\n\n\t\t\t// create the oriented frame that the box exists in\n\t\t\tboxTransform.set(\n\t\t\t\tvecX.x, vecY.x, vecZ.x, data[ 0 ],\n\t\t\t\tvecX.y, vecY.y, vecZ.y, data[ 1 ],\n\t\t\t\tvecX.z, vecY.z, vecZ.z, data[ 2 ],\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\t\t\tboxTransform.premultiply( transform );\n\t\t\tboxTransformInverse.copy( boxTransform ).invert();\n\n\t\t\t// scale the box by the extents\n\t\t\tbox.min.set( - scaleX, - scaleY, - scaleZ );\n\t\t\tbox.max.set( scaleX, scaleY, scaleZ );\n\n\t\t}\n\n\t\tlet sphere = null;\n\t\tif ( 'sphere' in tile.boundingVolume ) {\n\n\t\t\tconst data = tile.boundingVolume.sphere;\n\t\t\tsphere = new Sphere();\n\t\t\tsphere.center.set( data[ 0 ], data[ 1 ], data[ 2 ] );\n\t\t\tsphere.radius = data[ 3 ];\n\t\t\tsphere.applyMatrix4( transform );\n\n\t\t} else if ( 'box' in tile.boundingVolume ) {\n\n\t\t\tconst data = tile.boundingVolume.box;\n\t\t\tsphere = new Sphere();\n\t\t\tbox.getBoundingSphere( sphere );\n\t\t\tsphere.center.set( data[ 0 ], data[ 1 ], data[ 2 ] );\n\t\t\tsphere.applyMatrix4( transform );\n\n\t\t}\n\n\t\tlet region = null;\n\t\tif ( 'region' in tile.boundingVolume ) {\n\n\t\t\tconst data = tile.boundingVolume.region;\n\t\t\tconst [ west, south, east, north, minHeight, maxHeight ] = data;\n\n\t\t\tregion = new EllipsoidRegion(\n\t\t\t\tWGS84_RADIUS, WGS84_RADIUS, WGS84_HEIGHT,\n\t\t\t\tsouth, north,\n\t\t\t\twest, east,\n\t\t\t\tminHeight, maxHeight,\n\t\t\t);\n\n\t\t\tif ( sphere === null ) {\n\n\t\t\t\tsphere = new Sphere();\n\t\t\t\tregion.getBoundingSphere( sphere );\n\n\t\t\t}\n\n\t\t\tif ( box === null ) {\n\n\t\t\t\tbox = new Box3();\n\t\t\t\tboxTransform = new Matrix4();\n\t\t\t\tboxTransformInverse = new Matrix4();\n\n\t\t\t\tregion.getBoundingBox( box, boxTransform );\n\t\t\t\tboxTransformInverse.copy( boxTransform ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\n\t\ttile.cached = {\n\n\t\t\tloadIndex: 0,\n\t\t\ttransform,\n\t\t\ttransformInverse,\n\n\t\t\tactive: false,\n\t\t\tinFrustum: [],\n\n\t\t\tbox,\n\t\t\tboxTransform,\n\t\t\tboxTransformInverse,\n\t\t\tsphere,\n\t\t\tregion,\n\n\t\t\tscene: null,\n\t\t\tgeometry: null,\n\t\t\tmaterial: null,\n\n\t\t};\n\n\t}\n\n\tparseTile( buffer, tile, extension ) {\n\n\t\ttile._loadIndex = tile._loadIndex || 0;\n\t\ttile._loadIndex ++;\n\n\t\tconst uri = tile.content.uri;\n\t\tconst uriSplits = uri.split( /[\\\\\\/]/g );\n\t\turiSplits.pop();\n\t\tconst workingPath = uriSplits.join( '/' );\n\t\tconst fetchOptions = this.fetchOptions;\n\n\t\tconst manager = this.manager;\n\t\tconst loadIndex = tile._loadIndex;\n\t\tlet promise = null;\n\n\t\tconst upAxis = this.rootTileSet.asset && this.rootTileSet.asset.gltfUpAxis || 'y';\n\t\tconst cached = tile.cached;\n\t\tconst cachedTransform = cached.transform;\n\n\t\tswitch ( upAxis.toLowerCase() ) {\n\n\t\t\tcase 'x':\n\t\t\t\ttempMat.makeRotationAxis( Y_AXIS, - Math.PI / 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase 'y':\n\t\t\t\ttempMat.makeRotationAxis( X_AXIS, Math.PI / 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase 'z':\n\t\t\t\ttempMat.identity();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst fileType = readMagicBytes( buffer ) || extension;\n\t\tswitch ( fileType ) {\n\n\t\t\tcase 'b3dm': {\n\n\t\t\t\tconst loader = new B3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( tempMat );\n\n\t\t\t\tpromise = loader\n\t\t\t\t\t.parse( buffer )\n\t\t\t\t\t.then( res => res.scene );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'pnts': {\n\n\t\t\t\tconst loader = new PNTSLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\t\t\t\tpromise = loader\n\t\t\t\t\t.parse( buffer )\n\t\t\t\t\t.then( res => res.scene );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'i3dm': {\n\n\t\t\t\tconst loader = new I3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( tempMat );\n\n\t\t\t\tpromise = loader\n\t\t\t\t\t.parse( buffer )\n\t\t\t\t\t.then( res => res.scene );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'cmpt': {\n\n\t\t\t\tconst loader = new CMPTLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( tempMat );\n\n\t\t\t\tpromise = loader\n\t\t\t\t\t.parse( buffer )\n\t\t\t\t\t.then( res => res.scene\t);\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// 3DTILES_content_gltf\n\t\t\tcase 'gltf':\n\t\t\tcase 'glb':\n\t\t\t\tconst loader = new GLTFExtensionLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\t\t\t\tpromise = loader\n\t\t\t\t\t.parse( buffer )\n\t\t\t\t\t.then( res => res.scene\t);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( `TilesRenderer: Content type \"${ fileType }\" not supported.` );\n\t\t\t\tpromise = Promise.resolve( null );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn promise.then( scene => {\n\n\t\t\tif ( tile._loadIndex !== loadIndex ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\t\t\t// ensure the matrix is up to date in case the scene has a transform applied\n\t\t\tscene.updateMatrix();\n\n\t\t\t// apply the local up-axis correction rotation\n\t\t\t// GLTFLoader seems to never set a transformation on the root scene object so\n\t\t\t// any transformations applied to it can be assumed to be applied after load\n\t\t\t// (such as applying RTC_CENTER) meaning they should happen _after_ the z-up\n\t\t\t// rotation fix which is why \"multiply\" happens here.\n\t\t\tif ( fileType === 'glb' || fileType === 'gltf' ) {\n\n\t\t\t\tscene.matrix.multiply( tempMat );\n\n\t\t\t}\n\n\t\t\tscene.matrix.premultiply( cachedTransform );\n\t\t\tscene.matrix.decompose( scene.position, scene.quaternion, scene.scale );\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tc[ INITIAL_FRUSTUM_CULLED ] = c.frustumCulled;\n\n\t\t\t} );\n\t\t\tupdateFrustumCulled( scene, ! this.autoDisableRendererCulling );\n\n\t\t\tcached.scene = scene;\n\n\t\t\t// We handle raycasting in a custom way so remove it from here\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tc.raycast = this._overridenRaycast;\n\n\t\t\t} );\n\n\t\t\tconst materials = [];\n\t\t\tconst geometry = [];\n\t\t\tconst textures = [];\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.geometry ) {\n\n\t\t\t\t\tgeometry.push( c.geometry );\n\n\t\t\t\t}\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tconst material = c.material;\n\t\t\t\t\tmaterials.push( c.material );\n\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tcached.materials = materials;\n\t\t\tcached.geometry = geometry;\n\t\t\tcached.textures = textures;\n\n\t\t\tif ( this.onLoadModel ) {\n\n\t\t\t\tthis.onLoadModel( scene, tile );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\t// This could get called before the tile has finished downloading\n\t\tconst cached = tile.cached;\n\t\tif ( cached.scene ) {\n\n\t\t\tconst materials = cached.materials;\n\t\t\tconst geometry = cached.geometry;\n\t\t\tconst textures = cached.textures;\n\t\t\tconst parent = cached.scene.parent;\n\n\t\t\tfor ( let i = 0, l = geometry.length; i < l; i ++ ) {\n\n\t\t\t\tgeometry[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterials[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tparent.remove( cached.scene );\n\n\t\t\t}\n\n\t\t\tif ( this.onDisposeModel ) {\n\n\t\t\t\tthis.onDisposeModel( cached.scene, tile );\n\n\t\t\t}\n\n\t\t\tcached.scene = null;\n\t\t\tcached.materials = null;\n\t\t\tcached.textures = null;\n\t\t\tcached.geometry = null;\n\n\t\t}\n\n\t\tthis.activeTiles.delete( tile );\n\t\tthis.visibleTiles.delete( tile );\n\t\ttile._loadIndex ++;\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst scene = tile.cached.scene;\n\t\tconst visibleTiles = this.visibleTiles;\n\t\tconst group = this.group;\n\t\tif ( visible ) {\n\n\t\t\tgroup.add( scene );\n\t\t\tvisibleTiles.add( tile );\n\t\t\tscene.updateMatrixWorld( true );\n\n\t\t} else {\n\n\t\t\tgroup.remove( scene );\n\t\t\tvisibleTiles.delete( tile );\n\n\t\t}\n\n\t\tif ( this.onTileVisibilityChange ) {\n\n\t\t\tthis.onTileVisibilityChange( scene, tile, visible );\n\n\t\t}\n\n\t}\n\n\tsetTileActive( tile, active ) {\n\n\t\tconst activeTiles = this.activeTiles;\n\t\tif ( active ) {\n\n\t\t\tactiveTiles.add( tile );\n\n\t\t} else {\n\n\t\t\tactiveTiles.delete( tile );\n\n\t\t}\n\n\t}\n\n\tcalculateError( tile ) {\n\n\t\tconst cached = tile.cached;\n\t\tconst inFrustum = cached.inFrustum;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraInfo = this.cameraInfo;\n\n\t\t// TODO: Use the content bounding volume here?\n\t\t// TODO: We should use the largest distance to the tile between\n\t\t// all available bounding volume types.\n\t\tconst boundingSphere = cached.sphere;\n\t\tconst boundingBox = cached.box;\n\t\tconst boxTransformInverse = cached.boxTransformInverse;\n\t\tconst transformInverse = cached.transformInverse;\n\t\tconst useBox = boundingBox && boxTransformInverse;\n\n\t\tlet maxError = - Infinity;\n\t\tlet minDistance = Infinity;\n\n\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\tif ( ! inFrustum[ i ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// transform camera position into local frame of the tile bounding box\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tconst invScale = info.invScale;\n\n\t\t\tlet error;\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\tconst pixelSize = info.pixelSize;\n\t\t\t\terror = tile.geometricError / ( pixelSize * invScale );\n\n\t\t\t} else {\n\n\t\t\t\ttempVector.copy( info.position );\n\n\t\t\t\tlet distance;\n\t\t\t\tif ( useBox ) {\n\n\t\t\t\t\ttempVector.applyMatrix4( boxTransformInverse );\n\t\t\t\t\tdistance = boundingBox.distanceToPoint( tempVector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttempVector.applyMatrix4( transformInverse );\n\t\t\t\t\t// Sphere#distanceToPoint is negative inside the sphere, whereas Box3#distanceToPoint is\n\t\t\t\t\t// zero inside the box. Clipping the distance to a minimum of zero ensures that both\n\t\t\t\t\t// types of bounding volume behave the same way.\n\t\t\t\t\tdistance = Math.max( boundingSphere.distanceToPoint( tempVector ), 0 );\n\n\t\t\t\t}\n\n\t\t\t\tconst scaledDistance = distance * invScale;\n\t\t\t\tconst sseDenominator = info.sseDenominator;\n\t\t\t\terror = tile.geometricError / ( scaledDistance * sseDenominator );\n\n\t\t\t\tminDistance = Math.min( minDistance, scaledDistance );\n\n\t\t\t}\n\n\t\t\tmaxError = Math.max( maxError, error );\n\n\t\t}\n\n\t\ttile.__distanceFromCamera = minDistance;\n\t\ttile.__error = maxError;\n\n\t}\n\n\ttileInView( tile ) {\n\n\t\t// TODO: we should use the more precise bounding volumes here if possible\n\t\t// cache the root-space planes\n\t\t// Use separating axis theorem for frustum and obb\n\n\t\tconst cached = tile.cached;\n\t\tconst sphere = cached.sphere;\n\t\tconst inFrustum = cached.inFrustum;\n\t\tif ( sphere ) {\n\n\t\t\tconst cameraInfo = this.cameraInfo;\n\t\t\tlet inView = false;\n\t\t\tfor ( let i = 0, l = cameraInfo.length; i < l; i ++ ) {\n\n\t\t\t\t// Track which camera frustums this tile is in so we can use it\n\t\t\t\t// to ignore the error calculations for cameras that can't see it\n\t\t\t\tconst frustum = cameraInfo[ i ].frustum;\n\t\t\t\tif ( frustum.intersectsSphere( sphere ) ) {\n\n\t\t\t\t\tinView = true;\n\t\t\t\t\tinFrustum[ i ] = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinFrustum[ i ] = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn inView;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
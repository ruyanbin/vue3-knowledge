{"ast":null,"code":"// src/normalize.ts\nfunction isObject(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction normalizeOptions(options, factoryOptions) {\n  options = isObject(options) ? options : /* @__PURE__ */Object.create(null);\n  return new Proxy(options, {\n    get(target, key, receiver) {\n      if (key === \"key\") return Reflect.get(target, key, receiver);\n      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);\n    }\n  });\n}\n\n// src/pick.ts\nfunction get(state, path) {\n  return path.reduce((obj, p) => {\n    return obj == null ? void 0 : obj[p];\n  }, state);\n}\nfunction set(state, path, val) {\n  return path.slice(0, -1).reduce((obj, p) => {\n    if (/^(__proto__)$/.test(p)) return {};else return obj[p] = obj[p] || {};\n  }, state)[path[path.length - 1]] = val, state;\n}\nfunction pick(baseState, paths) {\n  return paths.reduce((substate, path) => {\n    const pathArray = path.split(\".\");\n    return set(substate, pathArray, get(baseState, pathArray));\n  }, {});\n}\n\n// src/plugin.ts\nfunction hydrateStore(store, {\n  storage,\n  serializer,\n  key,\n  debug\n}) {\n  try {\n    const fromStorage = storage == null ? void 0 : storage.getItem(key);\n    if (fromStorage) store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));\n  } catch (error) {\n    if (debug) console.error(error);\n  }\n}\nfunction persistState(state, {\n  storage,\n  serializer,\n  key,\n  paths,\n  debug\n}) {\n  try {\n    const toStore = Array.isArray(paths) ? pick(state, paths) : state;\n    storage.setItem(key, serializer.serialize(toStore));\n  } catch (error) {\n    if (debug) console.error(error);\n  }\n}\nfunction createPersistedState(factoryOptions = {}) {\n  return context => {\n    const {\n      options: {\n        persist\n      },\n      store\n    } = context;\n    if (!persist) return;\n    const persistences = (Array.isArray(persist) ? persist.map(p => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(({\n      storage = localStorage,\n      beforeRestore = null,\n      afterRestore = null,\n      serializer = {\n        serialize: JSON.stringify,\n        deserialize: JSON.parse\n      },\n      key = store.$id,\n      paths = null,\n      debug = false\n    }) => {\n      var _a;\n      return {\n        storage,\n        beforeRestore,\n        afterRestore,\n        serializer,\n        key: ((_a = factoryOptions.key) != null ? _a : k => k)(key),\n        paths,\n        debug\n      };\n    });\n    store.$persist = () => {\n      persistences.forEach(persistence => {\n        persistState(store.$state, persistence);\n      });\n    };\n    store.$hydrate = ({\n      runHooks = true\n    } = {}) => {\n      persistences.forEach(persistence => {\n        const {\n          beforeRestore,\n          afterRestore\n        } = persistence;\n        if (runHooks) beforeRestore == null ? void 0 : beforeRestore(context);\n        hydrateStore(store, persistence);\n        if (runHooks) afterRestore == null ? void 0 : afterRestore(context);\n      });\n    };\n    persistences.forEach(persistence => {\n      const {\n        beforeRestore,\n        afterRestore\n      } = persistence;\n      beforeRestore == null ? void 0 : beforeRestore(context);\n      hydrateStore(store, persistence);\n      afterRestore == null ? void 0 : afterRestore(context);\n      store.$subscribe((_mutation, state) => {\n        persistState(state, persistence);\n      }, {\n        detached: true\n      });\n    });\n  };\n}\n\n// src/index.ts\nvar src_default = createPersistedState();\nexport { createPersistedState, src_default as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
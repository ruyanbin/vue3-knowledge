{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Raycaster, AxesHelper, AmbientLight, DirectionalLight, HemisphereLight, PointLight, RectAreaLight, SpotLight, Vector2, sRGBEncoding, PMREMGenerator, LinearFilter } from 'three';\nimport { merge, bind } from 'lodash-es';\nimport { HDRCubeTextureLoader } from 'three/examples/jsm/loaders/HDRCubeTextureLoader.js';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { ThreeLayer } from '@amap/three-layer';\nimport { ThreeRenderPass } from './ThreeRenderPass.mjs';\nclass CustomThreeLayer extends ThreeLayer {\n  constructor(map, options, callback) {\n    options.onInit = (render, scene) => {\n      this.raycaster = new Raycaster();\n      if (options.axesHelper) {\n        const axesHelper = new AxesHelper(1e4);\n        scene.add(axesHelper);\n      }\n      this.createEffect();\n      this.createLights(options.lights || []);\n      this.createHDR(options.hdr);\n      this.bindEvents();\n      if (callback) {\n        callback();\n      }\n    };\n    super(map, options);\n    this.lightTypes = {\n      AmbientLight,\n      DirectionalLight,\n      HemisphereLight,\n      PointLight,\n      RectAreaLight,\n      SpotLight\n    };\n    this.passNum = 0;\n    this.passList = [];\n    this.mouse = new Vector2();\n  }\n  createEffect() {\n    var _a;\n    const size = (_a = this.renderer) == null ? void 0 : _a.getSize(new Vector2());\n    this.effectComposer = new EffectComposer(this.renderer);\n    this.effectComposer.setSize(size == null ? void 0 : size.x, size == null ? void 0 : size.y);\n    const renderPass = new ThreeRenderPass(this.scene, this.camera);\n    this.renderPass = renderPass;\n    this.effectComposer.addPass(renderPass);\n  }\n  addPass(pass) {\n    this.effectComposer.addPass(pass);\n    this.passNum++;\n    this.passList.push(pass);\n  }\n  removePass(pass) {\n    const index = this.passList.indexOf(pass);\n    if (index !== -1) {\n      this.passList.splice(index, 1);\n    }\n    this.effectComposer.removePass(pass);\n    this.passNum--;\n  }\n  createLights(lights) {\n    const defaultLightOptions = {\n      type: \"DirectionalLight\",\n      args: []\n    };\n    if (lights && lights.length > 0) {\n      lights.forEach(lightOptions => {\n        lightOptions = merge({}, defaultLightOptions, lightOptions);\n        if (this.lightTypes[lightOptions.type]) {\n          const light = new this.lightTypes[lightOptions.type](...lightOptions.args);\n          const position = lightOptions.position;\n          const lookAt = lightOptions.lookAt;\n          if (position) {\n            light.position.set(position.x, position.y, position.z);\n          }\n          if (lookAt) {\n            light.lookAt(lookAt.x, lookAt.y, lookAt.z);\n          }\n          this.add(light);\n        } else {\n          console.warn(\"\\u5F53\\u524D\\u8BBE\\u7F6E\\u7684\\u706F\\u5149\\u7C7B\\u578B\\u4E0D\\u5B58\\u5728\");\n        }\n      });\n    }\n  }\n  createHDR(hdr) {\n    if (!hdr) {\n      return;\n    }\n    const options = merge({}, {\n      urls: [],\n      path: \"/\",\n      exposure: 1\n    }, hdr);\n    const render = this.renderer;\n    render.physicallyCorrectLights = true;\n    render.outputEncoding = sRGBEncoding;\n    render.toneMappingExposure = options.exposure;\n    const hdrUrls = options.urls;\n    let pmremGenerator = new PMREMGenerator(render);\n    pmremGenerator.compileCubemapShader();\n    const hdrCubeMap = new HDRCubeTextureLoader().setPath(options.path).load(hdrUrls, () => {\n      const hdrCubeRenderTarget = pmremGenerator.fromCubemap(hdrCubeMap);\n      hdrCubeMap.magFilter = LinearFilter;\n      hdrCubeMap.needsUpdate = true;\n      this.envMap = hdrCubeRenderTarget ? hdrCubeRenderTarget.texture : null;\n      this.addEnvMap(this.scene);\n      pmremGenerator.dispose();\n      pmremGenerator = null;\n      this.refreshMap();\n    });\n  }\n  addEnvMap(object) {\n    this.scene.environment = this.envMap;\n  }\n  bindEvents() {\n    this.clickFun = bind(this._clickEvent, this);\n    this.hoverFun = bind(this._hoverEvent, this);\n    this.map.on(\"click\", this.clickFun);\n    this.map.on(\"mousemove\", this.hoverFun);\n  }\n  ubBindEvents() {\n    this.map.off(\"click\", this.clickFun);\n    this.map.off(\"mousemove\", this.hoverFun);\n  }\n  _clickEvent(e) {\n    const group = this._intersectGltf(e);\n    if (group) {\n      group.$vue.$emit(\"click\", group);\n    }\n  }\n  _hoverEvent(e) {\n    var _a;\n    const group = this._intersectGltf(e);\n    if (group) {\n      if (!group.isHover) {\n        group.isHover = true;\n        group.$vue.$emit(\"mouseover\", group);\n      }\n    } else {\n      const children = (_a = this.scene) == null ? void 0 : _a.children;\n      children == null ? void 0 : children.forEach(object => {\n        if (object.isCustomGroup && object.isHover === true) {\n          object.isHover = false;\n          object.$vue.$emit(\"mouseout\", object);\n        }\n      });\n    }\n  }\n  _intersectGltf(e) {\n    var _a, _b;\n    const client = this.map.getContainer();\n    const getBoundingClientRect = client.getBoundingClientRect();\n    const offsetTop = getBoundingClientRect.top + window.pageYOffset - client.clientTop;\n    const offsetLeft = getBoundingClientRect.left + window.pageXOffset - client.clientLeft;\n    this.mouse.x = (e.originEvent.x + window.pageXOffset - offsetLeft) / getBoundingClientRect.width * 2 - 1;\n    this.mouse.y = -((e.originEvent.y + window.pageYOffset - offsetTop) / getBoundingClientRect.height) * 2 + 1;\n    const camera = this.camera;\n    (_a = this.raycaster) == null ? void 0 : _a.setFromCamera(this.mouse, camera);\n    const intersects = (_b = this.raycaster) == null ? void 0 : _b.intersectObjects([this.scene], true);\n    const length = intersects == null ? void 0 : intersects.length;\n    if (length && length > 0) {\n      let group = null;\n      for (let i = 0; i < length; i++) {\n        const object = intersects[i];\n        group = this._getGroup(object.object);\n        if (group !== null) {\n          break;\n        }\n      }\n      return group;\n    }\n    return null;\n  }\n  _getGroup(object) {\n    if (!object) {\n      return null;\n    }\n    if (object.isCustomGroup) {\n      return object;\n    }\n    return this._getGroup(object.parent);\n  }\n  destroy() {\n    this.ubBindEvents();\n    if (this.envMap) {\n      this.envMap.dispose();\n      this.envMap = null;\n    }\n    super.destroy();\n    this.lightTypes = null;\n    this.raycaster = void 0;\n  }\n}\nexport { CustomThreeLayer as default };","map":{"version":3,"mappings":"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","names":["ThreeLayer","constructor","map","callback","options","render","scene","raycaster","Raycaster","axesHelper","AxesHelper","add","lights","createHDR","AmbientLight","DirectionalLight","HemisphereLight","PointLight","RectAreaLight","SpotLight","mouse","Vector2","createEffect","size","renderer","getSize","EffectComposer","effectComposer","renderPass","ThreeRenderPass","addPass","pass","passList","push","removePass","indexOf","index","splice","createLights","defaultLightOptions","type","args","forEach","lightOptions","lightTypes","light","position","lookAt","set","x","y","console","warn","hdr","merge","urls","path","exposure","physicallyCorrectLights","outputEncoding","toneMappingExposure","hdrUrls","PMREMGenerator","pmremGenerator","HDRCubeTextureLoader","fromCubemap","hdrCubeMap","magFilter","needsUpdate","hdrCubeRenderTarget","texture","addEnvMap","object","environment","bindEvents","bind","_clickEvent","_hoverEvent","on","ubBindEvents","off","e","_intersectGltf","group","$emit","isHover","_a","children","getBoundingClientRect","client","offsetTop","top","pageYOffset","offsetLeft","left","pageXOffset","originEvent","window","camera","setFromCamera","intersects","_b","intersectObjects","length","i","_getGroup","isCustomGroup","destroy","envMap"],"sources":["../../../../../../src/packages/three/ThreeLayer/CustomThreeLayer.ts"],"sourcesContent":["import {\r\n  AmbientLight,\r\n  DirectionalLight,\r\n  HemisphereLight,\r\n  PointLight,\r\n  RectAreaLight,\r\n  SpotLight,\r\n  PMREMGenerator,\r\n  sRGBEncoding,\r\n  LinearFilter,\r\n  Vector2,\r\n  AxesHelper,\r\n  Raycaster\r\n} from 'three';\r\nimport {merge, bind} from \"lodash-es\";\r\nimport {HDRCubeTextureLoader} from \"three/examples/jsm/loaders/HDRCubeTextureLoader.js\";\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\r\nimport {ThreeLayer} from '@amap/three-layer'\r\nimport { ThreeRenderPass } from './ThreeRenderPass.js';\r\nimport type { Texture, Camera,\r\n  WebGLRenderer,\r\n  Scene} from 'three';\r\nimport type {HDROptions, LightOption} from \"./Type\";\r\nimport type {ThreeLayerOptions} from '@amap/three-layer'\r\n\r\ninterface Options extends ThreeLayerOptions{\r\n  lights?: LightOption[] // 灯光数组\r\n  hdr?: HDROptions // 开启HDR配置\r\n  axesHelper: boolean // 是否开启箭头，用于debug，默认不开启\r\n\r\n}\r\n\r\nclass CustomThreeLayer extends ThreeLayer{\r\n\r\n  lightTypes = {\r\n    AmbientLight, // 环境光  环境光会均匀的照亮场景中的所有物体\r\n    DirectionalLight, // 平行光  平行光是沿着特定方向发射的光\r\n    HemisphereLight, // 半球光  光源直接放置于场景之上，光照颜色从天空光线颜色渐变到地面光线颜色。\r\n    PointLight, // 点光源  从一个点向各个方向发射的光源。一个常见的例子是模拟一个灯泡发出的光\r\n    RectAreaLight, // 平面光光源  平面光光源从一个矩形平面上均匀地发射光线。这种光源可以用来模拟像明亮的窗户或者条状灯光光源\r\n    SpotLight // 聚光灯  光线从一个点沿一个方向射出，随着光线照射的变远，光线圆锥体的尺寸也逐渐增大\r\n  }\r\n  raycaster: Raycaster | undefined // 射线，用于判断点击或者鼠标移动是否碰到物体\r\n  mouse: Vector2;\r\n  envMap: any; // HDR的环境贴图\r\n  clickFun: any;\r\n  hoverFun: any;\r\n  effectComposer: any\r\n  renderPass: any\r\n  passNum = 0\r\n  passList = [] as any[]\r\n\r\n  constructor(map: any, options: Options, callback: () => void) {\r\n    options.onInit = (render,scene) => {\r\n      this.raycaster = new Raycaster();\r\n      if(options.axesHelper){\r\n        const axesHelper = new AxesHelper( 10000 );\r\n        scene.add( axesHelper );\r\n      }\r\n      this.createEffect();\r\n      this.createLights(options.lights || []);\r\n      this.createHDR(options.hdr);\r\n      this.bindEvents();\r\n      if(callback){\r\n        callback()\r\n      }\r\n    }\r\n    super(map, options)\r\n    this.mouse = new Vector2();\r\n  }\r\n\r\n  createEffect() {\r\n    const size = this.renderer?.getSize( new Vector2() );\r\n    this.effectComposer = new EffectComposer( this.renderer as WebGLRenderer );\r\n    this.effectComposer.setSize( size?.x, size?.y );\r\n    const renderPass = new ThreeRenderPass( this.scene, this.camera );\r\n    this.renderPass = renderPass;\r\n    this.effectComposer.addPass(renderPass);\r\n  }\r\n\r\n  addPass(pass: any){\r\n    this.effectComposer.addPass(pass);\r\n    this.passNum++;\r\n    this.passList.push(pass);\r\n  }\r\n\r\n  removePass(pass: any){\r\n    const index = this.passList.indexOf( pass );\r\n    if ( index !== - 1 ) {\r\n      this.passList.splice( index, 1 );\r\n    }\r\n    this.effectComposer.removePass(pass);\r\n    this.passNum--;\r\n  }\r\n\r\n  createLights(lights: LightOption[] | undefined) {\r\n    const defaultLightOptions = {\r\n      type: 'DirectionalLight', // 灯光类型， 可选值见下面的字典\r\n      args: [] // 灯光初始化时需要的参数，具体参数顺序可以查看threejs官网灯光的说明。 采用 ...args 的方式进行初始化\r\n    };\r\n    if (lights && lights.length > 0) {\r\n      lights.forEach(lightOptions => {\r\n        lightOptions = merge({}, defaultLightOptions, lightOptions) as LightOption;\r\n        if (this.lightTypes[lightOptions.type]) {\r\n          const light = new this.lightTypes[lightOptions.type](...lightOptions.args);\r\n          const position = lightOptions.position;\r\n          const lookAt = lightOptions.lookAt;\r\n          if (position) {\r\n            light.position.set(position.x, position.y, position.z);\r\n          }\r\n          if (lookAt) {\r\n            light.lookAt(lookAt.x, lookAt.y, lookAt.z);\r\n          }\r\n          this.add(light);\r\n        } else {\r\n          console.warn('当前设置的灯光类型不存在');\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  createHDR(hdr: HDROptions | undefined) {\r\n    if (!hdr) {\r\n      return;\r\n    }\r\n    const options = merge({}, {\r\n      urls: [], // HDR贴图下载地址，需要6个文件，代表6个方向\r\n      path: '/', // HDR下载地址的路径前缀\r\n      // roughness: 0.0,\r\n      exposure: 1.0 // 光亮程度\r\n    }, hdr);\r\n    const render = this.renderer as WebGLRenderer;\r\n    render.physicallyCorrectLights = true;\r\n    render.outputEncoding = sRGBEncoding;\r\n    render.toneMappingExposure = options.exposure;\r\n    const hdrUrls = options.urls;\r\n    let pmremGenerator: PMREMGenerator = new PMREMGenerator(render);\r\n    pmremGenerator.compileCubemapShader();\r\n    const hdrCubeMap = new HDRCubeTextureLoader()\r\n      .setPath(options.path)\r\n      .load(hdrUrls, () => {\r\n        const hdrCubeRenderTarget = pmremGenerator.fromCubemap(hdrCubeMap);\r\n        hdrCubeMap.magFilter = LinearFilter;\r\n        hdrCubeMap.needsUpdate = true;\r\n        this.envMap = hdrCubeRenderTarget ? hdrCubeRenderTarget.texture : null;\r\n        this.addEnvMap(this.scene);\r\n        pmremGenerator.dispose();\r\n        pmremGenerator = null as any;\r\n        this.refreshMap();\r\n      }) as any;\r\n  }\r\n\r\n  addEnvMap(object) {\r\n    this.scene!.environment = this.envMap as Texture;\r\n    /*const envMap = this.envMap;\r\n    if (!envMap || !object) {\r\n      return;\r\n    }\r\n    if (object.material && envMap) {\r\n      object.material.envMap = envMap;\r\n      // object.material.roughness = 0;\r\n      object.material.needsUpdate = true;\r\n    }\r\n    if (object.children && object.children.length > 0) {\r\n      object.children.forEach(o => {\r\n        this.addEnvMap(o);\r\n      });\r\n    }*/\r\n  }\r\n\r\n  bindEvents() {\r\n    this.clickFun = bind(this._clickEvent, this);\r\n    this.hoverFun = bind(this._hoverEvent, this);\r\n    this.map.on('click', this.clickFun);\r\n    this.map.on('mousemove', this.hoverFun);\r\n  }\r\n\r\n  ubBindEvents() {\r\n    this.map.off('click', this.clickFun);\r\n    this.map.off('mousemove', this.hoverFun);\r\n  }\r\n\r\n  _clickEvent(e) {\r\n    const group = this._intersectGltf(e) as any;\r\n    if (group) {\r\n      group.$vue.$emit('click', group);\r\n    }\r\n  }\r\n\r\n  _hoverEvent(e) {\r\n    const group = this._intersectGltf(e) as any;\r\n    if (group) {\r\n      if (!group.isHover) {\r\n        group.isHover = true;\r\n        group.$vue.$emit('mouseover', group);\r\n      }\r\n    } else {\r\n      const children = this.scene?.children;\r\n      children?.forEach((object: any) => {\r\n        if (object.isCustomGroup && object.isHover === true) {\r\n          object.isHover = false;\r\n          object.$vue.$emit('mouseout', object);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  _intersectGltf(e) {\r\n    const client = this.map.getContainer();\r\n    // 通过鼠标点击位置,计算出 raycaster 所需点的位置,以屏幕为中心点,范围 -1 到 1\r\n    const getBoundingClientRect = client.getBoundingClientRect();\r\n\r\n    // window.pageYOffset 鼠标滚动的距离\r\n    // clientTop 一个元素顶部边框的宽度\r\n    const offsetTop = getBoundingClientRect.top + window.pageYOffset - client.clientTop;\r\n    const offsetLeft = getBoundingClientRect.left + window.pageXOffset - client.clientLeft;\r\n    this.mouse.x = ((e.originEvent.x + window.pageXOffset - offsetLeft) / getBoundingClientRect.width) * 2 - 1;\r\n    this.mouse.y = -((e.originEvent.y + window.pageYOffset - offsetTop) / getBoundingClientRect.height) * 2 + 1;\r\n    const camera = this.camera;\r\n    this.raycaster?.setFromCamera(this.mouse, camera as Camera);\r\n    const intersects = this.raycaster?.intersectObjects([this.scene as Scene], true);\r\n    const length = intersects?.length;\r\n    if (length && length > 0) {\r\n      let group = null;\r\n      for (let i = 0; i < length; i++) {\r\n        const object = intersects[i];\r\n        group = this._getGroup(object.object);\r\n        if (group !== null) {\r\n          break;\r\n        }\r\n      }\r\n      return group;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _getGroup(object) {\r\n    if(!object){\r\n      return null;\r\n    }\r\n    if (object.isCustomGroup) {\r\n      return object;\r\n    }\r\n    return this._getGroup(object.parent);\r\n  }\r\n\r\n  destroy() {\r\n    this.ubBindEvents();\r\n    if (this.envMap) {\r\n      this.envMap.dispose();\r\n      this.envMap = null;\r\n    }\r\n    super.destroy();\r\n    this.lightTypes = null as any;\r\n    this.raycaster = undefined;\r\n    // this.mouse = undefined;\r\n  }\r\n\r\n\r\n}\r\n\r\nexport default CustomThreeLayer\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
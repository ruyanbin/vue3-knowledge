{"ast":null,"code":"import Sortable from \"sortablejs\";\nimport { insertNodeAt, removeNode } from \"./util/htmlHelper\";\nimport { console } from \"./util/console\";\nimport { getComponentAttributes, createSortableOption, getValidSortableEntries } from \"./core/componentBuilderHelper\";\nimport { computeComponentStructure } from \"./core/renderHelper\";\nimport { events } from \"./core/sortableEvents\";\nimport { h, defineComponent, nextTick } from \"vue\";\nfunction emit(evtName, evtData) {\n  nextTick(() => this.$emit(evtName.toLowerCase(), evtData));\n}\nfunction manage(evtName) {\n  return (evtData, originalElement) => {\n    if (this.realList !== null) {\n      return this[`onDrag${evtName}`](evtData, originalElement);\n    }\n  };\n}\nfunction manageAndEmit(evtName) {\n  const delegateCallBack = manage.call(this, evtName);\n  return (evtData, originalElement) => {\n    delegateCallBack.call(this, evtData, originalElement);\n    emit.call(this, evtName, evtData);\n  };\n}\nlet draggingElement = null;\nconst props = {\n  list: {\n    type: Array,\n    required: false,\n    default: null\n  },\n  modelValue: {\n    type: Array,\n    required: false,\n    default: null\n  },\n  itemKey: {\n    type: [String, Function],\n    required: true\n  },\n  clone: {\n    type: Function,\n    default: original => {\n      return original;\n    }\n  },\n  tag: {\n    type: String,\n    default: \"div\"\n  },\n  move: {\n    type: Function,\n    default: null\n  },\n  componentData: {\n    type: Object,\n    required: false,\n    default: null\n  }\n};\nconst emits = [\"update:modelValue\", \"change\", ...[...events.manageAndEmit, ...events.emit].map(evt => evt.toLowerCase())];\nconst draggableComponent = defineComponent({\n  name: \"draggable\",\n  inheritAttrs: false,\n  props,\n  emits,\n  data() {\n    return {\n      error: false\n    };\n  },\n  render() {\n    try {\n      this.error = false;\n      const {\n        $slots,\n        $attrs,\n        tag,\n        componentData,\n        realList,\n        getKey\n      } = this;\n      const componentStructure = computeComponentStructure({\n        $slots,\n        tag,\n        realList,\n        getKey\n      });\n      this.componentStructure = componentStructure;\n      const attributes = getComponentAttributes({\n        $attrs,\n        componentData\n      });\n      return componentStructure.render(h, attributes);\n    } catch (err) {\n      this.error = true;\n      return h(\"pre\", {\n        style: {\n          color: \"red\"\n        }\n      }, err.stack);\n    }\n  },\n  created() {\n    if (this.list !== null && this.modelValue !== null) {\n      console.error(\"modelValue and list props are mutually exclusive! Please set one or another.\");\n    }\n  },\n  mounted() {\n    if (this.error) {\n      return;\n    }\n    const {\n      $attrs,\n      $el,\n      componentStructure\n    } = this;\n    componentStructure.updated();\n    const sortableOptions = createSortableOption({\n      $attrs,\n      callBackBuilder: {\n        manageAndEmit: event => manageAndEmit.call(this, event),\n        emit: event => emit.bind(this, event),\n        manage: event => manage.call(this, event)\n      }\n    });\n    const targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;\n    this._sortable = new Sortable(targetDomElement, sortableOptions);\n    this.targetDomElement = targetDomElement;\n    targetDomElement.__draggable_component__ = this;\n  },\n  updated() {\n    this.componentStructure.updated();\n  },\n  beforeUnmount() {\n    if (this._sortable !== undefined) this._sortable.destroy();\n  },\n  computed: {\n    realList() {\n      const {\n        list\n      } = this;\n      return list ? list : this.modelValue;\n    },\n    getKey() {\n      const {\n        itemKey\n      } = this;\n      if (typeof itemKey === \"function\") {\n        return itemKey;\n      }\n      return element => element[itemKey];\n    }\n  },\n  watch: {\n    $attrs: {\n      handler(newOptionValue) {\n        const {\n          _sortable\n        } = this;\n        if (!_sortable) return;\n        getValidSortableEntries(newOptionValue).forEach(([key, value]) => {\n          _sortable.option(key, value);\n        });\n      },\n      deep: true\n    }\n  },\n  methods: {\n    getUnderlyingVm(domElement) {\n      return this.componentStructure.getUnderlyingVm(domElement) || null;\n    },\n    getUnderlyingPotencialDraggableComponent(htmElement) {\n      //TODO check case where you need to see component children\n      return htmElement.__draggable_component__;\n    },\n    emitChanges(evt) {\n      nextTick(() => this.$emit(\"change\", evt));\n    },\n    alterList(onList) {\n      if (this.list) {\n        onList(this.list);\n        return;\n      }\n      const newList = [...this.modelValue];\n      onList(newList);\n      this.$emit(\"update:modelValue\", newList);\n    },\n    spliceList() {\n      const spliceList = list => list.splice(...arguments);\n      this.alterList(spliceList);\n    },\n    updatePosition(oldIndex, newIndex) {\n      const updatePosition = list => list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);\n      this.alterList(updatePosition);\n    },\n    getRelatedContextFromMoveEvent({\n      to,\n      related\n    }) {\n      const component = this.getUnderlyingPotencialDraggableComponent(to);\n      if (!component) {\n        return {\n          component\n        };\n      }\n      const list = component.realList;\n      const context = {\n        list,\n        component\n      };\n      if (to !== related && list) {\n        const destination = component.getUnderlyingVm(related) || {};\n        return {\n          ...destination,\n          ...context\n        };\n      }\n      return context;\n    },\n    getVmIndexFromDomIndex(domIndex) {\n      return this.componentStructure.getVmIndexFromDomIndex(domIndex, this.targetDomElement);\n    },\n    onDragStart(evt) {\n      this.context = this.getUnderlyingVm(evt.item);\n      evt.item._underlying_vm_ = this.clone(this.context.element);\n      draggingElement = evt.item;\n    },\n    onDragAdd(evt) {\n      const element = evt.item._underlying_vm_;\n      if (element === undefined) {\n        return;\n      }\n      removeNode(evt.item);\n      const newIndex = this.getVmIndexFromDomIndex(evt.newIndex);\n      this.spliceList(newIndex, 0, element);\n      const added = {\n        element,\n        newIndex\n      };\n      this.emitChanges({\n        added\n      });\n    },\n    onDragRemove(evt) {\n      insertNodeAt(this.$el, evt.item, evt.oldIndex);\n      if (evt.pullMode === \"clone\") {\n        removeNode(evt.clone);\n        return;\n      }\n      const {\n        index: oldIndex,\n        element\n      } = this.context;\n      this.spliceList(oldIndex, 1);\n      const removed = {\n        element,\n        oldIndex\n      };\n      this.emitChanges({\n        removed\n      });\n    },\n    onDragUpdate(evt) {\n      removeNode(evt.item);\n      insertNodeAt(evt.from, evt.item, evt.oldIndex);\n      const oldIndex = this.context.index;\n      const newIndex = this.getVmIndexFromDomIndex(evt.newIndex);\n      this.updatePosition(oldIndex, newIndex);\n      const moved = {\n        element: this.context.element,\n        oldIndex,\n        newIndex\n      };\n      this.emitChanges({\n        moved\n      });\n    },\n    computeFutureIndex(relatedContext, evt) {\n      if (!relatedContext.element) {\n        return 0;\n      }\n      const domChildren = [...evt.to.children].filter(el => el.style[\"display\"] !== \"none\");\n      const currentDomIndex = domChildren.indexOf(evt.related);\n      const currentIndex = relatedContext.component.getVmIndexFromDomIndex(currentDomIndex);\n      const draggedInList = domChildren.indexOf(draggingElement) !== -1;\n      return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;\n    },\n    onDragMove(evt, originalEvent) {\n      const {\n        move,\n        realList\n      } = this;\n      if (!move || !realList) {\n        return true;\n      }\n      const relatedContext = this.getRelatedContextFromMoveEvent(evt);\n      const futureIndex = this.computeFutureIndex(relatedContext, evt);\n      const draggedContext = {\n        ...this.context,\n        futureIndex\n      };\n      const sendEvent = {\n        ...evt,\n        relatedContext,\n        draggedContext\n      };\n      return move(sendEvent, originalEvent);\n    },\n    onDragEnd() {\n      draggingElement = null;\n    }\n  }\n});\nexport default draggableComponent;","map":{"version":3,"names":["Sortable","insertNodeAt","removeNode","console","getComponentAttributes","createSortableOption","getValidSortableEntries","computeComponentStructure","events","h","defineComponent","nextTick","emit","evtName","evtData","$emit","toLowerCase","manage","originalElement","realList","manageAndEmit","delegateCallBack","call","draggingElement","props","list","type","Array","required","default","modelValue","itemKey","String","Function","clone","original","tag","move","componentData","Object","emits","map","evt","draggableComponent","name","inheritAttrs","data","error","render","$slots","$attrs","getKey","componentStructure","attributes","err","style","color","stack","created","mounted","$el","updated","sortableOptions","callBackBuilder","event","bind","targetDomElement","nodeType","parentElement","_sortable","__draggable_component__","beforeUnmount","undefined","destroy","computed","element","watch","handler","newOptionValue","forEach","key","value","option","deep","methods","getUnderlyingVm","domElement","getUnderlyingPotencialDraggableComponent","htmElement","emitChanges","alterList","onList","newList","spliceList","splice","arguments","updatePosition","oldIndex","newIndex","getRelatedContextFromMoveEvent","to","related","component","context","destination","getVmIndexFromDomIndex","domIndex","onDragStart","item","_underlying_vm_","onDragAdd","added","onDragRemove","pullMode","index","removed","onDragUpdate","from","moved","computeFutureIndex","relatedContext","domChildren","children","filter","el","currentDomIndex","indexOf","currentIndex","draggedInList","willInsertAfter","onDragMove","originalEvent","futureIndex","draggedContext","sendEvent","onDragEnd"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/vuedraggable/src/vuedraggable.js"],"sourcesContent":["import Sortable from \"sortablejs\";\r\nimport { insertNodeAt, removeNode } from \"./util/htmlHelper\";\r\nimport { console } from \"./util/console\";\r\nimport {\r\n  getComponentAttributes,\r\n  createSortableOption,\r\n  getValidSortableEntries\r\n} from \"./core/componentBuilderHelper\";\r\nimport { computeComponentStructure } from \"./core/renderHelper\";\r\nimport { events } from \"./core/sortableEvents\";\r\nimport { h, defineComponent, nextTick } from \"vue\";\r\n\r\nfunction emit(evtName, evtData) {\r\n  nextTick(() => this.$emit(evtName.toLowerCase(), evtData));\r\n}\r\n\r\nfunction manage(evtName) {\r\n  return (evtData, originalElement) => {\r\n    if (this.realList !== null) {\r\n      return this[`onDrag${evtName}`](evtData, originalElement);\r\n    }\r\n  };\r\n}\r\n\r\nfunction manageAndEmit(evtName) {\r\n  const delegateCallBack = manage.call(this, evtName);\r\n  return (evtData, originalElement) => {\r\n    delegateCallBack.call(this, evtData, originalElement);\r\n    emit.call(this, evtName, evtData);\r\n  };\r\n}\r\n\r\nlet draggingElement = null;\r\n\r\nconst props = {\r\n  list: {\r\n    type: Array,\r\n    required: false,\r\n    default: null\r\n  },\r\n  modelValue: {\r\n    type: Array,\r\n    required: false,\r\n    default: null\r\n  },\r\n  itemKey: {\r\n    type: [String, Function],\r\n    required: true\r\n  },\r\n  clone: {\r\n    type: Function,\r\n    default: original => {\r\n      return original;\r\n    }\r\n  },\r\n  tag: {\r\n    type: String,\r\n    default: \"div\"\r\n  },\r\n  move: {\r\n    type: Function,\r\n    default: null\r\n  },\r\n  componentData: {\r\n    type: Object,\r\n    required: false,\r\n    default: null\r\n  }\r\n};\r\n\r\nconst emits = [\r\n  \"update:modelValue\",\r\n  \"change\",\r\n  ...[...events.manageAndEmit, ...events.emit].map(evt => evt.toLowerCase())\r\n];\r\n\r\nconst draggableComponent = defineComponent({\r\n  name: \"draggable\",\r\n\r\n  inheritAttrs: false,\r\n\r\n  props,\r\n\r\n  emits,\r\n\r\n  data() {\r\n    return {\r\n      error: false\r\n    };\r\n  },\r\n\r\n  render() {\r\n    try {\r\n      this.error = false;\r\n      const { $slots, $attrs, tag, componentData, realList, getKey } = this;\r\n      const componentStructure = computeComponentStructure({\r\n        $slots,\r\n        tag,\r\n        realList,\r\n        getKey\r\n      });\r\n      this.componentStructure = componentStructure;\r\n      const attributes = getComponentAttributes({ $attrs, componentData });\r\n      return componentStructure.render(h, attributes);\r\n    } catch (err) {\r\n      this.error = true;\r\n      return h(\"pre\", { style: { color: \"red\" } }, err.stack);\r\n    }\r\n  },\r\n\r\n  created() {\r\n    if (this.list !== null && this.modelValue !== null) {\r\n      console.error(\r\n        \"modelValue and list props are mutually exclusive! Please set one or another.\"\r\n      );\r\n    }\r\n  },\r\n\r\n  mounted() {\r\n    if (this.error) {\r\n      return;\r\n    }\r\n\r\n    const { $attrs, $el, componentStructure } = this;\r\n    componentStructure.updated();\r\n\r\n    const sortableOptions = createSortableOption({\r\n      $attrs,\r\n      callBackBuilder: {\r\n        manageAndEmit: event => manageAndEmit.call(this, event),\r\n        emit: event => emit.bind(this, event),\r\n        manage: event => manage.call(this, event)\r\n      }\r\n    });\r\n    const targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;\r\n    this._sortable = new Sortable(targetDomElement, sortableOptions);\r\n    this.targetDomElement = targetDomElement;\r\n    targetDomElement.__draggable_component__ = this;\r\n  },\r\n\r\n  updated() {\r\n    this.componentStructure.updated();\r\n  },\r\n\r\n  beforeUnmount() {\r\n    if (this._sortable !== undefined) this._sortable.destroy();\r\n  },\r\n\r\n  computed: {\r\n    realList() {\r\n      const { list } = this;\r\n      return list ? list : this.modelValue;\r\n    },\r\n\r\n    getKey() {\r\n      const { itemKey } = this;\r\n      if (typeof itemKey === \"function\") {\r\n        return itemKey;\r\n      }\r\n      return element => element[itemKey];\r\n    }\r\n  },\r\n\r\n  watch: {\r\n    $attrs: {\r\n      handler(newOptionValue) {\r\n        const { _sortable } = this;\r\n        if (!_sortable) return;\r\n        getValidSortableEntries(newOptionValue).forEach(([key, value]) => {\r\n          _sortable.option(key, value);\r\n        });\r\n      },\r\n      deep: true\r\n    }\r\n  },\r\n\r\n  methods: {\r\n    getUnderlyingVm(domElement) {\r\n      return this.componentStructure.getUnderlyingVm(domElement) || null;\r\n    },\r\n\r\n    getUnderlyingPotencialDraggableComponent(htmElement) {\r\n      //TODO check case where you need to see component children\r\n      return htmElement.__draggable_component__;\r\n    },\r\n\r\n    emitChanges(evt) {\r\n      nextTick(() => this.$emit(\"change\", evt));\r\n    },\r\n\r\n    alterList(onList) {\r\n      if (this.list) {\r\n        onList(this.list);\r\n        return;\r\n      }\r\n      const newList = [...this.modelValue];\r\n      onList(newList);\r\n      this.$emit(\"update:modelValue\", newList);\r\n    },\r\n\r\n    spliceList() {\r\n      const spliceList = list => list.splice(...arguments);\r\n      this.alterList(spliceList);\r\n    },\r\n\r\n    updatePosition(oldIndex, newIndex) {\r\n      const updatePosition = list =>\r\n        list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);\r\n      this.alterList(updatePosition);\r\n    },\r\n\r\n    getRelatedContextFromMoveEvent({ to, related }) {\r\n      const component = this.getUnderlyingPotencialDraggableComponent(to);\r\n      if (!component) {\r\n        return { component };\r\n      }\r\n      const list = component.realList;\r\n      const context = { list, component };\r\n      if (to !== related && list) {\r\n        const destination = component.getUnderlyingVm(related) || {};\r\n        return { ...destination, ...context };\r\n      }\r\n      return context;\r\n    },\r\n\r\n    getVmIndexFromDomIndex(domIndex) {\r\n      return this.componentStructure.getVmIndexFromDomIndex(\r\n        domIndex,\r\n        this.targetDomElement\r\n      );\r\n    },\r\n\r\n    onDragStart(evt) {\r\n      this.context = this.getUnderlyingVm(evt.item);\r\n      evt.item._underlying_vm_ = this.clone(this.context.element);\r\n      draggingElement = evt.item;\r\n    },\r\n\r\n    onDragAdd(evt) {\r\n      const element = evt.item._underlying_vm_;\r\n      if (element === undefined) {\r\n        return;\r\n      }\r\n      removeNode(evt.item);\r\n      const newIndex = this.getVmIndexFromDomIndex(evt.newIndex);\r\n      this.spliceList(newIndex, 0, element);\r\n      const added = { element, newIndex };\r\n      this.emitChanges({ added });\r\n    },\r\n\r\n    onDragRemove(evt) {\r\n      insertNodeAt(this.$el, evt.item, evt.oldIndex);\r\n      if (evt.pullMode === \"clone\") {\r\n        removeNode(evt.clone);\r\n        return;\r\n      }\r\n      const { index: oldIndex, element } = this.context;\r\n      this.spliceList(oldIndex, 1);\r\n      const removed = { element, oldIndex };\r\n      this.emitChanges({ removed });\r\n    },\r\n\r\n    onDragUpdate(evt) {\r\n      removeNode(evt.item);\r\n      insertNodeAt(evt.from, evt.item, evt.oldIndex);\r\n      const oldIndex = this.context.index;\r\n      const newIndex = this.getVmIndexFromDomIndex(evt.newIndex);\r\n      this.updatePosition(oldIndex, newIndex);\r\n      const moved = { element: this.context.element, oldIndex, newIndex };\r\n      this.emitChanges({ moved });\r\n    },\r\n\r\n    computeFutureIndex(relatedContext, evt) {\r\n      if (!relatedContext.element) {\r\n        return 0;\r\n      }\r\n      const domChildren = [...evt.to.children].filter(\r\n        el => el.style[\"display\"] !== \"none\"\r\n      );\r\n      const currentDomIndex = domChildren.indexOf(evt.related);\r\n      const currentIndex = relatedContext.component.getVmIndexFromDomIndex(\r\n        currentDomIndex\r\n      );\r\n      const draggedInList = domChildren.indexOf(draggingElement) !== -1;\r\n      return draggedInList || !evt.willInsertAfter\r\n        ? currentIndex\r\n        : currentIndex + 1;\r\n    },\r\n\r\n    onDragMove(evt, originalEvent) {\r\n      const { move, realList } = this;\r\n      if (!move || !realList) {\r\n        return true;\r\n      }\r\n\r\n      const relatedContext = this.getRelatedContextFromMoveEvent(evt);\r\n      const futureIndex = this.computeFutureIndex(relatedContext, evt);\r\n      const draggedContext = {\r\n        ...this.context,\r\n        futureIndex\r\n      };\r\n      const sendEvent = {\r\n        ...evt,\r\n        relatedContext,\r\n        draggedContext\r\n      };\r\n      return move(sendEvent, originalEvent);\r\n    },\r\n\r\n    onDragEnd() {\r\n      draggingElement = null;\r\n    }\r\n  }\r\n});\r\n\r\nexport default draggableComponent;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
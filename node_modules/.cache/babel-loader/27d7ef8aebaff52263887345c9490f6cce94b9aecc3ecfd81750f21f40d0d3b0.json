{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent } from 'vue';\nimport upperCamelCase from 'uppercamelcase';\nimport eventHelper from '../utils/event-helper.mjs';\nimport { eventReg, convertEventToLowerCase } from '../utils/util.mjs';\nvar registerMixin = defineComponent({\n  inject: {\n    parentInstance: {\n      default: null\n    }\n  },\n  inheritAttrs: false,\n  props: {\n    visible: {\n      type: Boolean,\n      default: true\n    },\n    zIndex: {\n      type: Number\n    },\n    reEventWhenUpdate: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: [\"init\"],\n  data() {\n    return {\n      needInitComponents: [],\n      unwatchFns: [],\n      propsRedirect: {},\n      converters: {},\n      isDestroy: false,\n      cacheEvents: {},\n      isMounted: false\n    };\n  },\n  created() {\n    this.$amapComponent = null;\n    this.$parentComponent = null;\n  },\n  mounted() {\n    if (this.parentInstance) {\n      if (this.parentInstance.$amapComponent) {\n        this.register();\n      } else {\n        this.parentInstance.addChildComponent(this);\n      }\n    }\n  },\n  beforeUnmount() {\n    if (!this.$amapComponent) return;\n    this.unregisterEvents();\n    this.unwatchFns.forEach(item => item());\n    this.unwatchFns = [];\n    this.destroyComponent();\n    this.isDestroy = true;\n  },\n  beforeUpdate() {\n    if (this.reEventWhenUpdate && this.isMounted && this.$amapComponent) {\n      this.unregisterEvents();\n    }\n  },\n  updated() {\n    if (this.reEventWhenUpdate && this.isMounted && this.$amapComponent) {\n      this.registerEvents();\n    }\n  },\n  methods: {\n    getHandlerFun(prop) {\n      if (this[`__${prop}`]) {\n        return this[`__${prop}`];\n      }\n      if (!this.$amapComponent) {\n        return null;\n      }\n      return this.$amapComponent[`set${upperCamelCase(prop)}`];\n    },\n    convertProps() {\n      const props = {};\n      const {\n        $props,\n        propsRedirect\n      } = this;\n      return Object.keys($props).reduce((res, _key) => {\n        let key = _key;\n        const propsValue = this.convertSignalProp(key, $props[key]);\n        if (propsValue === void 0) return res;\n        if (propsRedirect && propsRedirect[_key]) key = propsRedirect[key];\n        props[key] = propsValue;\n        return res;\n      }, props);\n    },\n    convertSignalProp(key, sourceData) {\n      if (this.converters && this.converters[key]) {\n        return this.converters[key].call(this, sourceData);\n      }\n      return sourceData;\n    },\n    registerEvents() {\n      const $props = this.$attrs;\n      Object.keys($props).forEach(key => {\n        if (eventReg.test(key)) {\n          const eventKey = convertEventToLowerCase(key);\n          eventHelper.addListener(this.$amapComponent, eventKey, $props[key]);\n          this.cacheEvents[eventKey] = $props[key];\n        }\n      });\n    },\n    unregisterEvents() {\n      Object.keys(this.cacheEvents).forEach(eventKey => {\n        eventHelper.removeListener(this.$amapComponent, eventKey, this.cacheEvents[eventKey]);\n        delete this.cacheEvents[eventKey];\n      });\n    },\n    setPropWatchers() {\n      const {\n        propsRedirect,\n        $props\n      } = this;\n      Object.keys($props).forEach(prop => {\n        let handleProp = prop;\n        if (propsRedirect && propsRedirect[prop]) handleProp = propsRedirect[prop];\n        const handleFun = this.getHandlerFun(handleProp);\n        if (!handleFun) return;\n        const watchOptions = {\n          deep: false\n        };\n        const propValueType = Object.prototype.toString.call($props[prop]);\n        if (propValueType === \"[object Object]\" || propValueType === \"[object Array]\") {\n          watchOptions.deep = true;\n        }\n        const unwatch = this.$watch(prop, nv => {\n          handleFun.call(this.$amapComponent, this.convertSignalProp(prop, nv));\n        }, watchOptions);\n        this.unwatchFns.push(unwatch);\n      });\n    },\n    initProps() {\n      const props = [\"editable\", \"visible\", \"zooms\"];\n      props.forEach(propStr => {\n        if (this[propStr] !== void 0) {\n          const handleFun = this.getHandlerFun(propStr);\n          handleFun && handleFun.call(this.$amapComponent, this.convertSignalProp(propStr, this[propStr]));\n        }\n      });\n    },\n    lazyRegister() {\n      const $parent = this.parentInstance;\n      if ($parent && $parent.addChildComponent) {\n        $parent.addChildComponent(this);\n      }\n    },\n    addChildComponent(component) {\n      this.needInitComponents.push(component);\n    },\n    createChildren() {\n      while (this.needInitComponents.length > 0) {\n        this.needInitComponents[0].register();\n        this.needInitComponents.splice(0, 1);\n      }\n    },\n    register() {\n      if (this.parentInstance && !this.$parentComponent) {\n        this.$parentComponent = this.parentInstance.$amapComponent;\n      }\n      const res = this[\"__initComponent\"] && this[\"__initComponent\"](this.convertProps());\n      if (res && res.then) res.then(instance => this.registerRest(instance));else this.registerRest(res);\n    },\n    registerRest(instance) {\n      if (!this.$amapComponent && instance) this.$amapComponent = instance;\n      this.registerEvents();\n      this.initProps();\n      this.setPropWatchers();\n      this.$emit(\"init\", this.$amapComponent, this);\n      this.$nextTick(() => {\n        this.createChildren();\n      });\n      this.isMounted = true;\n    },\n    $$getInstance() {\n      return this.$amapComponent;\n    },\n    destroyComponent() {\n      this.$amapComponent.setMap && this.$amapComponent.setMap(null);\n      this.$amapComponent.close && this.$amapComponent.close();\n      this.$amapComponent.editor && this.$amapComponent.editor.close();\n    },\n    __visible(flag) {\n      if (!!this.$amapComponent && !!this.$amapComponent.show && !!this.$amapComponent.hide) {\n        flag === false ? this.$amapComponent.hide() : this.$amapComponent.show();\n      }\n    },\n    __zIndex(value) {\n      if (this.$amapComponent && this.$amapComponent.setzIndex) {\n        this.$amapComponent.setzIndex(value);\n      }\n    }\n  }\n});\nexport { registerMixin as default };","map":{"version":3,"mappings":"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","names":["defineComponent","inject","parentInstance","default","inheritAttrs","props","visible","type","zIndex","reEventWhenUpdate","emits","data","needInitComponents","unwatchFns","propsRedirect","converters","isDestroy","cacheEvents","isMounted","created","$amapComponent","$parentComponent","mounted","addChildComponent","beforeUnmount","forEach","item","beforeUpdate","updated","methods","getHandlerFun","prop","upperCamelCase","convertProps","$props","Object","keys","reduce","res","_key","key","propsValue","convertSignalProp","sourceData","registerEvents","test","eventKey","convertEventToLowerCase","eventHelper","addListener","unregisterEvents","removeListener","setPropWatchers","handleProp","handleFun","watchOptions","deep","propValueType","prototype","call","unwatch","$watch","nv","push","initProps","propStr","lazyRegister","$parent","component","createChildren","splice","register","then","instance","registerRest","$nextTick","$$getInstance","destroyComponent","setMap","close","editor","__visible","flag","show","hide","__zIndex","value","setzIndex"],"sources":["../../../../src/mixins/register-component.ts"],"sourcesContent":["import {defineComponent} from \"vue\";\r\nimport upperCamelCase from 'uppercamelcase';\r\nimport eventHelper from '../utils/event-helper';\r\nimport {convertEventToLowerCase, eventReg} from \"../utils/util\";\r\nimport type {WatchStopHandle, ComponentPublicInstance} from \"vue\";\r\n\r\nexport default defineComponent({\r\n  inject: {\r\n    parentInstance: {\r\n      default: null\r\n    }\r\n  },\r\n  inheritAttrs: false,\r\n  props: {\r\n    visible: {\r\n      type: Boolean,\r\n      default: true\r\n    }, // 是否显示，默认 true\r\n    zIndex: {\r\n      type: Number\r\n    },\r\n    reEventWhenUpdate: {\r\n      type: Boolean,\r\n      default: false\r\n    } // 是否在组件更新时重新注册事件，主要用于数组更新时，绑定了事件但事件的对象不会更新问题\r\n  },\r\n  emits: ['init'],\r\n  data() {\r\n    return {\r\n      needInitComponents: [] as (ComponentPublicInstance & customComponent)[],\r\n      unwatchFns: [] as WatchStopHandle[],\r\n      propsRedirect: {},\r\n      converters: {},\r\n      isDestroy: false,\r\n      cacheEvents: {},\r\n      isMounted: false\r\n    };\r\n  },\r\n  created() {\r\n    this.$amapComponent = null as any;\r\n    this.$parentComponent = null as any;\r\n  },\r\n  mounted() {\r\n    if (this.parentInstance) {\r\n      if (this.parentInstance.$amapComponent) {\r\n        this.register();\r\n      } else {\r\n        this.parentInstance.addChildComponent(this);\r\n      }\r\n    }\r\n  },\r\n\r\n  beforeUnmount() {\r\n    if (!this.$amapComponent) return;\r\n    this.unregisterEvents();\r\n    this.unwatchFns.forEach(item => item());\r\n    this.unwatchFns = [];\r\n    this.destroyComponent();\r\n    this.isDestroy = true;\r\n  },\r\n  beforeUpdate() {\r\n    if(this.reEventWhenUpdate && this.isMounted && this.$amapComponent){\r\n      this.unregisterEvents();\r\n    }\r\n  },\r\n  updated() {\r\n    if(this.reEventWhenUpdate && this.isMounted && this.$amapComponent){\r\n      this.registerEvents();\r\n    }\r\n  },\r\n  methods: {\r\n    getHandlerFun(prop) {\r\n      if (this[`__${prop}`]) {\r\n        return this[`__${prop}`];\r\n      }\r\n      if(!this.$amapComponent){\r\n        return null;\r\n      }\r\n      return this.$amapComponent[`set${upperCamelCase(prop)}`];\r\n    },\r\n\r\n    convertProps() {\r\n      const props = {};\r\n      const {$props, propsRedirect} = this;\r\n      return Object.keys($props).reduce((res, _key) => {\r\n        let key = _key;\r\n        const propsValue = this.convertSignalProp(key, $props[key]);\r\n        if (propsValue === undefined) return res;\r\n        if (propsRedirect && propsRedirect[_key]) key = propsRedirect[key];\r\n        props[key] = propsValue;\r\n        return res;\r\n      }, props);\r\n    },\r\n\r\n    convertSignalProp(key, sourceData) {\r\n      if (this.converters && this.converters[key]) {\r\n        return this.converters[key].call(this, sourceData);\r\n      }\r\n      return sourceData;\r\n    },\r\n\r\n    registerEvents() {\r\n      const $props = this.$attrs;\r\n      Object.keys($props).forEach(key => {\r\n        if(eventReg.test(key)){\r\n          const eventKey = convertEventToLowerCase(key);\r\n          eventHelper.addListener(this.$amapComponent, eventKey, $props[key]);\r\n          this.cacheEvents[eventKey] = $props[key];\r\n        }\r\n      });\r\n    },\r\n\r\n    unregisterEvents() {\r\n      Object.keys(this.cacheEvents).forEach(eventKey => {\r\n        eventHelper.removeListener(this.$amapComponent, eventKey, this.cacheEvents[eventKey]);\r\n        delete this.cacheEvents[eventKey];\r\n      });\r\n    },\r\n\r\n    setPropWatchers() {\r\n      const {propsRedirect, $props} = this;\r\n\r\n      Object.keys($props).forEach(prop => {\r\n        let handleProp = prop;\r\n        if (propsRedirect && propsRedirect[prop]) handleProp = propsRedirect[prop];\r\n        const handleFun = this.getHandlerFun(handleProp);\r\n        if (!handleFun) return;\r\n        const watchOptions = {\r\n          deep: false\r\n        };\r\n        const propValueType = Object.prototype.toString.call($props[prop]);\r\n        if ( propValueType === '[object Object]' || propValueType === '[object Array]') {\r\n          watchOptions.deep = true;\r\n        }\r\n        // watch props\r\n        const unwatch = this.$watch(prop, nv => {\r\n          handleFun.call(this.$amapComponent, this.convertSignalProp(prop, nv));\r\n        }, watchOptions);\r\n\r\n        // collect watchers for destroyed\r\n        this.unwatchFns.push(unwatch);\r\n      });\r\n    },\r\n\r\n    // some prop can not init by initial created methods\r\n    initProps() {\r\n      const props = ['editable', 'visible', 'zooms'];\r\n\r\n      props.forEach(propStr => {\r\n        if (this[propStr] !== undefined) {\r\n          const handleFun = this.getHandlerFun(propStr);\r\n          handleFun && handleFun.call(this.$amapComponent, this.convertSignalProp(propStr, this[propStr]));\r\n        }\r\n      });\r\n\r\n      // this.printReactiveProp();\r\n    },\r\n\r\n    lazyRegister(){\r\n      const $parent = this.parentInstance as (ComponentPublicInstance & customComponent);\r\n      if($parent && $parent.addChildComponent){\r\n        $parent.addChildComponent(this);\r\n      }\r\n    },\r\n    addChildComponent(component : ComponentPublicInstance & customComponent){\r\n      this.needInitComponents.push(component);\r\n    },\r\n    createChildren(){\r\n      while (this.needInitComponents.length > 0){\r\n        this.needInitComponents[0].register();\r\n        this.needInitComponents.splice(0, 1);\r\n      }\r\n    },\r\n    register() {\r\n      if(this.parentInstance && !this.$parentComponent){\r\n        this.$parentComponent = this.parentInstance.$amapComponent;\r\n      }\r\n      const res = this['__initComponent'] && this['__initComponent'](this.convertProps());\r\n      if (res && res.then) res.then((instance) => this.registerRest(instance)); // promise\r\n      else this.registerRest(res);\r\n    },\r\n\r\n    registerRest(instance) {\r\n      if (!this.$amapComponent && instance) this.$amapComponent = instance;\r\n      this.registerEvents();\r\n      this.initProps();\r\n      this.setPropWatchers();\r\n      this.$emit('init', this.$amapComponent, this);\r\n      this.$nextTick(() => {\r\n        this.createChildren();\r\n      });\r\n      this.isMounted = true;\r\n    },\r\n\r\n    // helper method\r\n    $$getInstance() {\r\n      return this.$amapComponent;\r\n    },\r\n    destroyComponent() {\r\n      this.$amapComponent.setMap && this.$amapComponent.setMap(null);\r\n      this.$amapComponent.close && this.$amapComponent.close();\r\n      this.$amapComponent.editor && this.$amapComponent.editor.close();\r\n    },\r\n    __visible(flag){\r\n      if(!!this.$amapComponent && !!this.$amapComponent.show && !!this.$amapComponent.hide){\r\n        flag === false ? this.$amapComponent.hide() : this.$amapComponent.show();\r\n      }\r\n    },\r\n    __zIndex(value){\r\n      if (this.$amapComponent && this.$amapComponent.setzIndex) {\r\n        this.$amapComponent.setzIndex(value);\r\n      }\r\n    }\r\n  }\r\n});\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
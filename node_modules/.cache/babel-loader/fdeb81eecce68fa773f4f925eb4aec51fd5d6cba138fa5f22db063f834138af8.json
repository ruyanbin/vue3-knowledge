{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { GLTFLoader as C } from \"three/examples/jsm/loaders/GLTFLoader.js\";\nimport { DRACOLoader as F } from \"three/examples/jsm/loaders/DRACOLoader.js\";\nimport { Vector3 as b, Matrix4 as g, Box3 as k, Sphere as x, Vector2 as w, Raycaster as T } from \"three\";\nimport { bind as v } from \"lodash-es\";\nimport { TilesRenderer as R } from \"3d-tiles-renderer\";\nclass E {\n  constructor() {\n    this._listeners = {};\n  }\n  on(e, t, s) {\n    this._listeners[e] ? this._listeners[e].push({\n      callback: t,\n      isOnce: s\n    }) : this._listeners[e] = [{\n      callback: t,\n      isOnce: s\n    }];\n  }\n  off(e, t) {\n    if (!t) throw new Error(\"\\u53D6\\u6D88\\u4E8B\\u4EF6\\u65F6\\u9700\\u8981\\u4F20\\u5165\\u539F\\u56DE\\u8C03\\u51FD\\u6570\");\n    const s = this._listeners[e];\n    if (s && s.length > 0) {\n      for (let i = 0; i < s.length; i++) if (s[i].callback === t) {\n        s.splice(i, 1);\n        break;\n      }\n    }\n  }\n  emit(e, t) {\n    const s = this._listeners[e];\n    if (s && s.length > 0) for (let i = 0; i < s.length; i++) {\n      const o = s[i];\n      o.callback.call(this, t), o.isOnce && (s.splice(i, 1), i--);\n    }\n  }\n}\nconst c = new b(),\n  u = new b(),\n  m = new b();\nclass D extends R {\n  preprocessNode(e, t, s) {\n    super.preprocessNode(e, t, s);\n    const i = new g();\n    if (e.transform) {\n      t || (e.transform[0] = 1, e.transform[1] = 0, e.transform[2] = 0, e.transform[3] = 0, e.transform[4] = 0, e.transform[5] = 1, e.transform[6] = 0, e.transform[7] = 0, e.transform[8] = 0, e.transform[9] = 0, e.transform[10] = 1, e.transform[11] = 0, e.transform[12] = 0, e.transform[13] = 0, e.transform[14] = 0, e.transform[15] = 1);\n      const r = e.transform;\n      for (let d = 0; d < 16; d++) i.elements[d] = r[d];\n    }\n    t && i.premultiply(t.cached.transform);\n    const o = new g().copy(i).invert();\n    let l = null,\n      h = null,\n      n = null;\n    if (\"box\" in e.boundingVolume) {\n      const r = e.boundingVolume.box;\n      l = new k(), h = new g(), n = new g(), c.set(r[3], r[4], r[5]), u.set(r[6], r[7], r[8]), m.set(r[9], r[10], r[11]);\n      const d = c.length(),\n        f = u.length(),\n        y = m.length();\n      c.normalize(), u.normalize(), m.normalize(), d === 0 && c.crossVectors(u, m), f === 0 && u.crossVectors(c, m), y === 0 && m.crossVectors(c, u), h.set(c.x, u.x, m.x, r[0], c.y, u.y, m.y, r[1], c.z, u.z, m.z, r[2], 0, 0, 0, 1), h.premultiply(i), n.copy(h).invert(), l.min.set(-d, -f, -y), l.max.set(d, f, y);\n    }\n    let a = null;\n    if (\"sphere\" in e.boundingVolume) {\n      const r = e.boundingVolume.sphere;\n      a = new x(), a.center.set(r[0], r[1], r[2]), a.radius = r[3], a.applyMatrix4(i);\n    } else if (\"box\" in e.boundingVolume) {\n      const r = e.boundingVolume.box;\n      a = new x(), l == null || l.getBoundingSphere(a), a.center.set(r[0], r[1], r[2]), a.applyMatrix4(i);\n    }\n    const p = null;\n    \"region\" in e.boundingVolume && console.warn(\"ThreeTilesRenderer: region bounding volume not supported.\"), e.cached = {\n      loadIndex: 0,\n      transform: i,\n      transformInverse: o,\n      active: !1,\n      inFrustum: [],\n      box: l,\n      boxTransform: h,\n      boxTransformInverse: n,\n      sphere: a,\n      region: p,\n      scene: null,\n      geometry: null,\n      material: null\n    };\n  }\n  dispose() {\n    super.dispose();\n    const e = this;\n    e.lruCache.itemList.forEach(t => {\n      e.disposeTile(t);\n    }), e.lruCache.itemSet.clear(), e.lruCache.itemList = [], e.lruCache.callbacks.clear(), e.lruCache = null, e.visibleTiles.clear(), e.activeTiles.clear(), e.downloadQueue.callbacks.clear(), e.downloadQueue.items = [], e.downloadQueue = null, e.parseQueue.callbacks.clear(), e.parseQueue.items = [], e.parseQueue = null, this.clearGroup(this.group), e.tileSets = {}, e.cameraMap.clear(), e.cameras = [], e.cameraInfo = [], e.group = null;\n  }\n  clearGroup(e) {\n    e.traverse(t => {\n      t.isMesh && (t.geometry.dispose(), t.material.dispose(), t.material.texture && t.material.texture.dispose && t.material.texture.dispose()), delete t.featureTable, delete t.batchTable;\n    }), delete e.tilesRenderer, e.remove(...e.children);\n  }\n}\nclass L extends E {\n  constructor(e, t) {\n    super(), this.animationFrame = -1, this.mouse = new w(), this.layer = e;\n    const s = new D(t.url);\n    s.setCamera(this.layer.getCamera()), s.setResolutionFromRenderer(this.layer.getCamera(), this.layer.getRender());\n    const i = t.fetchOptions || {},\n      o = new C(s.manager);\n    i.credentials === \"include\" && i.mode === \"cors\" && o.setCrossOrigin(\"use-credentials\"), \"credentials\" in i && o.setWithCredentials(i.credentials === \"include\"), i.headers && o.setRequestHeader(i.headers);\n    const l = new F(),\n      h = t.dracoDecoderPath || \"https://cdn.jsdelivr.net/npm/three@0.143/examples/js/libs/draco/\";\n    if (l.setDecoderPath(h), o.setDRACOLoader(l), s.manager.addHandler(/\\.gltf$/i, o), s.onLoadTileSet = n => {\n      this.emit(\"loadTileSet\", n);\n    }, s.onLoadModel = (n, a) => {\n      this.emit(\"loadModel\", {\n        scene: n,\n        tile: a\n      });\n    }, s.onDisposeModel = (n, a) => {\n      this.emit(\"disposeModel\", {\n        scene: n,\n        tile: a\n      });\n    }, s.downloadQueue.maxJobs = 6, s.parseQueue.maxJobs = 6, this.group = s.group, this.layer.add(this.group), this.tilesRenderer = s, t.position && this.setPosition(t.position), t.rotation && this.setRotation(t.rotation), t.translate && this.setTranslate(t.translate), t.scale && this.setScale(t.scale), this.animate(), t.debug) {\n      const n = document.createElement(\"div\");\n      n.style.position = \"absolute\", n.style.top = \"0px\", n.style.left = \"0px\", n.style.color = \"white\", n.style.width = \"100%\", n.style.textAlign = \"center\", n.style.padding = \"5px\", n.style.pointerEvents = \"none\", n.style.lineHeight = \"1.5em\", document.body.appendChild(n), this.statsContainer = n;\n    }\n    this.bindEvents(t.mouseEvent);\n  }\n  bindEvents(e) {\n    if (e) {\n      this.raycaster = new T(), this.raycaster.firstHitOnly = !0;\n      const t = this.layer.getMap();\n      this.clickMapFn = v(this.clickMap, this), t.on(\"click\", this.clickMapFn), this.mousemoveMapFn = v(this.mousemoveMap, this), t.on(\"mousemove\", this.mousemoveMapFn), this.rightClickMapFn = v(this.rightClickMap, this), t.on(\"rightclick\", this.rightClickMapFn);\n    }\n  }\n  unbindEvents() {\n    const e = this.layer.getMap();\n    this.clickMapFn && (e.off(\"click\", this.clickMapFn), this.clickMapFn = null), this.mousemoveMapFn && (e.off(\"mousemove\", this.mousemoveMapFn), this.mousemoveMapFn = null), this.rightClickMapFn && (e.off(\"rightclick\", this.rightClickMapFn), this.rightClickMapFn = null), this.tilesRenderer && (this.tilesRenderer.onLoadTileSet = null, this.tilesRenderer.onLoadModel = null, this.tilesRenderer.onDisposeModel = null);\n  }\n  clickMap(e) {\n    const t = this._intersectGltf(e);\n    this.emit(\"click\", t);\n  }\n  mousemoveMap(e) {\n    const t = this._intersectGltf(e);\n    this.emit(\"mousemove\", t);\n  }\n  rightClickMap(e) {\n    const t = this._intersectGltf(e);\n    this.emit(\"rightClick\", t);\n  }\n  _intersectGltf(e) {\n    var t, s;\n    const i = this.layer.getMap().getContainer().getBoundingClientRect(),\n      o = this.mouse;\n    o.x = e.originEvent.clientX - i.x, o.y = e.originEvent.clientY - i.y, o.x = o.x / i.width * 2 - 1, o.y = -(o.y / i.height) * 2 + 1;\n    const l = this.layer.getCamera();\n    (t = this.raycaster) === null || t === void 0 || t.setFromCamera(o, l);\n    const h = (s = this.raycaster) === null || s === void 0 ? void 0 : s.intersectObject(this.group, !0);\n    if (h != null && h.length) {\n      const n = h[0].object,\n        a = {},\n        p = this.getBatchTable(n);\n      return p && p.getKeys().forEach(r => {\n        a[r] = p.getData(r);\n      }), {\n        object: n,\n        batchData: a\n      };\n    }\n    return null;\n  }\n  getBatchTable(e) {\n    return e ? e.batchTable ? e.batchTable : this.getBatchTable(e.parent) : null;\n  }\n  setPosition(e) {\n    const t = this.layer.convertLngLat(e);\n    this.group.position.setX(t[0]), this.group.position.setY(t[1]), this.refresh();\n  }\n  setRotation(e) {\n    if (e) {\n      const t = Math.PI / 180 * (e.x || 0),\n        s = Math.PI / 180 * (e.y || 0),\n        i = Math.PI / 180 * (e.z || 0);\n      this.group.rotation.set(t, s, i), this.refresh();\n    }\n  }\n  setTranslate(e) {\n    e && (this.group.translateX(e.x), this.group.translateY(e.y), this.group.translateZ(e.z), this.refresh());\n  }\n  setScale(e) {\n    let t;\n    typeof e == \"number\" ? t = {\n      x: e,\n      y: e,\n      z: e\n    } : t = e, this.group.scale.set(t.x, t.y, t.z), this.refresh();\n  }\n  refresh() {\n    this.layer.update();\n  }\n  show() {\n    this.group.visible = !0, this.refresh();\n  }\n  hide() {\n    this.group.visible = !1, this.refresh();\n  }\n  animate() {\n    this.animationFrame = requestAnimationFrame(() => {\n      this.update(), this.animate();\n    });\n  }\n  update() {\n    var e;\n    if (this.layer.getCamera().updateMatrixWorld(), (e = this.tilesRenderer) === null || e === void 0 || e.update(), this.layer.update(), this.statsContainer) {\n      const t = this.tilesRenderer;\n      this.statsContainer.innerHTML = `\\u6B63\\u5728\\u4E0B\\u8F7D: ${t.stats.downloading} \\u6B63\\u5728\\u7F16\\u8BD1: ${t.stats.parsing} \\u5DF2\\u663E\\u793A: ${t.group.children.length - 2}`;\n    }\n  }\n  getGroup() {\n    return this.group;\n  }\n  getTilesRenderer() {\n    return this.tilesRenderer;\n  }\n  destroy() {\n    var e;\n    cancelAnimationFrame(this.animationFrame), this.unbindEvents(), this.layer.remove(this.group), (e = this.tilesRenderer) === null || e === void 0 || e.dispose(), this.group = null, this.layer = null, this.statsContainer && (this.statsContainer.remove(), this.statsContainer = void 0);\n  }\n}\nexport { L as Layer3DTiles };","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["import{GLTFLoader as C}from\"three/examples/jsm/loaders/GLTFLoader.js\";import{DRACOLoader as F}from\"three/examples/jsm/loaders/DRACOLoader.js\";import{Vector3 as b,Matrix4 as g,Box3 as k,Sphere as x,Vector2 as w,Raycaster as T}from\"three\";import{bind as v}from\"lodash-es\";import{TilesRenderer as R}from\"3d-tiles-renderer\";class E{constructor(){this._listeners={}}on(e,t,s){this._listeners[e]?this._listeners[e].push({callback:t,isOnce:s}):this._listeners[e]=[{callback:t,isOnce:s}]}off(e,t){if(!t)throw new Error(\"\\u53D6\\u6D88\\u4E8B\\u4EF6\\u65F6\\u9700\\u8981\\u4F20\\u5165\\u539F\\u56DE\\u8C03\\u51FD\\u6570\");const s=this._listeners[e];if(s&&s.length>0){for(let i=0;i<s.length;i++)if(s[i].callback===t){s.splice(i,1);break}}}emit(e,t){const s=this._listeners[e];if(s&&s.length>0)for(let i=0;i<s.length;i++){const o=s[i];o.callback.call(this,t),o.isOnce&&(s.splice(i,1),i--)}}}const c=new b,u=new b,m=new b;class D extends R{preprocessNode(e,t,s){super.preprocessNode(e,t,s);const i=new g;if(e.transform){t||(e.transform[0]=1,e.transform[1]=0,e.transform[2]=0,e.transform[3]=0,e.transform[4]=0,e.transform[5]=1,e.transform[6]=0,e.transform[7]=0,e.transform[8]=0,e.transform[9]=0,e.transform[10]=1,e.transform[11]=0,e.transform[12]=0,e.transform[13]=0,e.transform[14]=0,e.transform[15]=1);const r=e.transform;for(let d=0;d<16;d++)i.elements[d]=r[d]}t&&i.premultiply(t.cached.transform);const o=new g().copy(i).invert();let l=null,h=null,n=null;if(\"box\"in e.boundingVolume){const r=e.boundingVolume.box;l=new k,h=new g,n=new g,c.set(r[3],r[4],r[5]),u.set(r[6],r[7],r[8]),m.set(r[9],r[10],r[11]);const d=c.length(),f=u.length(),y=m.length();c.normalize(),u.normalize(),m.normalize(),d===0&&c.crossVectors(u,m),f===0&&u.crossVectors(c,m),y===0&&m.crossVectors(c,u),h.set(c.x,u.x,m.x,r[0],c.y,u.y,m.y,r[1],c.z,u.z,m.z,r[2],0,0,0,1),h.premultiply(i),n.copy(h).invert(),l.min.set(-d,-f,-y),l.max.set(d,f,y)}let a=null;if(\"sphere\"in e.boundingVolume){const r=e.boundingVolume.sphere;a=new x,a.center.set(r[0],r[1],r[2]),a.radius=r[3],a.applyMatrix4(i)}else if(\"box\"in e.boundingVolume){const r=e.boundingVolume.box;a=new x,l==null||l.getBoundingSphere(a),a.center.set(r[0],r[1],r[2]),a.applyMatrix4(i)}const p=null;\"region\"in e.boundingVolume&&console.warn(\"ThreeTilesRenderer: region bounding volume not supported.\"),e.cached={loadIndex:0,transform:i,transformInverse:o,active:!1,inFrustum:[],box:l,boxTransform:h,boxTransformInverse:n,sphere:a,region:p,scene:null,geometry:null,material:null}}dispose(){super.dispose();const e=this;e.lruCache.itemList.forEach(t=>{e.disposeTile(t)}),e.lruCache.itemSet.clear(),e.lruCache.itemList=[],e.lruCache.callbacks.clear(),e.lruCache=null,e.visibleTiles.clear(),e.activeTiles.clear(),e.downloadQueue.callbacks.clear(),e.downloadQueue.items=[],e.downloadQueue=null,e.parseQueue.callbacks.clear(),e.parseQueue.items=[],e.parseQueue=null,this.clearGroup(this.group),e.tileSets={},e.cameraMap.clear(),e.cameras=[],e.cameraInfo=[],e.group=null}clearGroup(e){e.traverse(t=>{t.isMesh&&(t.geometry.dispose(),t.material.dispose(),t.material.texture&&t.material.texture.dispose&&t.material.texture.dispose()),delete t.featureTable,delete t.batchTable}),delete e.tilesRenderer,e.remove(...e.children)}}class L extends E{constructor(e,t){super(),this.animationFrame=-1,this.mouse=new w,this.layer=e;const s=new D(t.url);s.setCamera(this.layer.getCamera()),s.setResolutionFromRenderer(this.layer.getCamera(),this.layer.getRender());const i=t.fetchOptions||{},o=new C(s.manager);i.credentials===\"include\"&&i.mode===\"cors\"&&o.setCrossOrigin(\"use-credentials\"),\"credentials\"in i&&o.setWithCredentials(i.credentials===\"include\"),i.headers&&o.setRequestHeader(i.headers);const l=new F,h=t.dracoDecoderPath||\"https://cdn.jsdelivr.net/npm/three@0.143/examples/js/libs/draco/\";if(l.setDecoderPath(h),o.setDRACOLoader(l),s.manager.addHandler(/\\.gltf$/i,o),s.onLoadTileSet=n=>{this.emit(\"loadTileSet\",n)},s.onLoadModel=(n,a)=>{this.emit(\"loadModel\",{scene:n,tile:a})},s.onDisposeModel=(n,a)=>{this.emit(\"disposeModel\",{scene:n,tile:a})},s.downloadQueue.maxJobs=6,s.parseQueue.maxJobs=6,this.group=s.group,this.layer.add(this.group),this.tilesRenderer=s,t.position&&this.setPosition(t.position),t.rotation&&this.setRotation(t.rotation),t.translate&&this.setTranslate(t.translate),t.scale&&this.setScale(t.scale),this.animate(),t.debug){const n=document.createElement(\"div\");n.style.position=\"absolute\",n.style.top=\"0px\",n.style.left=\"0px\",n.style.color=\"white\",n.style.width=\"100%\",n.style.textAlign=\"center\",n.style.padding=\"5px\",n.style.pointerEvents=\"none\",n.style.lineHeight=\"1.5em\",document.body.appendChild(n),this.statsContainer=n}this.bindEvents(t.mouseEvent)}bindEvents(e){if(e){this.raycaster=new T,this.raycaster.firstHitOnly=!0;const t=this.layer.getMap();this.clickMapFn=v(this.clickMap,this),t.on(\"click\",this.clickMapFn),this.mousemoveMapFn=v(this.mousemoveMap,this),t.on(\"mousemove\",this.mousemoveMapFn),this.rightClickMapFn=v(this.rightClickMap,this),t.on(\"rightclick\",this.rightClickMapFn)}}unbindEvents(){const e=this.layer.getMap();this.clickMapFn&&(e.off(\"click\",this.clickMapFn),this.clickMapFn=null),this.mousemoveMapFn&&(e.off(\"mousemove\",this.mousemoveMapFn),this.mousemoveMapFn=null),this.rightClickMapFn&&(e.off(\"rightclick\",this.rightClickMapFn),this.rightClickMapFn=null),this.tilesRenderer&&(this.tilesRenderer.onLoadTileSet=null,this.tilesRenderer.onLoadModel=null,this.tilesRenderer.onDisposeModel=null)}clickMap(e){const t=this._intersectGltf(e);this.emit(\"click\",t)}mousemoveMap(e){const t=this._intersectGltf(e);this.emit(\"mousemove\",t)}rightClickMap(e){const t=this._intersectGltf(e);this.emit(\"rightClick\",t)}_intersectGltf(e){var t,s;const i=this.layer.getMap().getContainer().getBoundingClientRect(),o=this.mouse;o.x=e.originEvent.clientX-i.x,o.y=e.originEvent.clientY-i.y,o.x=o.x/i.width*2-1,o.y=-(o.y/i.height)*2+1;const l=this.layer.getCamera();(t=this.raycaster)===null||t===void 0||t.setFromCamera(o,l);const h=(s=this.raycaster)===null||s===void 0?void 0:s.intersectObject(this.group,!0);if(h!=null&&h.length){const n=h[0].object,a={},p=this.getBatchTable(n);return p&&p.getKeys().forEach(r=>{a[r]=p.getData(r)}),{object:n,batchData:a}}return null}getBatchTable(e){return e?e.batchTable?e.batchTable:this.getBatchTable(e.parent):null}setPosition(e){const t=this.layer.convertLngLat(e);this.group.position.setX(t[0]),this.group.position.setY(t[1]),this.refresh()}setRotation(e){if(e){const t=Math.PI/180*(e.x||0),s=Math.PI/180*(e.y||0),i=Math.PI/180*(e.z||0);this.group.rotation.set(t,s,i),this.refresh()}}setTranslate(e){e&&(this.group.translateX(e.x),this.group.translateY(e.y),this.group.translateZ(e.z),this.refresh())}setScale(e){let t;typeof e==\"number\"?t={x:e,y:e,z:e}:t=e,this.group.scale.set(t.x,t.y,t.z),this.refresh()}refresh(){this.layer.update()}show(){this.group.visible=!0,this.refresh()}hide(){this.group.visible=!1,this.refresh()}animate(){this.animationFrame=requestAnimationFrame(()=>{this.update(),this.animate()})}update(){var e;if(this.layer.getCamera().updateMatrixWorld(),(e=this.tilesRenderer)===null||e===void 0||e.update(),this.layer.update(),this.statsContainer){const t=this.tilesRenderer;this.statsContainer.innerHTML=`\\u6B63\\u5728\\u4E0B\\u8F7D: ${t.stats.downloading} \\u6B63\\u5728\\u7F16\\u8BD1: ${t.stats.parsing} \\u5DF2\\u663E\\u793A: ${t.group.children.length-2}`}}getGroup(){return this.group}getTilesRenderer(){return this.tilesRenderer}destroy(){var e;cancelAnimationFrame(this.animationFrame),this.unbindEvents(),this.layer.remove(this.group),(e=this.tilesRenderer)===null||e===void 0||e.dispose(),this.group=null,this.layer=null,this.statsContainer&&(this.statsContainer.remove(),this.statsContainer=void 0)}}export{L as Layer3DTiles};\n//# sourceMappingURL=index-es.js.map\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
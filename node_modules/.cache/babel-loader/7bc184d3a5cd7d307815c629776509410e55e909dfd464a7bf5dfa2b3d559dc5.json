{"ast":null,"code":"import { Group, Matrix4 } from 'three';\n\n// Specialization of \"Group\" that only updates world matrices of children if\n// the transform has changed since the last update and ignores the \"force\"\n// parameter under the assumption that the children tiles will not move.\nconst tempMat = new Matrix4();\nexport class TilesGroup extends Group {\n  constructor(tilesRenderer) {\n    super();\n    this.name = 'TilesRenderer.TilesGroup';\n    this.tilesRenderer = tilesRenderer;\n  }\n  raycast(raycaster, intersects) {\n    if (this.tilesRenderer.optimizeRaycast) {\n      this.tilesRenderer.raycast(raycaster, intersects);\n    }\n  }\n  updateMatrixWorld(force) {\n    if (this.matrixAutoUpdate) {\n      this.updateMatrix();\n    }\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.parent === null) {\n        tempMat.copy(this.matrix);\n      } else {\n        tempMat.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      }\n      this.matrixWorldNeedsUpdate = false;\n\n      // check if the matrix changed relative to what it was.\n      const elA = tempMat.elements;\n      const elB = this.matrixWorld.elements;\n      let isDifferent = false;\n      for (let i = 0; i < 16; i++) {\n        const itemA = elA[i];\n        const itemB = elB[i];\n        const diff = Math.abs(itemA - itemB);\n        if (diff > Number.EPSILON) {\n          isDifferent = true;\n          break;\n        }\n      }\n      if (isDifferent) {\n        this.matrixWorld.copy(tempMat);\n\n        // update children\n        // the children will not have to change unless the parent group has updated\n        const children = this.children;\n        for (let i = 0, l = children.length; i < l; i++) {\n          children[i].updateMatrixWorld();\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["Group","Matrix4","tempMat","TilesGroup","constructor","tilesRenderer","name","raycast","raycaster","intersects","optimizeRaycast","updateMatrixWorld","force","matrixAutoUpdate","updateMatrix","matrixWorldNeedsUpdate","parent","copy","matrix","multiplyMatrices","matrixWorld","elA","elements","elB","isDifferent","i","itemA","itemB","diff","Math","abs","Number","EPSILON","children","l","length"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/3d-tiles-renderer/src/three/TilesGroup.js"],"sourcesContent":["import { Group, Matrix4 } from 'three';\n\n// Specialization of \"Group\" that only updates world matrices of children if\n// the transform has changed since the last update and ignores the \"force\"\n// parameter under the assumption that the children tiles will not move.\nconst tempMat = new Matrix4();\nexport class TilesGroup extends Group {\n\n\tconstructor( tilesRenderer ) {\n\n\t\tsuper();\n\t\tthis.name = 'TilesRenderer.TilesGroup';\n\t\tthis.tilesRenderer = tilesRenderer;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( this.tilesRenderer.optimizeRaycast ) {\n\n\t\t\tthis.tilesRenderer.raycast( raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) {\n\n\t\t\tthis.updateMatrix();\n\n\t\t}\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\ttempMat.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\ttempMat.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t// check if the matrix changed relative to what it was.\n\t\t\tconst elA = tempMat.elements;\n\t\t\tconst elB = this.matrixWorld.elements;\n\t\t\tlet isDifferent = false;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\tconst itemA = elA[ i ];\n\t\t\t\tconst itemB = elB[ i ];\n\t\t\t\tconst diff = Math.abs( itemA - itemB );\n\n\t\t\t\tif ( diff > Number.EPSILON ) {\n\n\t\t\t\t\tisDifferent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isDifferent ) {\n\n\t\t\t\tthis.matrixWorld.copy( tempMat );\n\n\t\t\t\t// update children\n\t\t\t\t// the children will not have to change unless the parent group has updated\n\t\t\t\tconst children = this.children;\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tchildren[ i ].updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,OAAO,QAAQ,OAAO;;AAEtC;AACA;AACA;AACA,MAAMC,OAAO,GAAG,IAAID,OAAO,EAAE;AAC7B,OAAO,MAAME,UAAU,SAASH,KAAK,CAAC;EAErCI,WAAW,CAAEC,aAAa,EAAG;IAE5B,KAAK,EAAE;IACP,IAAI,CAACC,IAAI,GAAG,0BAA0B;IACtC,IAAI,CAACD,aAAa,GAAGA,aAAa;EAEnC;EAEAE,OAAO,CAAEC,SAAS,EAAEC,UAAU,EAAG;IAEhC,IAAK,IAAI,CAACJ,aAAa,CAACK,eAAe,EAAG;MAEzC,IAAI,CAACL,aAAa,CAACE,OAAO,CAAEC,SAAS,EAAEC,UAAU,CAAE;IAEpD;EAED;EAEAE,iBAAiB,CAAEC,KAAK,EAAG;IAE1B,IAAK,IAAI,CAACC,gBAAgB,EAAG;MAE5B,IAAI,CAACC,YAAY,EAAE;IAEpB;IAEA,IAAK,IAAI,CAACC,sBAAsB,IAAIH,KAAK,EAAG;MAE3C,IAAK,IAAI,CAACI,MAAM,KAAK,IAAI,EAAG;QAE3Bd,OAAO,CAACe,IAAI,CAAE,IAAI,CAACC,MAAM,CAAE;MAE5B,CAAC,MAAM;QAENhB,OAAO,CAACiB,gBAAgB,CAAE,IAAI,CAACH,MAAM,CAACI,WAAW,EAAE,IAAI,CAACF,MAAM,CAAE;MAEjE;MAEA,IAAI,CAACH,sBAAsB,GAAG,KAAK;;MAEnC;MACA,MAAMM,GAAG,GAAGnB,OAAO,CAACoB,QAAQ;MAC5B,MAAMC,GAAG,GAAG,IAAI,CAACH,WAAW,CAACE,QAAQ;MACrC,IAAIE,WAAW,GAAG,KAAK;MACvB,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAG,EAAG;QAE/B,MAAMC,KAAK,GAAGL,GAAG,CAAEI,CAAC,CAAE;QACtB,MAAME,KAAK,GAAGJ,GAAG,CAAEE,CAAC,CAAE;QACtB,MAAMG,IAAI,GAAGC,IAAI,CAACC,GAAG,CAAEJ,KAAK,GAAGC,KAAK,CAAE;QAEtC,IAAKC,IAAI,GAAGG,MAAM,CAACC,OAAO,EAAG;UAE5BR,WAAW,GAAG,IAAI;UAClB;QAED;MAED;MAEA,IAAKA,WAAW,EAAG;QAElB,IAAI,CAACJ,WAAW,CAACH,IAAI,CAAEf,OAAO,CAAE;;QAEhC;QACA;QACA,MAAM+B,QAAQ,GAAG,IAAI,CAACA,QAAQ;QAC9B,KAAM,IAAIR,CAAC,GAAG,CAAC,EAAES,CAAC,GAAGD,QAAQ,CAACE,MAAM,EAAEV,CAAC,GAAGS,CAAC,EAAET,CAAC,EAAG,EAAG;UAEnDQ,QAAQ,CAAER,CAAC,CAAE,CAACd,iBAAiB,EAAE;QAElC;MAED;IAED;EAED;AAED"},"metadata":{},"sourceType":"module","externalDependencies":[]}
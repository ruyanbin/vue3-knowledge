{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Matrix4, Sphere, Ray, Vector3 } from 'three';\nconst _sphere = new Sphere();\nconst _mat = new Matrix4();\nconst _vec = new Vector3();\nconst _vec2 = new Vector3();\nconst _ray = new Ray();\nconst _hitArray = [];\nfunction distanceSort(a, b) {\n  return a.distance - b.distance;\n}\nfunction intersectTileScene(scene, raycaster, intersects) {\n  // Don't intersect the box3 helpers because those are used for debugging\n  scene.traverse(c => {\n    // We set the default raycast function to empty so three.js doesn't automatically cast against it\n    Object.getPrototypeOf(c).raycast.call(c, raycaster, intersects);\n  });\n}\n\n// Returns the closest hit when traversing the tree\nexport function raycastTraverseFirstHit(root, group, activeTiles, raycaster) {\n  // If the root is active make sure we've checked it\n  if (activeTiles.has(root)) {\n    intersectTileScene(root.cached.scene, raycaster, _hitArray);\n    if (_hitArray.length > 0) {\n      if (_hitArray.length > 1) {\n        _hitArray.sort(distanceSort);\n      }\n      const res = _hitArray[0];\n      _hitArray.length = 0;\n      return res;\n    } else {\n      return null;\n    }\n  }\n\n  // TODO: can we avoid creating a new array here every time to save on memory?\n  const array = [];\n  const children = root.children;\n  for (let i = 0, l = children.length; i < l; i++) {\n    const tile = children[i];\n    const cached = tile.cached;\n    const groupMatrixWorld = group.matrixWorld;\n    _mat.copy(groupMatrixWorld);\n\n    // if we don't hit the sphere then early out\n    const sphere = cached.sphere;\n    if (sphere) {\n      _sphere.copy(sphere);\n      _sphere.applyMatrix4(_mat);\n      if (!raycaster.ray.intersectsSphere(_sphere)) {\n        continue;\n      }\n    }\n\n    // TODO: check region?\n\n    const boundingBox = cached.box;\n    const obbMat = cached.boxTransform;\n    if (boundingBox) {\n      _mat.multiply(obbMat).invert();\n      _ray.copy(raycaster.ray);\n      _ray.applyMatrix4(_mat);\n      if (_ray.intersectBox(boundingBox, _vec)) {\n        // account for tile scale\n        _vec2.setFromMatrixScale(_mat);\n        const invScale = _vec2.x;\n        if (Math.abs(Math.max(_vec2.x - _vec2.y, _vec2.x - _vec2.z)) > 1e-6) {\n          console.warn('ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when raycasting.');\n        }\n\n        // if we intersect the box save the distance to the tile bounds\n        const data = {\n          distance: Infinity,\n          tile: null\n        };\n        array.push(data);\n        data.distance = _vec.distanceToSquared(_ray.origin) * invScale * invScale;\n        data.tile = tile;\n      } else {\n        continue;\n      }\n    }\n  }\n\n  // sort them by ascending distance\n  array.sort(distanceSort);\n\n  // traverse until we find the best hit and early out if a tile bounds\n  // couldn't possible include a best hit\n  let bestDistanceSquared = Infinity;\n  let bestHit = null;\n  for (let i = 0, l = array.length; i < l; i++) {\n    const data = array[i];\n    const distanceSquared = data.distance;\n    if (distanceSquared > bestDistanceSquared) {\n      break;\n    } else {\n      const tile = data.tile;\n      const scene = tile.cached.scene;\n      let hit = null;\n      if (activeTiles.has(tile)) {\n        // save the hit if it's closer\n        intersectTileScene(scene, raycaster, _hitArray);\n        if (_hitArray.length > 0) {\n          if (_hitArray.length > 1) {\n            _hitArray.sort(distanceSort);\n          }\n          hit = _hitArray[0];\n        }\n      } else {\n        hit = raycastTraverseFirstHit(tile, group, activeTiles, raycaster);\n      }\n      if (hit) {\n        const hitDistanceSquared = hit.distance * hit.distance;\n        if (hitDistanceSquared < bestDistanceSquared) {\n          bestDistanceSquared = hitDistanceSquared;\n          bestHit = hit;\n        }\n        _hitArray.length = 0;\n      }\n    }\n  }\n  return bestHit;\n}\nexport function raycastTraverse(tile, group, activeTiles, raycaster, intersects) {\n  const cached = tile.cached;\n  const groupMatrixWorld = group.matrixWorld;\n  _mat.copy(groupMatrixWorld);\n\n  // Early out if we don't hit this tile sphere\n  const sphere = cached.sphere;\n  if (sphere) {\n    _sphere.copy(sphere);\n    _sphere.applyMatrix4(_mat);\n    if (!raycaster.ray.intersectsSphere(_sphere)) {\n      return;\n    }\n  }\n\n  // Early out if we don't this this tile box\n  const boundingBox = cached.box;\n  const obbMat = cached.boxTransform;\n  if (boundingBox) {\n    _mat.multiply(obbMat).invert();\n    _ray.copy(raycaster.ray).applyMatrix4(_mat);\n    if (!_ray.intersectsBox(boundingBox)) {\n      return;\n    }\n  }\n\n  // TODO: check region\n\n  const scene = cached.scene;\n  if (activeTiles.has(tile)) {\n    intersectTileScene(scene, raycaster, intersects);\n    return;\n  }\n  const children = tile.children;\n  for (let i = 0, l = children.length; i < l; i++) {\n    raycastTraverse(children[i], group, activeTiles, raycaster, intersects);\n  }\n}","map":{"version":3,"names":["Matrix4","Sphere","Ray","Vector3","_sphere","_mat","_vec","_vec2","_ray","_hitArray","distanceSort","a","b","distance","intersectTileScene","scene","raycaster","intersects","traverse","c","Object","getPrototypeOf","raycast","call","raycastTraverseFirstHit","root","group","activeTiles","has","cached","length","sort","res","array","children","i","l","tile","groupMatrixWorld","matrixWorld","copy","sphere","applyMatrix4","ray","intersectsSphere","boundingBox","box","obbMat","boxTransform","multiply","invert","intersectBox","setFromMatrixScale","invScale","x","Math","abs","max","y","z","console","warn","data","Infinity","push","distanceToSquared","origin","bestDistanceSquared","bestHit","distanceSquared","hit","hitDistanceSquared","raycastTraverse","intersectsBox"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/3d-tiles-renderer/src/three/raycastTraverse.js"],"sourcesContent":["import { Matrix4, Sphere, Ray, Vector3 } from 'three';\nconst _sphere = new Sphere();\nconst _mat = new Matrix4();\nconst _vec = new Vector3();\nconst _vec2 = new Vector3();\nconst _ray = new Ray();\n\nconst _hitArray = [];\n\nfunction distanceSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectTileScene( scene, raycaster, intersects ) {\n\n\t// Don't intersect the box3 helpers because those are used for debugging\n\tscene.traverse( c => {\n\n\t\t// We set the default raycast function to empty so three.js doesn't automatically cast against it\n\t\tObject.getPrototypeOf( c ).raycast.call( c, raycaster, intersects );\n\n\t} );\n\n}\n\n// Returns the closest hit when traversing the tree\nexport function raycastTraverseFirstHit( root, group, activeTiles, raycaster ) {\n\n\t// If the root is active make sure we've checked it\n\tif ( activeTiles.has( root ) ) {\n\n\t\tintersectTileScene( root.cached.scene, raycaster, _hitArray );\n\n\t\tif ( _hitArray.length > 0 ) {\n\n\t\t\tif ( _hitArray.length > 1 ) {\n\n\t\t\t\t_hitArray.sort( distanceSort );\n\n\t\t\t}\n\n\t\t\tconst res = _hitArray[ 0 ];\n\t\t\t_hitArray.length = 0;\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// TODO: can we avoid creating a new array here every time to save on memory?\n\tconst array = [];\n\tconst children = root.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst tile = children[ i ];\n\t\tconst cached = tile.cached;\n\t\tconst groupMatrixWorld = group.matrixWorld;\n\n\t\t_mat.copy( groupMatrixWorld );\n\n\t\t// if we don't hit the sphere then early out\n\t\tconst sphere = cached.sphere;\n\t\tif ( sphere ) {\n\n\t\t\t_sphere.copy( sphere );\n\t\t\t_sphere.applyMatrix4( _mat );\n\t\t\tif ( ! raycaster.ray.intersectsSphere( _sphere ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO: check region?\n\n\t\tconst boundingBox = cached.box;\n\t\tconst obbMat = cached.boxTransform;\n\t\tif ( boundingBox ) {\n\n\t\t\t_mat.multiply( obbMat ).invert();\n\t\t\t_ray.copy( raycaster.ray );\n\t\t\t_ray.applyMatrix4( _mat );\n\t\t\tif ( _ray.intersectBox( boundingBox, _vec ) ) {\n\n\t\t\t\t// account for tile scale\n\t\t\t\t_vec2.setFromMatrixScale( _mat );\n\t\t\t\tconst invScale = _vec2.x;\n\n\t\t\t\tif ( Math.abs( Math.max( _vec2.x - _vec2.y, _vec2.x - _vec2.z ) ) > 1e-6 ) {\n\n\t\t\t\t\tconsole.warn( 'ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when raycasting.' );\n\n\t\t\t\t}\n\n\t\t\t\t// if we intersect the box save the distance to the tile bounds\n\t\t\t\tconst data = {\n\t\t\t\t\tdistance: Infinity,\n\t\t\t\t\ttile: null\n\t\t\t\t};\n\t\t\t\tarray.push( data );\n\n\t\t\t\tdata.distance = _vec.distanceToSquared( _ray.origin ) * invScale * invScale;\n\t\t\t\tdata.tile = tile;\n\n\t\t\t} else {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// sort them by ascending distance\n\tarray.sort( distanceSort );\n\n\t// traverse until we find the best hit and early out if a tile bounds\n\t// couldn't possible include a best hit\n\tlet bestDistanceSquared = Infinity;\n\tlet bestHit = null;\n\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\tconst data = array[ i ];\n\t\tconst distanceSquared = data.distance;\n\t\tif ( distanceSquared > bestDistanceSquared ) {\n\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\tconst tile = data.tile;\n\t\t\tconst scene = tile.cached.scene;\n\n\t\t\tlet hit = null;\n\t\t\tif ( activeTiles.has( tile ) ) {\n\n\t\t\t\t// save the hit if it's closer\n\t\t\t\tintersectTileScene( scene, raycaster, _hitArray );\n\t\t\t\tif ( _hitArray.length > 0 ) {\n\n\t\t\t\t\tif ( _hitArray.length > 1 ) {\n\n\t\t\t\t\t\t_hitArray.sort( distanceSort );\n\n\t\t\t\t\t}\n\n\t\t\t\t\thit = _hitArray[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\thit = raycastTraverseFirstHit( tile, group, activeTiles, raycaster );\n\n\t\t\t}\n\n\t\t\tif ( hit ) {\n\n\t\t\t\tconst hitDistanceSquared = hit.distance * hit.distance;\n\t\t\t\tif ( hitDistanceSquared < bestDistanceSquared ) {\n\n\t\t\t\t\tbestDistanceSquared = hitDistanceSquared;\n\t\t\t\t\tbestHit = hit;\n\n\t\t\t\t}\n\t\t\t\t_hitArray.length = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bestHit;\n\n}\n\nexport function raycastTraverse( tile, group, activeTiles, raycaster, intersects ) {\n\n\tconst cached = tile.cached;\n\tconst groupMatrixWorld = group.matrixWorld;\n\n\t_mat.copy( groupMatrixWorld );\n\n\t// Early out if we don't hit this tile sphere\n\tconst sphere = cached.sphere;\n\tif ( sphere ) {\n\n\t\t_sphere.copy( sphere );\n\t\t_sphere.applyMatrix4( _mat );\n\t\tif ( ! raycaster.ray.intersectsSphere( _sphere ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t}\n\n\t// Early out if we don't this this tile box\n\tconst boundingBox = cached.box;\n\tconst obbMat = cached.boxTransform;\n\tif ( boundingBox ) {\n\n\t\t_mat.multiply( obbMat ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _mat );\n\t\tif ( ! _ray.intersectsBox( boundingBox ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t}\n\n\t// TODO: check region\n\n\tconst scene = cached.scene;\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tintersectTileScene( scene, raycaster, intersects );\n\t\treturn;\n\n\t}\n\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\traycastTraverse( children[ i ], group, activeTiles, raycaster, intersects );\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
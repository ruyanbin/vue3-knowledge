{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { PerspectiveCamera as g, OrthographicCamera as y, WebGLRenderer as b, Scene as v, Cache as C, AnimationMixer as j, Clock as x } from \"three\";\nimport { GLTFLoader as A } from \"three/examples/jsm/loaders/GLTFLoader.js\";\nclass p {\n  constructor() {\n    this._listeners = {};\n  }\n  on(t, e, s) {\n    this._listeners[t] ? this._listeners[t].push({\n      callback: e,\n      isOnce: s\n    }) : this._listeners[t] = [{\n      callback: e,\n      isOnce: s\n    }];\n  }\n  off(t, e) {\n    if (!e) throw new Error(\"\\u53D6\\u6D88\\u4E8B\\u4EF6\\u65F6\\u9700\\u8981\\u4F20\\u5165\\u539F\\u56DE\\u8C03\\u51FD\\u6570\");\n    const s = this._listeners[t];\n    if (s && s.length > 0) {\n      for (let i = 0; i < s.length; i++) if (s[i].callback === e) {\n        s.splice(i, 1);\n        break;\n      }\n    }\n  }\n  emit(t, e) {\n    const s = this._listeners[t];\n    if (s && s.length > 0) for (let i = 0; i < s.length; i++) {\n      const o = s[i];\n      o.callback.call(this, e), o.isOnce && (s.splice(i, 1), i--);\n    }\n  }\n}\nfunction z(l) {\n  l.traverse(t => {\n    u(t);\n  });\n}\nfunction u(l) {\n  const t = s => {\n      s.geometry && s.geometry.dispose(), s.material && s.material.dispose && s.material.dispose(), s.material.texture && s.material.texture.dispose && s.material.texture.dispose();\n    },\n    e = s => {\n      let i = s.children.filter(o => o);\n      i.forEach(o => {\n        o.children.length ? e(o) : o.isMesh && t(o);\n      }), i = null;\n    };\n  e(l);\n}\nclass M extends p {\n  constructor(t, e) {\n    super(), this.frameTimer = -1, this.needsUpdate = !1, e = e || {}, this.customCoords = t.customCoords, this.center = e.customCoordsCenter || t.getCenter().toArray(), this.customCoords.lngLatsToCoords([this.center]);\n    const s = {\n      zooms: [2, 20],\n      opacity: 1,\n      alpha: !1,\n      antialias: !1,\n      visible: !0,\n      zIndex: 120\n    };\n    this.options = Object.assign({}, s, e), this.map = t, this.init();\n  }\n  init() {\n    const t = this.map,\n      e = this.options,\n      s = {\n        zooms: e.zooms,\n        opacity: e.opacity,\n        visible: e.visible,\n        zIndex: e.zIndex,\n        init: i => {\n          const o = t.getContainer(),\n            n = o.offsetWidth,\n            r = o.offsetHeight;\n          let a;\n          t.getView().type === \"3D\" ? a = new g(60, n / r, 100, 1 << 30) : a = new y(n / -2, n / 2, r / 2, r / -2, 1, 1e3);\n          const h = new b({\n            context: i,\n            alpha: e.alpha,\n            antialias: e.antialias\n          });\n          h.setSize(n, r), h.autoClear = !1;\n          const c = new v();\n          this.camera = a, this.renderer = h, this.scene = c, e.onInit && e.onInit(h, c, a), this.animate(), this.emit(\"complete\");\n        },\n        render: () => {\n          var i, o, n;\n          (i = this.renderer) === null || i === void 0 || i.resetState(), this.customCoords.setCenter(this.center);\n          const r = this.camera;\n          if (t.getView().type === \"3D\") {\n            const {\n              near: a,\n              far: h,\n              fov: c,\n              up: m,\n              lookAt: d,\n              position: f\n            } = this.customCoords.getCameraParams();\n            r.near = a, r.far = h, r.fov = c, r.position.set(...f), r.up.set(...m), r.lookAt(...d), r.updateProjectionMatrix();\n          } else {\n            const {\n              top: a,\n              bottom: h,\n              left: c,\n              right: m,\n              position: d\n            } = this.customCoords.getCameraParams();\n            r.top = a, r.bottom = h, r.left = c, r.right = m, r.position.set(...d), r.updateProjectionMatrix();\n          }\n          this.camera = r, e.onRender ? e.onRender(this.renderer, this.scene, this.camera) : (o = this.renderer) === null || o === void 0 || o.render(this.scene, r), (n = this.renderer) === null || n === void 0 || n.resetState();\n        }\n      };\n    this.layer = new AMap.GLCustomLayer(s), this.layer.setMap(t);\n  }\n  update() {\n    this.needsUpdate = !0;\n  }\n  animate() {\n    this.needsUpdate && (this.refreshMap(), this.needsUpdate = !1), this.frameTimer = requestAnimationFrame(() => {\n      this.animate();\n    });\n  }\n  refreshMap() {\n    this.map && this.map.render();\n  }\n  convertLngLat(t) {\n    return this.customCoords.lngLatsToCoords([t])[0];\n  }\n  add(t) {\n    var e;\n    (e = this.scene) === null || e === void 0 || e.add(t), this.refreshMap();\n  }\n  remove(t) {\n    var e;\n    (e = this.scene) === null || e === void 0 || e.remove(t), this.refreshMap();\n  }\n  getScene() {\n    return this.scene;\n  }\n  getCamera() {\n    return this.camera;\n  }\n  getRender() {\n    return this.renderer;\n  }\n  destroy() {\n    var t;\n    cancelAnimationFrame(this.frameTimer), this.layer.setMap(null), this.customCoords = null, z(this.scene), this.scene = void 0, this.camera = void 0, (t = this.renderer) === null || t === void 0 || t.dispose(), this.renderer = void 0, this.layer = null, this.map = null, C.clear(), this.options = null;\n  }\n  getMap() {\n    return this.map ? this.map : null;\n  }\n  getOpacity() {\n    return this.layer.getOpacity();\n  }\n  setOpacity(t) {\n    this.layer.setOpacity(t);\n  }\n  getZooms() {\n    return this.layer.getZooms();\n  }\n  setZooms(t) {\n    this.layer.setZooms(t);\n  }\n  getzIndex() {\n    return this.layer.getzIndex();\n  }\n  setzIndex(t) {\n    this.layer.setzIndex(t);\n  }\n  show() {\n    this.layer.show();\n  }\n  hide() {\n    this.layer.hide();\n  }\n}\nclass w extends p {\n  constructor(t, e) {\n    super(), this.linerAnimationFrame = -1, this.layer = t, e = Object.assign({}, {\n      url: \"\",\n      position: [0, 0],\n      height: 0,\n      rotation: {\n        x: 0,\n        y: 0,\n        z: 0\n      },\n      scale: 1,\n      angle: 0\n    }, e), this.init(e);\n  }\n  init(t) {\n    new A().load(t.url, e => {\n      const s = e.scene,\n        i = e.animations;\n      this.layer.add(s), this.object = s, this.animations = i, this.setScale(t.scale), this.setRotation(t.rotation), this.setAngle(t.angle), this.setPosition(t.position), this.setHeight(t.height), t.onLoaded && t.onLoaded(s, i), this.emit(\"complete\", {\n        target: s,\n        animations: i\n      });\n    });\n  }\n  setScale(t) {\n    let e;\n    typeof t == \"number\" ? e = {\n      x: t,\n      y: t,\n      z: t\n    } : e = t, this.object.scale.set(e.x, e.y, e.z), this.refresh();\n  }\n  setPosition(t) {\n    const e = this.layer.convertLngLat(t);\n    this.object.position.setX(e[0]), this.object.position.setY(e[1]), this.refresh();\n  }\n  setRotation(t) {\n    if (t) {\n      const e = Math.PI / 180 * (t.x || 0),\n        s = Math.PI / 180 * (t.y || 0),\n        i = Math.PI / 180 * (t.z || 0);\n      this.object.rotation.set(e, s, i), this.refresh();\n    }\n  }\n  setAngle(t) {\n    const e = this.object.rotation.x,\n      s = this.object.rotation.z,\n      i = Math.PI / 180 * t;\n    this.object.rotation.set(e, i, s), this.refresh();\n  }\n  setHeight(t) {\n    t !== void 0 && (this.object.position.setZ(t), this.refresh());\n  }\n  getAnimations() {\n    return this.animations;\n  }\n  getObject() {\n    return this.object;\n  }\n  refresh() {\n    this.layer.update();\n  }\n  show() {\n    this.object.visible = !0, this.refresh();\n  }\n  hide() {\n    this.object.visible = !1, this.refresh();\n  }\n  animate(t) {\n    this.linerAnimationFrame = requestAnimationFrame(() => {\n      this.animate(t);\n    }), t();\n  }\n  startAnimations() {\n    if (this.animations) {\n      const t = this.animations,\n        e = new j(this.object),\n        s = {};\n      for (let o = 0; o < t.length; o++) {\n        const n = t[o];\n        s[n.name] = e.clipAction(n);\n      }\n      const i = new x();\n      for (const o in s) s[o].play();\n      this.animate(() => {\n        const o = i.getDelta();\n        e && e.update(o), this.refresh();\n      });\n    }\n  }\n  stopAnimations() {\n    cancelAnimationFrame(this.linerAnimationFrame);\n  }\n  remove() {\n    this.object && this.layer.remove(this.object);\n  }\n  destroy() {\n    this.stopAnimations(), this.object && (u(this.object), this.object = null, this.layer = null);\n  }\n}\nexport { w as ThreeGltf, M as ThreeLayer };","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["import{PerspectiveCamera as g,OrthographicCamera as y,WebGLRenderer as b,Scene as v,Cache as C,AnimationMixer as j,Clock as x}from\"three\";import{GLTFLoader as A}from\"three/examples/jsm/loaders/GLTFLoader.js\";class p{constructor(){this._listeners={}}on(t,e,s){this._listeners[t]?this._listeners[t].push({callback:e,isOnce:s}):this._listeners[t]=[{callback:e,isOnce:s}]}off(t,e){if(!e)throw new Error(\"\\u53D6\\u6D88\\u4E8B\\u4EF6\\u65F6\\u9700\\u8981\\u4F20\\u5165\\u539F\\u56DE\\u8C03\\u51FD\\u6570\");const s=this._listeners[t];if(s&&s.length>0){for(let i=0;i<s.length;i++)if(s[i].callback===e){s.splice(i,1);break}}}emit(t,e){const s=this._listeners[t];if(s&&s.length>0)for(let i=0;i<s.length;i++){const o=s[i];o.callback.call(this,e),o.isOnce&&(s.splice(i,1),i--)}}}function z(l){l.traverse(t=>{u(t)})}function u(l){const t=s=>{s.geometry&&s.geometry.dispose(),s.material&&s.material.dispose&&s.material.dispose(),s.material.texture&&s.material.texture.dispose&&s.material.texture.dispose()},e=s=>{let i=s.children.filter(o=>o);i.forEach(o=>{o.children.length?e(o):o.isMesh&&t(o)}),i=null};e(l)}class M extends p{constructor(t,e){super(),this.frameTimer=-1,this.needsUpdate=!1,e=e||{},this.customCoords=t.customCoords,this.center=e.customCoordsCenter||t.getCenter().toArray(),this.customCoords.lngLatsToCoords([this.center]);const s={zooms:[2,20],opacity:1,alpha:!1,antialias:!1,visible:!0,zIndex:120};this.options=Object.assign({},s,e),this.map=t,this.init()}init(){const t=this.map,e=this.options,s={zooms:e.zooms,opacity:e.opacity,visible:e.visible,zIndex:e.zIndex,init:i=>{const o=t.getContainer(),n=o.offsetWidth,r=o.offsetHeight;let a;t.getView().type===\"3D\"?a=new g(60,n/r,100,1<<30):a=new y(n/-2,n/2,r/2,r/-2,1,1e3);const h=new b({context:i,alpha:e.alpha,antialias:e.antialias});h.setSize(n,r),h.autoClear=!1;const c=new v;this.camera=a,this.renderer=h,this.scene=c,e.onInit&&e.onInit(h,c,a),this.animate(),this.emit(\"complete\")},render:()=>{var i,o,n;(i=this.renderer)===null||i===void 0||i.resetState(),this.customCoords.setCenter(this.center);const r=this.camera;if(t.getView().type===\"3D\"){const{near:a,far:h,fov:c,up:m,lookAt:d,position:f}=this.customCoords.getCameraParams();r.near=a,r.far=h,r.fov=c,r.position.set(...f),r.up.set(...m),r.lookAt(...d),r.updateProjectionMatrix()}else{const{top:a,bottom:h,left:c,right:m,position:d}=this.customCoords.getCameraParams();r.top=a,r.bottom=h,r.left=c,r.right=m,r.position.set(...d),r.updateProjectionMatrix()}this.camera=r,e.onRender?e.onRender(this.renderer,this.scene,this.camera):(o=this.renderer)===null||o===void 0||o.render(this.scene,r),(n=this.renderer)===null||n===void 0||n.resetState()}};this.layer=new AMap.GLCustomLayer(s),this.layer.setMap(t)}update(){this.needsUpdate=!0}animate(){this.needsUpdate&&(this.refreshMap(),this.needsUpdate=!1),this.frameTimer=requestAnimationFrame(()=>{this.animate()})}refreshMap(){this.map&&this.map.render()}convertLngLat(t){return this.customCoords.lngLatsToCoords([t])[0]}add(t){var e;(e=this.scene)===null||e===void 0||e.add(t),this.refreshMap()}remove(t){var e;(e=this.scene)===null||e===void 0||e.remove(t),this.refreshMap()}getScene(){return this.scene}getCamera(){return this.camera}getRender(){return this.renderer}destroy(){var t;cancelAnimationFrame(this.frameTimer),this.layer.setMap(null),this.customCoords=null,z(this.scene),this.scene=void 0,this.camera=void 0,(t=this.renderer)===null||t===void 0||t.dispose(),this.renderer=void 0,this.layer=null,this.map=null,C.clear(),this.options=null}getMap(){return this.map?this.map:null}getOpacity(){return this.layer.getOpacity()}setOpacity(t){this.layer.setOpacity(t)}getZooms(){return this.layer.getZooms()}setZooms(t){this.layer.setZooms(t)}getzIndex(){return this.layer.getzIndex()}setzIndex(t){this.layer.setzIndex(t)}show(){this.layer.show()}hide(){this.layer.hide()}}class w extends p{constructor(t,e){super(),this.linerAnimationFrame=-1,this.layer=t,e=Object.assign({},{url:\"\",position:[0,0],height:0,rotation:{x:0,y:0,z:0},scale:1,angle:0},e),this.init(e)}init(t){new A().load(t.url,e=>{const s=e.scene,i=e.animations;this.layer.add(s),this.object=s,this.animations=i,this.setScale(t.scale),this.setRotation(t.rotation),this.setAngle(t.angle),this.setPosition(t.position),this.setHeight(t.height),t.onLoaded&&t.onLoaded(s,i),this.emit(\"complete\",{target:s,animations:i})})}setScale(t){let e;typeof t==\"number\"?e={x:t,y:t,z:t}:e=t,this.object.scale.set(e.x,e.y,e.z),this.refresh()}setPosition(t){const e=this.layer.convertLngLat(t);this.object.position.setX(e[0]),this.object.position.setY(e[1]),this.refresh()}setRotation(t){if(t){const e=Math.PI/180*(t.x||0),s=Math.PI/180*(t.y||0),i=Math.PI/180*(t.z||0);this.object.rotation.set(e,s,i),this.refresh()}}setAngle(t){const e=this.object.rotation.x,s=this.object.rotation.z,i=Math.PI/180*t;this.object.rotation.set(e,i,s),this.refresh()}setHeight(t){t!==void 0&&(this.object.position.setZ(t),this.refresh())}getAnimations(){return this.animations}getObject(){return this.object}refresh(){this.layer.update()}show(){this.object.visible=!0,this.refresh()}hide(){this.object.visible=!1,this.refresh()}animate(t){this.linerAnimationFrame=requestAnimationFrame(()=>{this.animate(t)}),t()}startAnimations(){if(this.animations){const t=this.animations,e=new j(this.object),s={};for(let o=0;o<t.length;o++){const n=t[o];s[n.name]=e.clipAction(n)}const i=new x;for(const o in s)s[o].play();this.animate(()=>{const o=i.getDelta();e&&e.update(o),this.refresh()})}}stopAnimations(){cancelAnimationFrame(this.linerAnimationFrame)}remove(){this.object&&this.layer.remove(this.object)}destroy(){this.stopAnimations(),this.object&&(u(this.object),this.object=null,this.layer=null)}}export{w as ThreeGltf,M as ThreeLayer};\n//# sourceMappingURL=index-es.js.map\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
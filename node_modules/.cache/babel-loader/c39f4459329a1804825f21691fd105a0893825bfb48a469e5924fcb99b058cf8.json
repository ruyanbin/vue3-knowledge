{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport * as echarts from 'echarts/lib/echarts';\nimport * as numberUtil from 'echarts/lib/util/number';\nimport LiquidShape from './liquidFillShape';\nvar parsePercent = numberUtil.parsePercent;\nfunction isPathSymbol(symbol) {\n  return symbol && symbol.indexOf('path://') === 0;\n}\necharts.extendChartView({\n  type: 'liquidFill',\n  render: function (seriesModel, ecModel, api) {\n    var self = this;\n    var group = this.group;\n    group.removeAll();\n    var data = seriesModel.getData();\n    var itemModel = data.getItemModel(0);\n    var center = itemModel.get('center');\n    var radius = itemModel.get('radius');\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    // itemStyle\n    var outlineDistance = 0;\n    var outlineBorderWidth = 0;\n    var showOutline = seriesModel.get('outline.show');\n    if (showOutline) {\n      outlineDistance = seriesModel.get('outline.borderDistance');\n      outlineBorderWidth = parsePercent(seriesModel.get('outline.itemStyle.borderWidth'), size);\n    }\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var outterRadius;\n    var innerRadius;\n    var paddingRadius;\n    var isFillContainer = false;\n    var symbol = seriesModel.get('shape');\n    if (symbol === 'container') {\n      // a shape that fully fills the container\n      isFillContainer = true;\n      outterRadius = [width / 2, height / 2];\n      innerRadius = [outterRadius[0] - outlineBorderWidth / 2, outterRadius[1] - outlineBorderWidth / 2];\n      paddingRadius = [parsePercent(outlineDistance, width), parsePercent(outlineDistance, height)];\n      radius = [Math.max(innerRadius[0] - paddingRadius[0], 0), Math.max(innerRadius[1] - paddingRadius[1], 0)];\n    } else {\n      outterRadius = parsePercent(radius, size) / 2;\n      innerRadius = outterRadius - outlineBorderWidth / 2;\n      paddingRadius = parsePercent(outlineDistance, size);\n      radius = Math.max(innerRadius - paddingRadius, 0);\n    }\n    if (showOutline) {\n      var outline = getOutline();\n      outline.style.lineWidth = outlineBorderWidth;\n      group.add(getOutline());\n    }\n    var left = isFillContainer ? 0 : cx - radius;\n    var top = isFillContainer ? 0 : cy - radius;\n    var wavePath = null;\n    group.add(getBackground());\n\n    // each data item for a wave\n    var oldData = this._data;\n    var waves = [];\n    data.diff(oldData).add(function (idx) {\n      var wave = getWave(idx, false);\n      var waterLevel = wave.shape.waterLevel;\n      wave.shape.waterLevel = isFillContainer ? height / 2 : radius;\n      echarts.graphic.initProps(wave, {\n        shape: {\n          waterLevel: waterLevel\n        }\n      }, seriesModel);\n      wave.z2 = 2;\n      setWaveAnimation(idx, wave, null);\n      group.add(wave);\n      data.setItemGraphicEl(idx, wave);\n      waves.push(wave);\n    }).update(function (newIdx, oldIdx) {\n      var waveElement = oldData.getItemGraphicEl(oldIdx);\n\n      // new wave is used to calculate position, but not added\n      var newWave = getWave(newIdx, false, waveElement);\n\n      // changes with animation\n      var shape = {};\n      var shapeAttrs = ['amplitude', 'cx', 'cy', 'phase', 'radius', 'radiusY', 'waterLevel', 'waveLength'];\n      for (var i = 0; i < shapeAttrs.length; ++i) {\n        var attr = shapeAttrs[i];\n        if (newWave.shape.hasOwnProperty(attr)) {\n          shape[attr] = newWave.shape[attr];\n        }\n      }\n      var style = {};\n      var styleAttrs = ['fill', 'opacity', 'shadowBlur', 'shadowColor'];\n      for (var i = 0; i < styleAttrs.length; ++i) {\n        var attr = styleAttrs[i];\n        if (newWave.style.hasOwnProperty(attr)) {\n          style[attr] = newWave.style[attr];\n        }\n      }\n      if (isFillContainer) {\n        shape.radiusY = height / 2;\n      }\n\n      // changes with animation\n      echarts.graphic.updateProps(waveElement, {\n        shape: shape,\n        x: newWave.x,\n        y: newWave.y\n      }, seriesModel);\n      if (seriesModel.isUniversalTransitionEnabled && seriesModel.isUniversalTransitionEnabled()) {\n        echarts.graphic.updateProps(waveElement, {\n          style: style\n        }, seriesModel);\n      } else {\n        waveElement.useStyle(style);\n      }\n\n      // instant changes\n      var oldWaveClipPath = waveElement.getClipPath();\n      var newWaveClipPath = newWave.getClipPath();\n      waveElement.setClipPath(newWave.getClipPath());\n      waveElement.shape.inverse = newWave.inverse;\n      if (oldWaveClipPath && newWaveClipPath && self._shape === symbol\n      // TODO use zrender morphing to apply complex symbol animation.\n      && !isPathSymbol(symbol)) {\n        // Can be animated.\n        echarts.graphic.updateProps(newWaveClipPath, {\n          shape: oldWaveClipPath.shape\n        }, seriesModel, {\n          isFrom: true\n        });\n      }\n      setWaveAnimation(newIdx, waveElement, waveElement);\n      group.add(waveElement);\n      data.setItemGraphicEl(newIdx, waveElement);\n      waves.push(waveElement);\n    }).remove(function (idx) {\n      var wave = oldData.getItemGraphicEl(idx);\n      group.remove(wave);\n    }).execute();\n    if (itemModel.get('label.show')) {\n      group.add(getText(waves));\n    }\n    this._shape = symbol;\n    this._data = data;\n\n    /**\n     * Get path for outline, background and clipping\n     *\n     * @param {number} r outter radius of shape\n     * @param {boolean|undefined} isForClipping if the shape is used\n     *                                          for clipping\n     */\n    function getPath(r, isForClipping) {\n      if (symbol) {\n        // customed symbol path\n        if (isPathSymbol(symbol)) {\n          var path = echarts.graphic.makePath(symbol.slice(7), {});\n          var bouding = path.getBoundingRect();\n          var w = bouding.width;\n          var h = bouding.height;\n          if (w > h) {\n            h = r * 2 / w * h;\n            w = r * 2;\n          } else {\n            w = r * 2 / h * w;\n            h = r * 2;\n          }\n          var left = isForClipping ? 0 : cx - w / 2;\n          var top = isForClipping ? 0 : cy - h / 2;\n          path = echarts.graphic.makePath(symbol.slice(7), {}, new echarts.graphic.BoundingRect(left, top, w, h));\n          if (isForClipping) {\n            path.x = -w / 2;\n            path.y = -h / 2;\n          }\n          return path;\n        } else if (isFillContainer) {\n          // fully fill the container\n          var x = isForClipping ? -r[0] : cx - r[0];\n          var y = isForClipping ? -r[1] : cy - r[1];\n          return echarts.helper.createSymbol('rect', x, y, r[0] * 2, r[1] * 2);\n        } else {\n          var x = isForClipping ? -r : cx - r;\n          var y = isForClipping ? -r : cy - r;\n          if (symbol === 'pin') {\n            y += r;\n          } else if (symbol === 'arrow') {\n            y -= r;\n          }\n          return echarts.helper.createSymbol(symbol, x, y, r * 2, r * 2);\n        }\n      }\n      return new echarts.graphic.Circle({\n        shape: {\n          cx: isForClipping ? 0 : cx,\n          cy: isForClipping ? 0 : cy,\n          r: r\n        }\n      });\n    }\n    /**\n     * Create outline\n     */\n    function getOutline() {\n      var outlinePath = getPath(outterRadius);\n      outlinePath.style.fill = null;\n      outlinePath.setStyle(seriesModel.getModel('outline.itemStyle').getItemStyle());\n      return outlinePath;\n    }\n\n    /**\n     * Create background\n     */\n    function getBackground() {\n      // Seperate stroke and fill, so we can use stroke to cover the alias of clipping.\n      var strokePath = getPath(radius);\n      strokePath.setStyle(seriesModel.getModel('backgroundStyle').getItemStyle());\n      strokePath.style.fill = null;\n\n      // Stroke is front of wave\n      strokePath.z2 = 5;\n      var fillPath = getPath(radius);\n      fillPath.setStyle(seriesModel.getModel('backgroundStyle').getItemStyle());\n      fillPath.style.stroke = null;\n      var group = new echarts.graphic.Group();\n      group.add(strokePath);\n      group.add(fillPath);\n      return group;\n    }\n\n    /**\n     * wave shape\n     */\n    function getWave(idx, isInverse, oldWave) {\n      var radiusX = isFillContainer ? radius[0] : radius;\n      var radiusY = isFillContainer ? height / 2 : radius;\n      var itemModel = data.getItemModel(idx);\n      var itemStyleModel = itemModel.getModel('itemStyle');\n      var phase = itemModel.get('phase');\n      var amplitude = parsePercent(itemModel.get('amplitude'), radiusY * 2);\n      var waveLength = parsePercent(itemModel.get('waveLength'), radiusX * 2);\n      var value = data.get('value', idx);\n      var waterLevel = radiusY - value * radiusY * 2;\n      phase = oldWave ? oldWave.shape.phase : phase === 'auto' ? idx * Math.PI / 4 : phase;\n      var normalStyle = itemStyleModel.getItemStyle();\n      if (!normalStyle.fill) {\n        var seriesColor = seriesModel.get('color');\n        var id = idx % seriesColor.length;\n        normalStyle.fill = seriesColor[id];\n      }\n      var x = radiusX * 2;\n      var wave = new LiquidShape({\n        shape: {\n          waveLength: waveLength,\n          radius: radiusX,\n          radiusY: radiusY,\n          cx: x,\n          cy: 0,\n          waterLevel: waterLevel,\n          amplitude: amplitude,\n          phase: phase,\n          inverse: isInverse\n        },\n        style: normalStyle,\n        x: cx,\n        y: cy\n      });\n      wave.shape._waterLevel = waterLevel;\n      var hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n      hoverStyle.lineWidth = 0;\n      wave.ensureState('emphasis').style = hoverStyle;\n      echarts.helper.enableHoverEmphasis(wave);\n\n      // clip out the part outside the circle\n      var clip = getPath(radius, true);\n      // set fill for clipPath, otherwise it will not trigger hover event\n      clip.setStyle({\n        fill: 'white'\n      });\n      wave.setClipPath(clip);\n      return wave;\n    }\n    function setWaveAnimation(idx, wave, oldWave) {\n      var itemModel = data.getItemModel(idx);\n      var maxSpeed = itemModel.get('period');\n      var direction = itemModel.get('direction');\n      var value = data.get('value', idx);\n      var phase = itemModel.get('phase');\n      phase = oldWave ? oldWave.shape.phase : phase === 'auto' ? idx * Math.PI / 4 : phase;\n      var defaultSpeed = function (maxSpeed) {\n        var cnt = data.count();\n        return cnt === 0 ? maxSpeed : maxSpeed * (0.2 + (cnt - idx) / cnt * 0.8);\n      };\n      var speed = 0;\n      if (maxSpeed === 'auto') {\n        speed = defaultSpeed(5000);\n      } else {\n        speed = typeof maxSpeed === 'function' ? maxSpeed(value, idx) : maxSpeed;\n      }\n\n      // phase for moving left/right\n      var phaseOffset = 0;\n      if (direction === 'right' || direction == null) {\n        phaseOffset = Math.PI;\n      } else if (direction === 'left') {\n        phaseOffset = -Math.PI;\n      } else if (direction === 'none') {\n        phaseOffset = 0;\n      } else {\n        console.error('Illegal direction value for liquid fill.');\n      }\n\n      // wave animation of moving left/right\n      if (direction !== 'none' && itemModel.get('waveAnimation')) {\n        wave.animate('shape', true).when(0, {\n          phase: phase\n        }).when(speed / 2, {\n          phase: phaseOffset + phase\n        }).when(speed, {\n          phase: phaseOffset * 2 + phase\n        }).during(function () {\n          if (wavePath) {\n            wavePath.dirty(true);\n          }\n        }).start();\n      }\n    }\n\n    /**\n     * text on wave\n     */\n    function getText(waves) {\n      var labelModel = itemModel.getModel('label');\n      function formatLabel() {\n        var formatted = seriesModel.getFormattedLabel(0, 'normal');\n        var defaultVal = data.get('value', 0) * 100;\n        var defaultLabel = data.getName(0) || seriesModel.name;\n        if (!isNaN(defaultVal)) {\n          defaultLabel = defaultVal.toFixed(0) + '%';\n        }\n        return formatted == null ? defaultLabel : formatted;\n      }\n      var textRectOption = {\n        z2: 10,\n        shape: {\n          x: left,\n          y: top,\n          width: (isFillContainer ? radius[0] : radius) * 2,\n          height: (isFillContainer ? radius[1] : radius) * 2\n        },\n        style: {\n          fill: 'transparent'\n        },\n        textConfig: {\n          position: labelModel.get('position') || 'inside'\n        },\n        silent: true\n      };\n      var textOption = {\n        style: {\n          text: formatLabel(),\n          textAlign: labelModel.get('align'),\n          textVerticalAlign: labelModel.get('baseline')\n        }\n      };\n      Object.assign(textOption.style, echarts.helper.createTextStyle(labelModel));\n      var outsideTextRect = new echarts.graphic.Rect(textRectOption);\n      var insideTextRect = new echarts.graphic.Rect(textRectOption);\n      insideTextRect.disableLabelAnimation = true;\n      outsideTextRect.disableLabelAnimation = true;\n      var outsideText = new echarts.graphic.Text(textOption);\n      var insideText = new echarts.graphic.Text(textOption);\n      outsideTextRect.setTextContent(outsideText);\n      insideTextRect.setTextContent(insideText);\n      var insColor = labelModel.get('insideColor');\n      insideText.style.fill = insColor;\n      var group = new echarts.graphic.Group();\n      group.add(outsideTextRect);\n      group.add(insideTextRect);\n\n      // clip out waves for insideText\n      var boundingCircle = getPath(radius, true);\n      wavePath = new echarts.graphic.CompoundPath({\n        shape: {\n          paths: waves\n        },\n        x: cx,\n        y: cy\n      });\n      wavePath.setClipPath(boundingCircle);\n      insideTextRect.setClipPath(wavePath);\n      return group;\n    }\n  },\n  dispose: function () {\n    // dispose nothing here\n  }\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
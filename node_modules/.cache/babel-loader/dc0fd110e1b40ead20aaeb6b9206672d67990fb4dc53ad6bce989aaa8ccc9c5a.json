{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nfunction t(t) {\n  return t.split(\"-\")[0];\n}\nfunction e(t) {\n  return t.split(\"-\")[1];\n}\nfunction n(e) {\n  return [\"top\", \"bottom\"].includes(t(e)) ? \"x\" : \"y\";\n}\nfunction i(t) {\n  return \"y\" === t ? \"height\" : \"width\";\n}\nfunction o(o, r, a) {\n  let {\n    reference: l,\n    floating: s\n  } = o;\n  const c = l.x + l.width / 2 - s.width / 2,\n    f = l.y + l.height / 2 - s.height / 2,\n    u = n(r),\n    m = i(u),\n    g = l[m] / 2 - s[m] / 2,\n    d = \"x\" === u;\n  let p;\n  switch (t(r)) {\n    case \"top\":\n      p = {\n        x: c,\n        y: l.y - s.height\n      };\n      break;\n    case \"bottom\":\n      p = {\n        x: c,\n        y: l.y + l.height\n      };\n      break;\n    case \"right\":\n      p = {\n        x: l.x + l.width,\n        y: f\n      };\n      break;\n    case \"left\":\n      p = {\n        x: l.x - s.width,\n        y: f\n      };\n      break;\n    default:\n      p = {\n        x: l.x,\n        y: l.y\n      };\n  }\n  switch (e(r)) {\n    case \"start\":\n      p[u] -= g * (a && d ? -1 : 1);\n      break;\n    case \"end\":\n      p[u] += g * (a && d ? -1 : 1);\n  }\n  return p;\n}\nconst r = async (t, e, n) => {\n  const {\n      placement: i = \"bottom\",\n      strategy: r = \"absolute\",\n      middleware: a = [],\n      platform: l\n    } = n,\n    s = a.filter(Boolean),\n    c = await (null == l.isRTL ? void 0 : l.isRTL(e));\n  let f = await l.getElementRects({\n      reference: t,\n      floating: e,\n      strategy: r\n    }),\n    {\n      x: u,\n      y: m\n    } = o(f, i, c),\n    g = i,\n    d = {},\n    p = 0;\n  for (let n = 0; n < s.length; n++) {\n    const {\n        name: a,\n        fn: h\n      } = s[n],\n      {\n        x: y,\n        y: x,\n        data: w,\n        reset: v\n      } = await h({\n        x: u,\n        y: m,\n        initialPlacement: i,\n        placement: g,\n        strategy: r,\n        middlewareData: d,\n        rects: f,\n        platform: l,\n        elements: {\n          reference: t,\n          floating: e\n        }\n      });\n    u = null != y ? y : u, m = null != x ? x : m, d = {\n      ...d,\n      [a]: {\n        ...d[a],\n        ...w\n      }\n    }, v && p <= 50 && (p++, \"object\" == typeof v && (v.placement && (g = v.placement), v.rects && (f = !0 === v.rects ? await l.getElementRects({\n      reference: t,\n      floating: e,\n      strategy: r\n    }) : v.rects), ({\n      x: u,\n      y: m\n    } = o(f, g, c))), n = -1);\n  }\n  return {\n    x: u,\n    y: m,\n    placement: g,\n    strategy: r,\n    middlewareData: d\n  };\n};\nfunction a(t) {\n  return \"number\" != typeof t ? function (t) {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...t\n    };\n  }(t) : {\n    top: t,\n    right: t,\n    bottom: t,\n    left: t\n  };\n}\nfunction l(t) {\n  return {\n    ...t,\n    top: t.y,\n    left: t.x,\n    right: t.x + t.width,\n    bottom: t.y + t.height\n  };\n}\nasync function s(t, e) {\n  var n;\n  void 0 === e && (e = {});\n  const {\n      x: i,\n      y: o,\n      platform: r,\n      rects: s,\n      elements: c,\n      strategy: f\n    } = t,\n    {\n      boundary: u = \"clippingAncestors\",\n      rootBoundary: m = \"viewport\",\n      elementContext: g = \"floating\",\n      altBoundary: d = !1,\n      padding: p = 0\n    } = e,\n    h = a(p),\n    y = c[d ? \"floating\" === g ? \"reference\" : \"floating\" : g],\n    x = l(await r.getClippingRect({\n      element: null == (n = await (null == r.isElement ? void 0 : r.isElement(y))) || n ? y : y.contextElement || (await (null == r.getDocumentElement ? void 0 : r.getDocumentElement(c.floating))),\n      boundary: u,\n      rootBoundary: m,\n      strategy: f\n    })),\n    w = \"floating\" === g ? {\n      ...s.floating,\n      x: i,\n      y: o\n    } : s.reference,\n    v = await (null == r.getOffsetParent ? void 0 : r.getOffsetParent(c.floating)),\n    b = (await (null == r.isElement ? void 0 : r.isElement(v))) && (await (null == r.getScale ? void 0 : r.getScale(v))) || {\n      x: 1,\n      y: 1\n    },\n    R = l(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({\n      rect: w,\n      offsetParent: v,\n      strategy: f\n    }) : w);\n  return {\n    top: (x.top - R.top + h.top) / b.y,\n    bottom: (R.bottom - x.bottom + h.bottom) / b.y,\n    left: (x.left - R.left + h.left) / b.x,\n    right: (R.right - x.right + h.right) / b.x\n  };\n}\nconst c = Math.min,\n  f = Math.max;\nfunction u(t, e, n) {\n  return f(t, c(e, n));\n}\nconst m = t => ({\n    name: \"arrow\",\n    options: t,\n    async fn(o) {\n      const {\n          element: r,\n          padding: l = 0\n        } = null != t ? t : {},\n        {\n          x: s,\n          y: c,\n          placement: f,\n          rects: m,\n          platform: g\n        } = o;\n      if (null == r) return {};\n      const d = a(l),\n        p = {\n          x: s,\n          y: c\n        },\n        h = n(f),\n        y = i(h),\n        x = await g.getDimensions(r),\n        w = \"y\" === h ? \"top\" : \"left\",\n        v = \"y\" === h ? \"bottom\" : \"right\",\n        b = m.reference[y] + m.reference[h] - p[h] - m.floating[y],\n        R = p[h] - m.reference[h],\n        A = await (null == g.getOffsetParent ? void 0 : g.getOffsetParent(r));\n      let P = A ? \"y\" === h ? A.clientHeight || 0 : A.clientWidth || 0 : 0;\n      0 === P && (P = m.floating[y]);\n      const T = b / 2 - R / 2,\n        O = d[w],\n        E = P - x[y] - d[v],\n        L = P / 2 - x[y] / 2 + T,\n        D = u(O, L, E),\n        k = null != e(f) && L != D && m.reference[y] / 2 - (L < O ? d[w] : d[v]) - x[y] / 2 < 0;\n      return {\n        [h]: p[h] - (k ? L < O ? O - L : E - L : 0),\n        data: {\n          [h]: D,\n          centerOffset: L - D\n        }\n      };\n    }\n  }),\n  g = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n  };\nfunction d(t) {\n  return t.replace(/left|right|bottom|top/g, t => g[t]);\n}\nfunction p(t, o, r) {\n  void 0 === r && (r = !1);\n  const a = e(t),\n    l = n(t),\n    s = i(l);\n  let c = \"x\" === l ? a === (r ? \"end\" : \"start\") ? \"right\" : \"left\" : \"start\" === a ? \"bottom\" : \"top\";\n  return o.reference[s] > o.floating[s] && (c = d(c)), {\n    main: c,\n    cross: d(c)\n  };\n}\nconst h = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction y(t) {\n  return t.replace(/start|end/g, t => h[t]);\n}\nconst x = [\"top\", \"right\", \"bottom\", \"left\"],\n  w = x.reduce((t, e) => t.concat(e, e + \"-start\", e + \"-end\"), []);\nconst v = function (n) {\n  return void 0 === n && (n = {}), {\n    name: \"autoPlacement\",\n    options: n,\n    async fn(i) {\n      var o, r, a, l, c;\n      const {\n          x: f,\n          y: u,\n          rects: m,\n          middlewareData: g,\n          placement: d,\n          platform: h,\n          elements: x\n        } = i,\n        {\n          alignment: v,\n          allowedPlacements: b = w,\n          autoAlignment: R = !0,\n          ...A\n        } = n,\n        P = void 0 !== v || b === w ? function (n, i, o) {\n          return (n ? [...o.filter(t => e(t) === n), ...o.filter(t => e(t) !== n)] : o.filter(e => t(e) === e)).filter(t => !n || e(t) === n || !!i && y(t) !== t);\n        }(v || null, R, b) : b,\n        T = await s(i, A),\n        O = null != (o = null == (r = g.autoPlacement) ? void 0 : r.index) ? o : 0,\n        E = P[O];\n      if (null == E) return {};\n      const {\n        main: L,\n        cross: D\n      } = p(E, m, await (null == h.isRTL ? void 0 : h.isRTL(x.floating)));\n      if (d !== E) return {\n        x: f,\n        y: u,\n        reset: {\n          placement: P[0]\n        }\n      };\n      const k = [T[t(E)], T[L], T[D]],\n        B = [...(null != (a = null == (l = g.autoPlacement) ? void 0 : l.overflows) ? a : []), {\n          placement: E,\n          overflows: k\n        }],\n        C = P[O + 1];\n      if (C) return {\n        data: {\n          index: O + 1,\n          overflows: B\n        },\n        reset: {\n          placement: C\n        }\n      };\n      const H = B.slice().sort((t, e) => t.overflows[0] - e.overflows[0]),\n        V = null == (c = H.find(t => {\n          let {\n            overflows: e\n          } = t;\n          return e.every(t => t <= 0);\n        })) ? void 0 : c.placement,\n        S = null != V ? V : H[0].placement;\n      return S !== d ? {\n        data: {\n          index: O + 1,\n          overflows: B\n        },\n        reset: {\n          placement: S\n        }\n      } : {};\n    }\n  };\n};\nconst b = function (e) {\n  return void 0 === e && (e = {}), {\n    name: \"flip\",\n    options: e,\n    async fn(n) {\n      var i;\n      const {\n          placement: o,\n          middlewareData: r,\n          rects: a,\n          initialPlacement: l,\n          platform: c,\n          elements: f\n        } = n,\n        {\n          mainAxis: u = !0,\n          crossAxis: m = !0,\n          fallbackPlacements: g,\n          fallbackStrategy: h = \"bestFit\",\n          flipAlignment: x = !0,\n          ...w\n        } = e,\n        v = t(o),\n        b = g || (v === l || !x ? [d(l)] : function (t) {\n          const e = d(t);\n          return [y(t), e, y(e)];\n        }(l)),\n        R = [l, ...b],\n        A = await s(n, w),\n        P = [];\n      let T = (null == (i = r.flip) ? void 0 : i.overflows) || [];\n      if (u && P.push(A[v]), m) {\n        const {\n          main: t,\n          cross: e\n        } = p(o, a, await (null == c.isRTL ? void 0 : c.isRTL(f.floating)));\n        P.push(A[t], A[e]);\n      }\n      if (T = [...T, {\n        placement: o,\n        overflows: P\n      }], !P.every(t => t <= 0)) {\n        var O, E;\n        const t = (null != (O = null == (E = r.flip) ? void 0 : E.index) ? O : 0) + 1,\n          e = R[t];\n        if (e) return {\n          data: {\n            index: t,\n            overflows: T\n          },\n          reset: {\n            placement: e\n          }\n        };\n        let n = \"bottom\";\n        switch (h) {\n          case \"bestFit\":\n            {\n              var L;\n              const t = null == (L = T.map(t => [t, t.overflows.filter(t => t > 0).reduce((t, e) => t + e, 0)]).sort((t, e) => t[1] - e[1])[0]) ? void 0 : L[0].placement;\n              t && (n = t);\n              break;\n            }\n          case \"initialPlacement\":\n            n = l;\n        }\n        if (o !== n) return {\n          reset: {\n            placement: n\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\nfunction R(t, e) {\n  return {\n    top: t.top - e.height,\n    right: t.right - e.width,\n    bottom: t.bottom - e.height,\n    left: t.left - e.width\n  };\n}\nfunction A(t) {\n  return x.some(e => t[e] >= 0);\n}\nconst P = function (t) {\n  return void 0 === t && (t = {}), {\n    name: \"hide\",\n    options: t,\n    async fn(e) {\n      const {\n          strategy: n = \"referenceHidden\",\n          ...i\n        } = t,\n        {\n          rects: o\n        } = e;\n      switch (n) {\n        case \"referenceHidden\":\n          {\n            const t = R(await s(e, {\n              ...i,\n              elementContext: \"reference\"\n            }), o.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: t,\n                referenceHidden: A(t)\n              }\n            };\n          }\n        case \"escaped\":\n          {\n            const t = R(await s(e, {\n              ...i,\n              altBoundary: !0\n            }), o.floating);\n            return {\n              data: {\n                escapedOffsets: t,\n                escaped: A(t)\n              }\n            };\n          }\n        default:\n          return {};\n      }\n    }\n  };\n};\nconst T = function (i) {\n  return void 0 === i && (i = 0), {\n    name: \"offset\",\n    options: i,\n    async fn(o) {\n      const {\n          x: r,\n          y: a\n        } = o,\n        l = await async function (i, o) {\n          const {\n              placement: r,\n              platform: a,\n              elements: l\n            } = i,\n            s = await (null == a.isRTL ? void 0 : a.isRTL(l.floating)),\n            c = t(r),\n            f = e(r),\n            u = \"x\" === n(r),\n            m = [\"left\", \"top\"].includes(c) ? -1 : 1,\n            g = s && u ? -1 : 1,\n            d = \"function\" == typeof o ? o(i) : o;\n          let {\n            mainAxis: p,\n            crossAxis: h,\n            alignmentAxis: y\n          } = \"number\" == typeof d ? {\n            mainAxis: d,\n            crossAxis: 0,\n            alignmentAxis: null\n          } : {\n            mainAxis: 0,\n            crossAxis: 0,\n            alignmentAxis: null,\n            ...d\n          };\n          return f && \"number\" == typeof y && (h = \"end\" === f ? -1 * y : y), u ? {\n            x: h * g,\n            y: p * m\n          } : {\n            x: p * m,\n            y: h * g\n          };\n        }(o, i);\n      return {\n        x: r + l.x,\n        y: a + l.y,\n        data: l\n      };\n    }\n  };\n};\nfunction O(t) {\n  return \"x\" === t ? \"y\" : \"x\";\n}\nconst E = function (e) {\n    return void 0 === e && (e = {}), {\n      name: \"shift\",\n      options: e,\n      async fn(i) {\n        const {\n            x: o,\n            y: r,\n            placement: a\n          } = i,\n          {\n            mainAxis: l = !0,\n            crossAxis: c = !1,\n            limiter: f = {\n              fn: t => {\n                let {\n                  x: e,\n                  y: n\n                } = t;\n                return {\n                  x: e,\n                  y: n\n                };\n              }\n            },\n            ...m\n          } = e,\n          g = {\n            x: o,\n            y: r\n          },\n          d = await s(i, m),\n          p = n(t(a)),\n          h = O(p);\n        let y = g[p],\n          x = g[h];\n        if (l) {\n          const t = \"y\" === p ? \"bottom\" : \"right\";\n          y = u(y + d[\"y\" === p ? \"top\" : \"left\"], y, y - d[t]);\n        }\n        if (c) {\n          const t = \"y\" === h ? \"bottom\" : \"right\";\n          x = u(x + d[\"y\" === h ? \"top\" : \"left\"], x, x - d[t]);\n        }\n        const w = f.fn({\n          ...i,\n          [p]: y,\n          [h]: x\n        });\n        return {\n          ...w,\n          data: {\n            x: w.x - o,\n            y: w.y - r\n          }\n        };\n      }\n    };\n  },\n  L = function (e) {\n    return void 0 === e && (e = {}), {\n      options: e,\n      fn(i) {\n        const {\n            x: o,\n            y: r,\n            placement: a,\n            rects: l,\n            middlewareData: s\n          } = i,\n          {\n            offset: c = 0,\n            mainAxis: f = !0,\n            crossAxis: u = !0\n          } = e,\n          m = {\n            x: o,\n            y: r\n          },\n          g = n(a),\n          d = O(g);\n        let p = m[g],\n          h = m[d];\n        const y = \"function\" == typeof c ? c(i) : c,\n          x = \"number\" == typeof y ? {\n            mainAxis: y,\n            crossAxis: 0\n          } : {\n            mainAxis: 0,\n            crossAxis: 0,\n            ...y\n          };\n        if (f) {\n          const t = \"y\" === g ? \"height\" : \"width\",\n            e = l.reference[g] - l.floating[t] + x.mainAxis,\n            n = l.reference[g] + l.reference[t] - x.mainAxis;\n          p < e ? p = e : p > n && (p = n);\n        }\n        if (u) {\n          var w, v, b, R;\n          const e = \"y\" === g ? \"width\" : \"height\",\n            n = [\"top\", \"left\"].includes(t(a)),\n            i = l.reference[d] - l.floating[e] + (n && null != (w = null == (v = s.offset) ? void 0 : v[d]) ? w : 0) + (n ? 0 : x.crossAxis),\n            o = l.reference[d] + l.reference[e] + (n ? 0 : null != (b = null == (R = s.offset) ? void 0 : R[d]) ? b : 0) - (n ? x.crossAxis : 0);\n          h < i ? h = i : h > o && (h = o);\n        }\n        return {\n          [g]: p,\n          [d]: h\n        };\n      }\n    };\n  },\n  D = function (n) {\n    return void 0 === n && (n = {}), {\n      name: \"size\",\n      options: n,\n      async fn(i) {\n        const {\n            placement: o,\n            rects: r,\n            platform: a,\n            elements: l\n          } = i,\n          {\n            apply: c = () => {},\n            ...u\n          } = n,\n          m = await s(i, u),\n          g = t(o),\n          d = e(o);\n        let p, h;\n        \"top\" === g || \"bottom\" === g ? (p = g, h = d === ((await (null == a.isRTL ? void 0 : a.isRTL(l.floating))) ? \"start\" : \"end\") ? \"left\" : \"right\") : (h = g, p = \"end\" === d ? \"top\" : \"bottom\");\n        const y = f(m.left, 0),\n          x = f(m.right, 0),\n          w = f(m.top, 0),\n          v = f(m.bottom, 0),\n          b = {\n            availableHeight: r.floating.height - ([\"left\", \"right\"].includes(o) ? 2 * (0 !== w || 0 !== v ? w + v : f(m.top, m.bottom)) : m[p]),\n            availableWidth: r.floating.width - ([\"top\", \"bottom\"].includes(o) ? 2 * (0 !== y || 0 !== x ? y + x : f(m.left, m.right)) : m[h])\n          };\n        await c({\n          ...i,\n          ...b\n        });\n        const R = await a.getDimensions(l.floating);\n        return r.floating.width !== R.width || r.floating.height !== R.height ? {\n          reset: {\n            rects: !0\n          }\n        } : {};\n      }\n    };\n  },\n  k = function (e) {\n    return void 0 === e && (e = {}), {\n      name: \"inline\",\n      options: e,\n      async fn(i) {\n        var o;\n        const {\n            placement: r,\n            elements: s,\n            rects: u,\n            platform: m,\n            strategy: g\n          } = i,\n          {\n            padding: d = 2,\n            x: p,\n            y: h\n          } = e,\n          y = l(m.convertOffsetParentRelativeRectToViewportRelativeRect ? await m.convertOffsetParentRelativeRectToViewportRelativeRect({\n            rect: u.reference,\n            offsetParent: await (null == m.getOffsetParent ? void 0 : m.getOffsetParent(s.floating)),\n            strategy: g\n          }) : u.reference),\n          x = null != (o = await (null == m.getClientRects ? void 0 : m.getClientRects(s.reference))) ? o : [],\n          w = a(d);\n        const v = await m.getElementRects({\n          reference: {\n            getBoundingClientRect: function () {\n              var e;\n              if (2 === x.length && x[0].left > x[1].right && null != p && null != h) return null != (e = x.find(t => p > t.left - w.left && p < t.right + w.right && h > t.top - w.top && h < t.bottom + w.bottom)) ? e : y;\n              if (x.length >= 2) {\n                if (\"x\" === n(r)) {\n                  const e = x[0],\n                    n = x[x.length - 1],\n                    i = \"top\" === t(r),\n                    o = e.top,\n                    a = n.bottom,\n                    l = i ? e.left : n.left,\n                    s = i ? e.right : n.right;\n                  return {\n                    top: o,\n                    bottom: a,\n                    left: l,\n                    right: s,\n                    width: s - l,\n                    height: a - o,\n                    x: l,\n                    y: o\n                  };\n                }\n                const e = \"left\" === t(r),\n                  i = f(...x.map(t => t.right)),\n                  o = c(...x.map(t => t.left)),\n                  a = x.filter(t => e ? t.left === o : t.right === i),\n                  l = a[0].top,\n                  s = a[a.length - 1].bottom;\n                return {\n                  top: l,\n                  bottom: s,\n                  left: o,\n                  right: i,\n                  width: i - o,\n                  height: s - l,\n                  x: o,\n                  y: l\n                };\n              }\n              return y;\n            }\n          },\n          floating: s.floating,\n          strategy: g\n        });\n        return u.reference.x !== v.reference.x || u.reference.y !== v.reference.y || u.reference.width !== v.reference.width || u.reference.height !== v.reference.height ? {\n          reset: {\n            rects: v\n          }\n        } : {};\n      }\n    };\n  };\nexport { m as arrow, v as autoPlacement, r as computePosition, s as detectOverflow, b as flip, P as hide, k as inline, L as limitShift, T as offset, l as rectToClientRect, E as shift, D as size };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
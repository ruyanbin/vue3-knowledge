{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { I3DMLoaderBase } from '../base/I3DMLoaderBase.js';\nimport { DefaultLoadingManager, Matrix4, InstancedMesh, Vector3, Quaternion } from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nconst tempFwd = new Vector3();\nconst tempUp = new Vector3();\nconst tempRight = new Vector3();\nconst tempPos = new Vector3();\nconst tempQuat = new Quaternion();\nconst tempSca = new Vector3();\nconst tempMat = new Matrix4();\nexport class I3DMLoader extends I3DMLoaderBase {\n  constructor(manager = DefaultLoadingManager) {\n    super();\n    this.manager = manager;\n    this.adjustmentTransform = new Matrix4();\n  }\n  resolveExternalURL(url) {\n    return this.manager.resolveURL(super.resolveExternalURL(url));\n  }\n  parse(buffer) {\n    return super.parse(buffer).then(i3dm => {\n      const {\n        featureTable,\n        batchTable\n      } = i3dm;\n      const gltfBuffer = i3dm.glbBytes.slice().buffer;\n      return new Promise((resolve, reject) => {\n        const fetchOptions = this.fetchOptions;\n        const manager = this.manager;\n        const loader = manager.getHandler('path.gltf') || new GLTFLoader(manager);\n        if (fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors') {\n          loader.setCrossOrigin('use-credentials');\n        }\n        if ('credentials' in fetchOptions) {\n          loader.setWithCredentials(fetchOptions.credentials === 'include');\n        }\n        if (fetchOptions.headers) {\n          loader.setRequestHeader(fetchOptions.headers);\n        }\n\n        // GLTFLoader assumes the working path ends in a slash\n        let workingPath = this.workingPath;\n        if (!/[\\\\/]$/.test(workingPath)) {\n          workingPath += '/';\n        }\n        const adjustmentTransform = this.adjustmentTransform;\n        loader.parse(gltfBuffer, workingPath, model => {\n          const INSTANCES_LENGTH = featureTable.getData('INSTANCES_LENGTH');\n          const POSITION = featureTable.getData('POSITION', INSTANCES_LENGTH, 'FLOAT', 'VEC3');\n          const NORMAL_UP = featureTable.getData('NORMAL_UP', INSTANCES_LENGTH, 'FLOAT', 'VEC3');\n          const NORMAL_RIGHT = featureTable.getData('NORMAL_RIGHT', INSTANCES_LENGTH, 'FLOAT', 'VEC3');\n          const SCALE_NON_UNIFORM = featureTable.getData('SCALE_NON_UNIFORM', INSTANCES_LENGTH, 'FLOAT', 'VEC3');\n          const SCALE = featureTable.getData('SCALE', INSTANCES_LENGTH, 'FLOAT', 'SCALAR');\n          ['RTC_CENTER', 'QUANTIZED_VOLUME_OFFSET', 'QUANTIZED_VOLUME_SCALE', 'EAST_NORTH_UP', 'POSITION_QUANTIZED', 'NORMAL_UP_OCT32P', 'NORMAL_RIGHT_OCT32P'].forEach(feature => {\n            if (feature in featureTable.header) {\n              console.warn(`I3DMLoader: Unsupported FeatureTable feature \"${feature}\" detected.`);\n            }\n          });\n          const instanceMap = new Map();\n          const instances = [];\n          model.scene.traverse(child => {\n            if (child.isMesh) {\n              const {\n                geometry,\n                material\n              } = child;\n              const instancedMesh = new InstancedMesh(geometry, material, INSTANCES_LENGTH);\n              instancedMesh.position.copy(child.position);\n              instancedMesh.rotation.copy(child.rotation);\n              instancedMesh.scale.copy(child.scale);\n              instances.push(instancedMesh);\n              instanceMap.set(child, instancedMesh);\n            }\n          });\n          const averageVector = new Vector3();\n          for (let i = 0; i < INSTANCES_LENGTH; i++) {\n            averageVector.x += POSITION[i * 3 + 0] / INSTANCES_LENGTH;\n            averageVector.y += POSITION[i * 3 + 1] / INSTANCES_LENGTH;\n            averageVector.z += POSITION[i * 3 + 2] / INSTANCES_LENGTH;\n          }\n\n          // replace the meshes with instanced meshes\n          instanceMap.forEach((instancedMesh, mesh) => {\n            const parent = mesh.parent;\n            if (parent) {\n              // Mesh have no children\n              parent.remove(mesh);\n              parent.add(instancedMesh);\n\n              // Center the instance around an average point to avoid jitter at large scales.\n              // Transform the average vector by matrix world so we can account for any existing\n              // transforms of the instanced mesh.\n              instancedMesh.updateMatrixWorld();\n              instancedMesh.position.copy(averageVector).applyMatrix4(instancedMesh.matrixWorld);\n            }\n          });\n          for (let i = 0; i < INSTANCES_LENGTH; i++) {\n            // position\n            tempPos.set(POSITION[i * 3 + 0] - averageVector.x, POSITION[i * 3 + 1] - averageVector.y, POSITION[i * 3 + 2] - averageVector.z);\n\n            // rotation\n            if (NORMAL_UP) {\n              tempUp.set(NORMAL_UP[i * 3 + 0], NORMAL_UP[i * 3 + 1], NORMAL_UP[i * 3 + 2]);\n              tempRight.set(NORMAL_RIGHT[i * 3 + 0], NORMAL_RIGHT[i * 3 + 1], NORMAL_RIGHT[i * 3 + 2]);\n              tempFwd.crossVectors(tempRight, tempUp).normalize();\n              tempMat.makeBasis(tempRight, tempUp, tempFwd);\n              tempQuat.setFromRotationMatrix(tempMat);\n            } else {\n              tempQuat.set(0, 0, 0, 1);\n            }\n\n            // scale\n            if (SCALE) {\n              tempSca.setScalar(SCALE[i]);\n            } else if (SCALE_NON_UNIFORM) {\n              tempSca.set(SCALE_NON_UNIFORM[i * 3 + 0], SCALE_NON_UNIFORM[i * 3 + 1], SCALE_NON_UNIFORM[i * 3 + 2]);\n            } else {\n              tempSca.set(1, 1, 1);\n            }\n            tempMat.compose(tempPos, tempQuat, tempSca).multiply(adjustmentTransform);\n            for (let j = 0, l = instances.length; j < l; j++) {\n              const instance = instances[j];\n              instance.setMatrixAt(i, tempMat);\n            }\n          }\n          model.batchTable = batchTable;\n          model.featureTable = featureTable;\n          model.scene.batchTable = batchTable;\n          model.scene.featureTable = featureTable;\n          resolve(model);\n        }, reject);\n      });\n    });\n  }\n}","map":{"version":3,"names":["I3DMLoaderBase","DefaultLoadingManager","Matrix4","InstancedMesh","Vector3","Quaternion","GLTFLoader","tempFwd","tempUp","tempRight","tempPos","tempQuat","tempSca","tempMat","I3DMLoader","constructor","manager","adjustmentTransform","resolveExternalURL","url","resolveURL","parse","buffer","then","i3dm","featureTable","batchTable","gltfBuffer","glbBytes","slice","Promise","resolve","reject","fetchOptions","loader","getHandler","credentials","mode","setCrossOrigin","setWithCredentials","headers","setRequestHeader","workingPath","test","model","INSTANCES_LENGTH","getData","POSITION","NORMAL_UP","NORMAL_RIGHT","SCALE_NON_UNIFORM","SCALE","forEach","feature","header","console","warn","instanceMap","Map","instances","scene","traverse","child","isMesh","geometry","material","instancedMesh","position","copy","rotation","scale","push","set","averageVector","i","x","y","z","mesh","parent","remove","add","updateMatrixWorld","applyMatrix4","matrixWorld","crossVectors","normalize","makeBasis","setFromRotationMatrix","setScalar","compose","multiply","j","l","length","instance","setMatrixAt"],"sources":["/Users/yanbinru/Desktop/代码/github/vue3-knowledge/node_modules/3d-tiles-renderer/src/three/I3DMLoader.js"],"sourcesContent":["import { I3DMLoaderBase } from '../base/I3DMLoaderBase.js';\nimport { DefaultLoadingManager, Matrix4, InstancedMesh, Vector3, Quaternion } from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nconst tempFwd = new Vector3();\nconst tempUp = new Vector3();\nconst tempRight = new Vector3();\nconst tempPos = new Vector3();\nconst tempQuat = new Quaternion();\nconst tempSca = new Vector3();\nconst tempMat = new Matrix4();\nexport class I3DMLoader extends I3DMLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis.adjustmentTransform = new Matrix4();\n\n\t}\n\n\tresolveExternalURL( url ) {\n\n\t\treturn this.manager.resolveURL( super.resolveExternalURL( url ) );\n\n\t}\n\n\tparse( buffer ) {\n\n\t\treturn super\n\t\t\t.parse( buffer )\n\t\t\t.then( i3dm => {\n\n\t\t\t\tconst { featureTable, batchTable } = i3dm;\n\t\t\t\tconst gltfBuffer = i3dm.glbBytes.slice().buffer;\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tconst fetchOptions = this.fetchOptions;\n\t\t\t\t\tconst manager = this.manager;\n\t\t\t\t\tconst loader = manager.getHandler( 'path.gltf' ) || new GLTFLoader( manager );\n\n\t\t\t\t\tif ( fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors' ) {\n\n\t\t\t\t\t\tloader.setCrossOrigin( 'use-credentials' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'credentials' in fetchOptions ) {\n\n\t\t\t\t\t\tloader.setWithCredentials( fetchOptions.credentials === 'include' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( fetchOptions.headers ) {\n\n\t\t\t\t\t\tloader.setRequestHeader( fetchOptions.headers );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// GLTFLoader assumes the working path ends in a slash\n\t\t\t\t\tlet workingPath = this.workingPath;\n\t\t\t\t\tif ( ! /[\\\\/]$/.test( workingPath ) ) {\n\n\t\t\t\t\t\tworkingPath += '/';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst adjustmentTransform = this.adjustmentTransform;\n\n\t\t\t\t\tloader.parse( gltfBuffer, workingPath, model => {\n\n\t\t\t\t\t\tconst INSTANCES_LENGTH = featureTable.getData( 'INSTANCES_LENGTH' );\n\t\t\t\t\t\tconst POSITION = featureTable.getData( 'POSITION', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst NORMAL_UP = featureTable.getData( 'NORMAL_UP', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst NORMAL_RIGHT = featureTable.getData( 'NORMAL_RIGHT', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst SCALE_NON_UNIFORM = featureTable.getData( 'SCALE_NON_UNIFORM', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst SCALE = featureTable.getData( 'SCALE', INSTANCES_LENGTH, 'FLOAT', 'SCALAR' );\n\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t'RTC_CENTER',\n\t\t\t\t\t\t\t'QUANTIZED_VOLUME_OFFSET',\n\t\t\t\t\t\t\t'QUANTIZED_VOLUME_SCALE',\n\t\t\t\t\t\t\t'EAST_NORTH_UP',\n\t\t\t\t\t\t\t'POSITION_QUANTIZED',\n\t\t\t\t\t\t\t'NORMAL_UP_OCT32P',\n\t\t\t\t\t\t\t'NORMAL_RIGHT_OCT32P',\n\t\t\t\t\t\t].forEach( feature => {\n\n\t\t\t\t\t\t\tif ( feature in featureTable.header ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( `I3DMLoader: Unsupported FeatureTable feature \"${ feature }\" detected.` );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tconst instanceMap = new Map();\n\t\t\t\t\t\tconst instances = [];\n\t\t\t\t\t\tmodel.scene.traverse( child => {\n\n\t\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\t\tconst { geometry, material } = child;\n\t\t\t\t\t\t\t\tconst instancedMesh = new InstancedMesh( geometry, material, INSTANCES_LENGTH );\n\t\t\t\t\t\t\t\tinstancedMesh.position.copy( child.position );\n\t\t\t\t\t\t\t\tinstancedMesh.rotation.copy( child.rotation );\n\t\t\t\t\t\t\t\tinstancedMesh.scale.copy( child.scale );\n\t\t\t\t\t\t\t\tinstances.push( instancedMesh );\n\t\t\t\t\t\t\t\tinstanceMap.set( child, instancedMesh );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tconst averageVector = new Vector3();\n\t\t\t\t\t\tfor ( let i = 0; i < INSTANCES_LENGTH; i ++ ) {\n\n\t\t\t\t\t\t\taverageVector.x += POSITION[ i * 3 + 0 ] / INSTANCES_LENGTH;\n\t\t\t\t\t\t\taverageVector.y += POSITION[ i * 3 + 1 ] / INSTANCES_LENGTH;\n\t\t\t\t\t\t\taverageVector.z += POSITION[ i * 3 + 2 ] / INSTANCES_LENGTH;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// replace the meshes with instanced meshes\n\t\t\t\t\t\tinstanceMap.forEach( ( instancedMesh, mesh ) => {\n\n\t\t\t\t\t\t\tconst parent = mesh.parent;\n\t\t\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t\t\t// Mesh have no children\n\t\t\t\t\t\t\t\tparent.remove( mesh );\n\t\t\t\t\t\t\t\tparent.add( instancedMesh );\n\n\t\t\t\t\t\t\t\t// Center the instance around an average point to avoid jitter at large scales.\n\t\t\t\t\t\t\t\t// Transform the average vector by matrix world so we can account for any existing\n\t\t\t\t\t\t\t\t// transforms of the instanced mesh.\n\t\t\t\t\t\t\t\tinstancedMesh.updateMatrixWorld();\n\t\t\t\t\t\t\t\tinstancedMesh\n\t\t\t\t\t\t\t\t\t.position\n\t\t\t\t\t\t\t\t\t.copy( averageVector )\n\t\t\t\t\t\t\t\t\t.applyMatrix4( instancedMesh.matrixWorld );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tfor ( let i = 0; i < INSTANCES_LENGTH; i ++ ) {\n\n\t\t\t\t\t\t\t// position\n\t\t\t\t\t\t\ttempPos.set(\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 0 ] - averageVector.x,\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 1 ] - averageVector.y,\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 2 ] - averageVector.z,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// rotation\n\t\t\t\t\t\t\tif ( NORMAL_UP ) {\n\n\t\t\t\t\t\t\t\ttempUp.set(\n\t\t\t\t\t\t\t\t\tNORMAL_UP[ i * 3 + 0 ],\n\t\t\t\t\t\t\t\t\tNORMAL_UP[ i * 3 + 1 ],\n\t\t\t\t\t\t\t\t\tNORMAL_UP[ i * 3 + 2 ],\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\ttempRight.set(\n\t\t\t\t\t\t\t\t\tNORMAL_RIGHT[ i * 3 + 0 ],\n\t\t\t\t\t\t\t\t\tNORMAL_RIGHT[ i * 3 + 1 ],\n\t\t\t\t\t\t\t\t\tNORMAL_RIGHT[ i * 3 + 2 ],\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\ttempFwd.crossVectors( tempRight, tempUp )\n\t\t\t\t\t\t\t\t\t.normalize();\n\n\t\t\t\t\t\t\t\ttempMat.makeBasis(\n\t\t\t\t\t\t\t\t\ttempRight,\n\t\t\t\t\t\t\t\t\ttempUp,\n\t\t\t\t\t\t\t\t\ttempFwd,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\ttempQuat.setFromRotationMatrix( tempMat );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttempQuat.set( 0, 0, 0, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// scale\n\t\t\t\t\t\t\tif ( SCALE ) {\n\n\t\t\t\t\t\t\t\ttempSca.setScalar( SCALE[ i ] );\n\n\t\t\t\t\t\t\t} else if ( SCALE_NON_UNIFORM ) {\n\n\t\t\t\t\t\t\t\ttempSca.set(\n\t\t\t\t\t\t\t\t\tSCALE_NON_UNIFORM[ i * 3 + 0 ],\n\t\t\t\t\t\t\t\t\tSCALE_NON_UNIFORM[ i * 3 + 1 ],\n\t\t\t\t\t\t\t\t\tSCALE_NON_UNIFORM[ i * 3 + 2 ],\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttempSca.set( 1, 1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\ttempMat.compose( tempPos, tempQuat, tempSca ).multiply( adjustmentTransform );\n\n\t\t\t\t\t\t\tfor ( let j = 0, l = instances.length; j < l; j ++ ) {\n\n\t\t\t\t\t\t\t\tconst instance = instances[ j ];\n\t\t\t\t\t\t\t\tinstance.setMatrixAt( i, tempMat );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tmodel.batchTable = batchTable;\n\t\t\t\t\t\tmodel.featureTable = featureTable;\n\n\t\t\t\t\t\tmodel.scene.batchTable = batchTable;\n\t\t\t\t\t\tmodel.scene.featureTable = featureTable;\n\n\t\t\t\t\t\tresolve( model );\n\n\t\t\t\t\t}, reject );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t}\n\n}\n"],"mappings":";AAAA,SAASA,cAAc,QAAQ,2BAA2B;AAC1D,SAASC,qBAAqB,EAAEC,OAAO,EAAEC,aAAa,EAAEC,OAAO,EAAEC,UAAU,QAAQ,OAAO;AAC1F,SAASC,UAAU,QAAQ,0CAA0C;AAErE,MAAMC,OAAO,GAAG,IAAIH,OAAO,EAAE;AAC7B,MAAMI,MAAM,GAAG,IAAIJ,OAAO,EAAE;AAC5B,MAAMK,SAAS,GAAG,IAAIL,OAAO,EAAE;AAC/B,MAAMM,OAAO,GAAG,IAAIN,OAAO,EAAE;AAC7B,MAAMO,QAAQ,GAAG,IAAIN,UAAU,EAAE;AACjC,MAAMO,OAAO,GAAG,IAAIR,OAAO,EAAE;AAC7B,MAAMS,OAAO,GAAG,IAAIX,OAAO,EAAE;AAC7B,OAAO,MAAMY,UAAU,SAASd,cAAc,CAAC;EAE9Ce,WAAW,CAAEC,OAAO,GAAGf,qBAAqB,EAAG;IAE9C,KAAK,EAAE;IACP,IAAI,CAACe,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,mBAAmB,GAAG,IAAIf,OAAO,EAAE;EAEzC;EAEAgB,kBAAkB,CAAEC,GAAG,EAAG;IAEzB,OAAO,IAAI,CAACH,OAAO,CAACI,UAAU,CAAE,KAAK,CAACF,kBAAkB,CAAEC,GAAG,CAAE,CAAE;EAElE;EAEAE,KAAK,CAAEC,MAAM,EAAG;IAEf,OAAO,KAAK,CACVD,KAAK,CAAEC,MAAM,CAAE,CACfC,IAAI,CAAEC,IAAI,IAAI;MAEd,MAAM;QAAEC,YAAY;QAAEC;MAAW,CAAC,GAAGF,IAAI;MACzC,MAAMG,UAAU,GAAGH,IAAI,CAACI,QAAQ,CAACC,KAAK,EAAE,CAACP,MAAM;MAC/C,OAAO,IAAIQ,OAAO,CAAE,CAAEC,OAAO,EAAEC,MAAM,KAAM;QAE1C,MAAMC,YAAY,GAAG,IAAI,CAACA,YAAY;QACtC,MAAMjB,OAAO,GAAG,IAAI,CAACA,OAAO;QAC5B,MAAMkB,MAAM,GAAGlB,OAAO,CAACmB,UAAU,CAAE,WAAW,CAAE,IAAI,IAAI7B,UAAU,CAAEU,OAAO,CAAE;QAE7E,IAAKiB,YAAY,CAACG,WAAW,KAAK,SAAS,IAAIH,YAAY,CAACI,IAAI,KAAK,MAAM,EAAG;UAE7EH,MAAM,CAACI,cAAc,CAAE,iBAAiB,CAAE;QAE3C;QAEA,IAAK,aAAa,IAAIL,YAAY,EAAG;UAEpCC,MAAM,CAACK,kBAAkB,CAAEN,YAAY,CAACG,WAAW,KAAK,SAAS,CAAE;QAEpE;QAEA,IAAKH,YAAY,CAACO,OAAO,EAAG;UAE3BN,MAAM,CAACO,gBAAgB,CAAER,YAAY,CAACO,OAAO,CAAE;QAEhD;;QAEA;QACA,IAAIE,WAAW,GAAG,IAAI,CAACA,WAAW;QAClC,IAAK,CAAE,QAAQ,CAACC,IAAI,CAAED,WAAW,CAAE,EAAG;UAErCA,WAAW,IAAI,GAAG;QAEnB;QAEA,MAAMzB,mBAAmB,GAAG,IAAI,CAACA,mBAAmB;QAEpDiB,MAAM,CAACb,KAAK,CAAEM,UAAU,EAAEe,WAAW,EAAEE,KAAK,IAAI;UAE/C,MAAMC,gBAAgB,GAAGpB,YAAY,CAACqB,OAAO,CAAE,kBAAkB,CAAE;UACnE,MAAMC,QAAQ,GAAGtB,YAAY,CAACqB,OAAO,CAAE,UAAU,EAAED,gBAAgB,EAAE,OAAO,EAAE,MAAM,CAAE;UACtF,MAAMG,SAAS,GAAGvB,YAAY,CAACqB,OAAO,CAAE,WAAW,EAAED,gBAAgB,EAAE,OAAO,EAAE,MAAM,CAAE;UACxF,MAAMI,YAAY,GAAGxB,YAAY,CAACqB,OAAO,CAAE,cAAc,EAAED,gBAAgB,EAAE,OAAO,EAAE,MAAM,CAAE;UAC9F,MAAMK,iBAAiB,GAAGzB,YAAY,CAACqB,OAAO,CAAE,mBAAmB,EAAED,gBAAgB,EAAE,OAAO,EAAE,MAAM,CAAE;UACxG,MAAMM,KAAK,GAAG1B,YAAY,CAACqB,OAAO,CAAE,OAAO,EAAED,gBAAgB,EAAE,OAAO,EAAE,QAAQ,CAAE;UAElF,CACC,YAAY,EACZ,yBAAyB,EACzB,wBAAwB,EACxB,eAAe,EACf,oBAAoB,EACpB,kBAAkB,EAClB,qBAAqB,CACrB,CAACO,OAAO,CAAEC,OAAO,IAAI;YAErB,IAAKA,OAAO,IAAI5B,YAAY,CAAC6B,MAAM,EAAG;cAErCC,OAAO,CAACC,IAAI,CAAG,iDAAiDH,OAAS,aAAY,CAAE;YAExF;UAED,CAAC,CAAE;UAEH,MAAMI,WAAW,GAAG,IAAIC,GAAG,EAAE;UAC7B,MAAMC,SAAS,GAAG,EAAE;UACpBf,KAAK,CAACgB,KAAK,CAACC,QAAQ,CAAEC,KAAK,IAAI;YAE9B,IAAKA,KAAK,CAACC,MAAM,EAAG;cAEnB,MAAM;gBAAEC,QAAQ;gBAAEC;cAAS,CAAC,GAAGH,KAAK;cACpC,MAAMI,aAAa,GAAG,IAAI/D,aAAa,CAAE6D,QAAQ,EAAEC,QAAQ,EAAEpB,gBAAgB,CAAE;cAC/EqB,aAAa,CAACC,QAAQ,CAACC,IAAI,CAAEN,KAAK,CAACK,QAAQ,CAAE;cAC7CD,aAAa,CAACG,QAAQ,CAACD,IAAI,CAAEN,KAAK,CAACO,QAAQ,CAAE;cAC7CH,aAAa,CAACI,KAAK,CAACF,IAAI,CAAEN,KAAK,CAACQ,KAAK,CAAE;cACvCX,SAAS,CAACY,IAAI,CAAEL,aAAa,CAAE;cAC/BT,WAAW,CAACe,GAAG,CAAEV,KAAK,EAAEI,aAAa,CAAE;YAExC;UAED,CAAC,CAAE;UAEH,MAAMO,aAAa,GAAG,IAAIrE,OAAO,EAAE;UACnC,KAAM,IAAIsE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,gBAAgB,EAAE6B,CAAC,EAAG,EAAG;YAE7CD,aAAa,CAACE,CAAC,IAAI5B,QAAQ,CAAE2B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,GAAG7B,gBAAgB;YAC3D4B,aAAa,CAACG,CAAC,IAAI7B,QAAQ,CAAE2B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,GAAG7B,gBAAgB;YAC3D4B,aAAa,CAACI,CAAC,IAAI9B,QAAQ,CAAE2B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,GAAG7B,gBAAgB;UAE5D;;UAEA;UACAY,WAAW,CAACL,OAAO,CAAE,CAAEc,aAAa,EAAEY,IAAI,KAAM;YAE/C,MAAMC,MAAM,GAAGD,IAAI,CAACC,MAAM;YAC1B,IAAKA,MAAM,EAAG;cAEb;cACAA,MAAM,CAACC,MAAM,CAAEF,IAAI,CAAE;cACrBC,MAAM,CAACE,GAAG,CAAEf,aAAa,CAAE;;cAE3B;cACA;cACA;cACAA,aAAa,CAACgB,iBAAiB,EAAE;cACjChB,aAAa,CACXC,QAAQ,CACRC,IAAI,CAAEK,aAAa,CAAE,CACrBU,YAAY,CAAEjB,aAAa,CAACkB,WAAW,CAAE;YAE5C;UAED,CAAC,CAAE;UAEH,KAAM,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,gBAAgB,EAAE6B,CAAC,EAAG,EAAG;YAE7C;YACAhE,OAAO,CAAC8D,GAAG,CACVzB,QAAQ,CAAE2B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,GAAGD,aAAa,CAACE,CAAC,EACvC5B,QAAQ,CAAE2B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,GAAGD,aAAa,CAACG,CAAC,EACvC7B,QAAQ,CAAE2B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,GAAGD,aAAa,CAACI,CAAC,CACvC;;YAED;YACA,IAAK7B,SAAS,EAAG;cAEhBxC,MAAM,CAACgE,GAAG,CACTxB,SAAS,CAAE0B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,EACtB1B,SAAS,CAAE0B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,EACtB1B,SAAS,CAAE0B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,CACtB;cAEDjE,SAAS,CAAC+D,GAAG,CACZvB,YAAY,CAAEyB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,EACzBzB,YAAY,CAAEyB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,EACzBzB,YAAY,CAAEyB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,CACzB;cAEDnE,OAAO,CAAC8E,YAAY,CAAE5E,SAAS,EAAED,MAAM,CAAE,CACvC8E,SAAS,EAAE;cAEbzE,OAAO,CAAC0E,SAAS,CAChB9E,SAAS,EACTD,MAAM,EACND,OAAO,CACP;cAEDI,QAAQ,CAAC6E,qBAAqB,CAAE3E,OAAO,CAAE;YAE1C,CAAC,MAAM;cAENF,QAAQ,CAAC6D,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;YAE3B;;YAEA;YACA,IAAKrB,KAAK,EAAG;cAEZvC,OAAO,CAAC6E,SAAS,CAAEtC,KAAK,CAAEuB,CAAC,CAAE,CAAE;YAEhC,CAAC,MAAM,IAAKxB,iBAAiB,EAAG;cAE/BtC,OAAO,CAAC4D,GAAG,CACVtB,iBAAiB,CAAEwB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,EAC9BxB,iBAAiB,CAAEwB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,EAC9BxB,iBAAiB,CAAEwB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE,CAC9B;YAEF,CAAC,MAAM;cAEN9D,OAAO,CAAC4D,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;YAEvB;YAGA3D,OAAO,CAAC6E,OAAO,CAAEhF,OAAO,EAAEC,QAAQ,EAAEC,OAAO,CAAE,CAAC+E,QAAQ,CAAE1E,mBAAmB,CAAE;YAE7E,KAAM,IAAI2E,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGlC,SAAS,CAACmC,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAG,EAAG;cAEpD,MAAMG,QAAQ,GAAGpC,SAAS,CAAEiC,CAAC,CAAE;cAC/BG,QAAQ,CAACC,WAAW,CAAEtB,CAAC,EAAE7D,OAAO,CAAE;YAEnC;UAED;UAGA+B,KAAK,CAAClB,UAAU,GAAGA,UAAU;UAC7BkB,KAAK,CAACnB,YAAY,GAAGA,YAAY;UAEjCmB,KAAK,CAACgB,KAAK,CAAClC,UAAU,GAAGA,UAAU;UACnCkB,KAAK,CAACgB,KAAK,CAACnC,YAAY,GAAGA,YAAY;UAEvCM,OAAO,CAAEa,KAAK,CAAE;QAEjB,CAAC,EAAEZ,MAAM,CAAE;MAEZ,CAAC,CAAE;IAEJ,CAAC,CAAE;EAEL;AAED"},"metadata":{},"sourceType":"module","externalDependencies":[]}
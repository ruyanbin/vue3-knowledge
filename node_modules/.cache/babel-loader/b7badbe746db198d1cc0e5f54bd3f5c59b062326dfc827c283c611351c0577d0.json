{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isPlainObject as e } from \"is-plain-object\";\nfunction t() {\n  return t = Object.assign ? Object.assign.bind() : function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, t.apply(this, arguments);\n}\nfunction n(e, t) {\n  if (null == e) return {};\n  var n,\n    r,\n    i = {},\n    o = Object.keys(e);\n  for (r = 0; r < o.length; r++) t.indexOf(n = o[r]) >= 0 || (i[n] = e[n]);\n  return i;\n}\nconst r = {\n    silent: !1,\n    logLevel: \"warn\"\n  },\n  i = [\"validator\"],\n  o = Object.prototype,\n  a = o.toString,\n  s = o.hasOwnProperty,\n  u = /^\\s*function (\\w+)/;\nfunction l(e) {\n  var t;\n  const n = null !== (t = null == e ? void 0 : e.type) && void 0 !== t ? t : e;\n  if (n) {\n    const e = n.toString().match(u);\n    return e ? e[1] : \"\";\n  }\n  return \"\";\n}\nconst c = e,\n  d = e => e;\nlet f = d;\nif (\"production\" !== process.env.NODE_ENV) {\n  const e = \"undefined\" != typeof console;\n  f = e ? function (e, t = r.logLevel) {\n    !1 === r.silent && console[t](`[VueTypes warn]: ${e}`);\n  } : d;\n}\nconst p = (e, t) => s.call(e, t),\n  y = Number.isInteger || function (e) {\n    return \"number\" == typeof e && isFinite(e) && Math.floor(e) === e;\n  },\n  v = Array.isArray || function (e) {\n    return \"[object Array]\" === a.call(e);\n  },\n  h = e => \"[object Function]\" === a.call(e),\n  b = (e, t) => c(e) && p(e, \"_vueTypes_name\") && (!t || e._vueTypes_name === t),\n  g = e => c(e) && (p(e, \"type\") || [\"_vueTypes_name\", \"validator\", \"default\", \"required\"].some(t => p(e, t)));\nfunction O(e, t) {\n  return Object.defineProperty(e.bind(t), \"__original\", {\n    value: e\n  });\n}\nfunction m(e, t, n = !1) {\n  let r,\n    i = !0,\n    o = \"\";\n  r = c(e) ? e : {\n    type: e\n  };\n  const a = b(r) ? r._vueTypes_name + \" - \" : \"\";\n  if (g(r) && null !== r.type) {\n    if (void 0 === r.type || !0 === r.type) return i;\n    if (!r.required && void 0 === t) return i;\n    v(r.type) ? (i = r.type.some(e => !0 === m(e, t, !0)), o = r.type.map(e => l(e)).join(\" or \")) : (o = l(r), i = \"Array\" === o ? v(t) : \"Object\" === o ? c(t) : \"String\" === o || \"Number\" === o || \"Boolean\" === o || \"Function\" === o ? function (e) {\n      if (null == e) return \"\";\n      const t = e.constructor.toString().match(u);\n      return t ? t[1] : \"\";\n    }(t) === o : t instanceof r.type);\n  }\n  if (!i) {\n    const e = `${a}value \"${t}\" should be of type \"${o}\"`;\n    return !1 === n ? (f(e), !1) : e;\n  }\n  if (p(r, \"validator\") && h(r.validator)) {\n    const e = f,\n      o = [];\n    if (f = e => {\n      o.push(e);\n    }, i = r.validator(t), f = e, !i) {\n      const e = (o.length > 1 ? \"* \" : \"\") + o.join(\"\\n* \");\n      return o.length = 0, !1 === n ? (f(e), i) : e;\n    }\n  }\n  return i;\n}\nfunction j(e, t) {\n  const n = Object.defineProperties(t, {\n      _vueTypes_name: {\n        value: e,\n        writable: !0\n      },\n      isRequired: {\n        get() {\n          return this.required = !0, this;\n        }\n      },\n      def: {\n        value(e) {\n          return void 0 === e ? this.type === Boolean || Array.isArray(this.type) && this.type.includes(Boolean) ? void (this.default = void 0) : (p(this, \"default\") && delete this.default, this) : h(e) || !0 === m(this, e, !0) ? (this.default = v(e) ? () => [...e] : c(e) ? () => Object.assign({}, e) : e, this) : (f(`${this._vueTypes_name} - invalid default value: \"${e}\"`), this);\n        }\n      }\n    }),\n    {\n      validator: r\n    } = n;\n  return h(r) && (n.validator = O(r, n)), n;\n}\nfunction _(e, t) {\n  const n = j(e, t);\n  return Object.defineProperty(n, \"validate\", {\n    value(e) {\n      return h(this.validator) && f(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:\\n${JSON.stringify(this)}`), this.validator = O(e, this), this;\n    }\n  });\n}\nfunction T(e, t, r) {\n  const o = function (e) {\n    const t = {};\n    return Object.getOwnPropertyNames(e).forEach(n => {\n      t[n] = Object.getOwnPropertyDescriptor(e, n);\n    }), Object.defineProperties({}, t);\n  }(t);\n  if (o._vueTypes_name = e, !c(r)) return o;\n  const {\n      validator: a\n    } = r,\n    s = n(r, i);\n  if (h(a)) {\n    let {\n      validator: e\n    } = o;\n    e && (e = null !== (l = (u = e).__original) && void 0 !== l ? l : u), o.validator = O(e ? function (t) {\n      return e.call(this, t) && a.call(this, t);\n    } : a, o);\n  }\n  var u, l;\n  return Object.assign(o, s);\n}\nfunction $(e) {\n  return e.replace(/^(?!\\s*$)/gm, \"  \");\n}\nconst w = () => _(\"any\", {}),\n  x = () => _(\"function\", {\n    type: Function\n  }),\n  P = () => _(\"boolean\", {\n    type: Boolean\n  }),\n  A = () => _(\"string\", {\n    type: String\n  }),\n  E = () => _(\"number\", {\n    type: Number\n  }),\n  S = () => _(\"array\", {\n    type: Array\n  }),\n  N = () => _(\"object\", {\n    type: Object\n  }),\n  V = () => j(\"integer\", {\n    type: Number,\n    validator(e) {\n      const t = y(e);\n      return !1 === t && f(`integer - \"${e}\" is not an integer`), t;\n    }\n  }),\n  q = () => j(\"symbol\", {\n    validator(e) {\n      const t = \"symbol\" == typeof e;\n      return !1 === t && f(`symbol - invalid value \"${e}\"`), t;\n    }\n  }),\n  k = () => Object.defineProperty({\n    type: null,\n    validator(e) {\n      const t = null === e;\n      return !1 === t && f(\"nullable - value should be null\"), t;\n    }\n  }, \"_vueTypes_name\", {\n    value: \"nullable\"\n  });\nfunction D(e, t = \"custom validation failed\") {\n  if (\"function\" != typeof e) throw new TypeError(\"[VueTypes error]: You must provide a function as argument\");\n  return j(e.name || \"<<anonymous function>>\", {\n    type: null,\n    validator(n) {\n      const r = e(n);\n      return r || f(`${this._vueTypes_name} - ${t}`), r;\n    }\n  });\n}\nfunction L(e) {\n  if (!v(e)) throw new TypeError(\"[VueTypes error]: You must provide an array as argument.\");\n  const t = `oneOf - value should be one of \"${e.map(e => \"symbol\" == typeof e ? e.toString() : e).join('\", \"')}\".`,\n    n = {\n      validator(n) {\n        const r = -1 !== e.indexOf(n);\n        return r || f(t), r;\n      }\n    };\n  if (-1 === e.indexOf(null)) {\n    const t = e.reduce((e, t) => {\n      if (null != t) {\n        const n = t.constructor;\n        -1 === e.indexOf(n) && e.push(n);\n      }\n      return e;\n    }, []);\n    t.length > 0 && (n.type = t);\n  }\n  return j(\"oneOf\", n);\n}\nfunction B(e) {\n  if (!v(e)) throw new TypeError(\"[VueTypes error]: You must provide an array as argument\");\n  let t = !1,\n    n = !1,\n    r = [];\n  for (let i = 0; i < e.length; i += 1) {\n    const o = e[i];\n    if (g(o)) {\n      if (h(o.validator) && (t = !0), b(o, \"oneOf\") && o.type) {\n        r = r.concat(o.type);\n        continue;\n      }\n      if (b(o, \"nullable\")) {\n        n = !0;\n        continue;\n      }\n      if (!0 === o.type || !o.type) {\n        f('oneOfType - invalid usage of \"true\" and \"null\" as types.');\n        continue;\n      }\n      r = r.concat(o.type);\n    } else r.push(o);\n  }\n  r = r.filter((e, t) => r.indexOf(e) === t);\n  const i = !1 === n && r.length > 0 ? r : null;\n  return j(\"oneOfType\", t ? {\n    type: i,\n    validator(t) {\n      const n = [],\n        r = e.some(e => {\n          const r = m(e, t, !0);\n          return \"string\" == typeof r && n.push(r), !0 === r;\n        });\n      return r || f(`oneOfType - provided value does not match any of the ${n.length} passed-in validators:\\n${$(n.join(\"\\n\"))}`), r;\n    }\n  } : {\n    type: i\n  });\n}\nfunction F(e) {\n  return j(\"arrayOf\", {\n    type: Array,\n    validator(t) {\n      let n = \"\";\n      const r = t.every(t => (n = m(e, t, !0), !0 === n));\n      return r || f(`arrayOf - value validation error:\\n${$(n)}`), r;\n    }\n  });\n}\nfunction Y(e) {\n  return j(\"instanceOf\", {\n    type: e\n  });\n}\nfunction I(e) {\n  return j(\"objectOf\", {\n    type: Object,\n    validator(t) {\n      let n = \"\";\n      const r = Object.keys(t).every(r => (n = m(e, t[r], !0), !0 === n));\n      return r || f(`objectOf - value validation error:\\n${$(n)}`), r;\n    }\n  });\n}\nfunction J(e) {\n  const t = Object.keys(e),\n    n = t.filter(t => {\n      var n;\n      return !(null === (n = e[t]) || void 0 === n || !n.required);\n    }),\n    r = j(\"shape\", {\n      type: Object,\n      validator(r) {\n        if (!c(r)) return !1;\n        const i = Object.keys(r);\n        if (n.length > 0 && n.some(e => -1 === i.indexOf(e))) {\n          const e = n.filter(e => -1 === i.indexOf(e));\n          return f(1 === e.length ? `shape - required property \"${e[0]}\" is not defined.` : `shape - required properties \"${e.join('\", \"')}\" are not defined.`), !1;\n        }\n        return i.every(n => {\n          if (-1 === t.indexOf(n)) return !0 === this._vueTypes_isLoose || (f(`shape - shape definition does not include a \"${n}\" property. Allowed keys: \"${t.join('\", \"')}\".`), !1);\n          const i = m(e[n], r[n], !0);\n          return \"string\" == typeof i && f(`shape - \"${n}\" property validation error:\\n ${$(i)}`), !0 === i;\n        });\n      }\n    });\n  return Object.defineProperty(r, \"_vueTypes_isLoose\", {\n    writable: !0,\n    value: !1\n  }), Object.defineProperty(r, \"loose\", {\n    get() {\n      return this._vueTypes_isLoose = !0, this;\n    }\n  }), r;\n}\nconst M = [\"name\", \"validate\", \"getter\"],\n  R = /*#__PURE__*/(() => {\n    var e;\n    return (e = class {\n      static get any() {\n        return w();\n      }\n      static get func() {\n        return x().def(this.defaults.func);\n      }\n      static get bool() {\n        return void 0 === this.defaults.bool ? P() : P().def(this.defaults.bool);\n      }\n      static get string() {\n        return A().def(this.defaults.string);\n      }\n      static get number() {\n        return E().def(this.defaults.number);\n      }\n      static get array() {\n        return S().def(this.defaults.array);\n      }\n      static get object() {\n        return N().def(this.defaults.object);\n      }\n      static get integer() {\n        return V().def(this.defaults.integer);\n      }\n      static get symbol() {\n        return q();\n      }\n      static get nullable() {\n        return k();\n      }\n      static extend(e) {\n        if (f(\"VueTypes.extend is deprecated. Use the ES6+ method instead. See https://dwightjack.github.io/vue-types/advanced/extending-vue-types.html#extending-namespaced-validators-in-es6 for details.\"), v(e)) return e.forEach(e => this.extend(e)), this;\n        const {\n            name: t,\n            validate: r = !1,\n            getter: i = !1\n          } = e,\n          o = n(e, M);\n        if (p(this, t)) throw new TypeError(`[VueTypes error]: Type \"${t}\" already defined`);\n        const {\n          type: a\n        } = o;\n        if (b(a)) return delete o.type, Object.defineProperty(this, t, i ? {\n          get: () => T(t, a, o)\n        } : {\n          value(...e) {\n            const n = T(t, a, o);\n            return n.validator && (n.validator = n.validator.bind(n, ...e)), n;\n          }\n        });\n        let s;\n        return s = i ? {\n          get() {\n            const e = Object.assign({}, o);\n            return r ? _(t, e) : j(t, e);\n          },\n          enumerable: !0\n        } : {\n          value(...e) {\n            const n = Object.assign({}, o);\n            let i;\n            return i = r ? _(t, n) : j(t, n), n.validator && (i.validator = n.validator.bind(i, ...e)), i;\n          },\n          enumerable: !0\n        }, Object.defineProperty(this, t, s);\n      }\n    }).defaults = {}, e.sensibleDefaults = void 0, e.config = r, e.custom = D, e.oneOf = L, e.instanceOf = Y, e.oneOfType = B, e.arrayOf = F, e.objectOf = I, e.shape = J, e.utils = {\n      validate: (e, t) => !0 === m(t, e, !0),\n      toType: (e, t, n = !1) => n ? _(e, t) : j(e, t)\n    }, e;\n  })();\nfunction U(e = {\n  func: () => {},\n  bool: !0,\n  string: \"\",\n  number: 0,\n  array: () => [],\n  object: () => ({}),\n  integer: 0\n}) {\n  var n;\n  return (n = class extends R {\n    static get sensibleDefaults() {\n      return t({}, this.defaults);\n    }\n    static set sensibleDefaults(n) {\n      this.defaults = !1 !== n ? t({}, !0 !== n ? n : e) : {};\n    }\n  }).defaults = t({}, e), n;\n}\nclass z extends U() {}\nexport { w as any, S as array, F as arrayOf, P as bool, r as config, U as createTypes, D as custom, z as default, T as fromType, x as func, Y as instanceOf, V as integer, k as nullable, E as number, N as object, I as objectOf, L as oneOf, B as oneOfType, J as shape, A as string, q as symbol, j as toType, _ as toValidableType, m as validateType };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}